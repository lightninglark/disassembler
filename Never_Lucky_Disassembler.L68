00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/23/2017 4:59:02 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010B6             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 0000193C             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 000019E3             28  GET_INPUT   LEA         STA_MSG,A1  *Load STA_MSG into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display start address msg
0000102A  4E4F                      30              TRAP        #15         
0000102C                            31              
0000102C  43F9 00001A4D             32              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
00001032  103C 0002                 33              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  4EB9 00001062             36              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000103E  4281                      37              CLR.L       D1          *Clear input length from D1
00001040                            38              
00001040  43F9 00001A06             39              LEA         END_MSG,A1  *Load END_MSG into A1
00001046  103C 000E                 40              MOVE.B      #14,D0      *Trap task 14, display end address msg
0000104A  4E4F                      41              TRAP        #15
0000104C                            42              
0000104C  43F9 00001A75             43              LEA         END_ADDR,A1 *Store input in END_ADDR variable
00001052  103C 0002                 44              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001056  4E4F                      45              TRAP        #15         
00001058                            46              
00001058  4EB9 0000106E             47              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000105E  4281                      48              CLR.L       D1          *Clear input length from D1
00001060                            49              
00001060  4E75                      50              RTS
00001062                            51              
00001062                            52  *--------------------PROC_STA-------------------------------
00001062                            53  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
00001062  4EB9 0000107A             54              JSR         ASCII_HEX   *Convert input into Hex
00001068                            55              
00001068                            56              *assuming all error checking is done before the next instruction (not yet implemented)
00001068                            57              
00001068  2A43                      58              MOVEA.L     D3,A5       *Move hex to STA_ADDR
0000106A  4283                      59              CLR.L       D3          *Clear D3
0000106C  4E75                      60              RTS                     
0000106E                            61  
0000106E                            62  *--------------------PROC_END-------------------------------
0000106E                            63  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000106E                            64              *      does not fall before start
0000106E  4EB9 0000107A             65              JSR         ASCII_HEX   *Convert input into Hex
00001074                            66              
00001074                            67              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            68              
00001074  2C43                      69              MOVE.L      D3,A6       *Move hex to END_ADDR
00001076  4283                      70              CLR.L       D3          *Clear D3
00001078  4E75                      71              RTS
0000107A                            72  
0000107A                            73  *-------------------ASCII_HEX-------------------------------
0000107A  0C01 0000                 74  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000107E  6700 0012                 75              BEQ         AH_DONE     *End subroutine if all converted
00001082  1419                      76              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001084  183C 0039                 77              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001088  B404                      78              CMP.B       D4,D2       *Check if ascii code is for a number or letter
0000108A  6F00 0008                 79              BLE         NUM         *Codes less than $39 imply a number, so branch
0000108E  6000 000E                 80              BRA         LET         *If not a number, must be a letter.            
00001092  4E75                      81  AH_DONE     RTS
00001094                            82  
00001094  183C 0030                 83  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
00001098  9404                      84              SUB.B       D4,D2       *convert to hexadecimal number
0000109A  6000 000C                 85              BRA         FORMAT      *branch to subroutine to store converted hex number
0000109E                            86              
0000109E  183C 0037                 87  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010A2  9404                      88              SUB.B       D4,D2       *convert to hexadecimal letter
000010A4  6000 0002                 89              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010A8                            90  
000010A8  5301                      91  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010AA  D602                      92              ADD.B       D2,D3       *Store converted number in D3
000010AC  0C01 0000                 93              CMPI.B      #$0,D1      *Check if we're all done converting
000010B0  67C8                      94              BEQ         ASCII_HEX   *If not continue conversion
000010B2  E983                      95              ASL.L       #4,D3       *Shift bits to the left to correct position
000010B4  60C4                      96              BRA         ASCII_HEX   *Branch back to label
000010B6                            97              
000010B6                            98  *-------------------DECODE_LOOP-----------------------------
000010B6  3E1D                      99  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010B8  47F9 00001A9E            100              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010BE  49F9 00001ADE            101              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010C4                           102              
000010C4  4EB9 00001122            103              JSR         INIT_STRS   *Initialize Bad and Good Str
000010CA                           104              
000010CA  4EB9 0000125A            105              JSR         JMP_TBL     *Start opcode identification waterfall
000010D0                           106              
000010D0  4EB9 0000117C            107              JSR         CLEAN_GS    *end of output string.
000010D6                           108              
000010D6  4EB9 00001222            109  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010DC  6000 000C                110              BRA         CONTINUE    *Continue the loop
000010E0  4EB9 00001238            111  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010E6  6000 0002                112              BRA         CONTINUE    *Continue the loop            
000010EA                           113              
000010EA  BCCD                     114  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010EC  6700 0160                115              BEQ         END_OPT     *if we're done, move to end options (ask user what to do)
000010F0                           116              
000010F0                           117                          
000010F0  5205                     118              ADDQ.B      #1,D5       *Increment line counter
000010F2  BA3C 0018                119              CMP.B       #24,D5      *See if page is full
000010F6  6700 0004                120              BEQ         NEXT_PAGE   *Jump to next page prompt
000010FA                           121              
000010FA  60BA                     122              BRA         DECODE_LOOP * Continue loop
000010FC                           123  
000010FC                           124  *-------------------NEXT_PAGE-----------------------------
000010FC  43F9 00001A27            125  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001102  4280                     126              CLR.L       D0          *Make sure D0 is empty
00001104  103C 000E                127              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001108  4E4F                     128              TRAP        #15            
0000110A                           129              
0000110A  103C 000C                130              MOVE.B      #12,D0      *Keyboard echo trap task
0000110E  4281                     131              CLR.L       D1          *Start keyboard echo trap
00001110  4E4F                     132              TRAP        #15         
00001112                           133              
00001112  103C 0005                134              MOVE.B      #5,D0       *Single char trap task
00001116  4E4F                     135              TRAP        #15         
00001118                           136              
00001118  B23C 000D                137              CMP.B       #$D,D1      *Check if ENTER key was pressed
0000111C  66DE                     138              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
0000111E                           139              
0000111E  4285                     140              CLR.L       D5          *Reset page counter
00001120                           141              
00001120  6094                     142              BRA         DECODE_LOOP *Continue the loop         
00001122                           143              
00001122                           144  *-------------------INIT_STRS-----------------------------
00001122  4EB9 00001130            145  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001128  4EB9 00001144            146              JSR         INIT_BAD    *Initialize the bad string
0000112E  4E75                     147              RTS
00001130                           148  *-------------------INIT_GOOD-----------------------------
00001130                           149  INIT_GOOD   
00001130                           150  *            MOVE.B      #'L',(A4)+  *Add to good string  
00001130                           151  *            MOVE.B      #'e',(A4)+ 
00001130                           152  *            MOVE.B      #'g',(A4)+ 
00001130                           153  *            MOVE.B      #'a',(A4)+ 
00001130                           154  *            MOVE.B      #'l',(A4)+
00001130                           155  *            MOVE.B      #' ',(A4)+
00001130                           156  *            MOVE.B      #' ',(A4)+ 
00001130                           157  *            MOVE.B      #':',(A4)+
00001130                           158  *            MOVE.B      #' ',(A4)+ 
00001130                           159  
00001130  18FC 0024                160              MOVE.B      #'$',(A4)+ 
00001134  4EB9 000011DA            161              JSR         HEX_ASCII_G *Now convert opcode to ASCII
0000113A                           162              
0000113A  18FC 0020                163              MOVE.B      #' ',(A4)+  *Add spaces after memory location added
0000113E  18FC 0020                164              MOVE.B      #' ',(A4)+
00001142                           165              
00001142                           166              *Add 'Legal: ', then add opcode (must go from hex to ascii)
00001142                           167              
00001142                           168              
00001142  4E75                     169              RTS
00001144                           170  
00001144                           171  *-------------------INIT_BAD------------------------------            
00001144  16FC 0049                172  INIT_BAD    MOVE.B      #'I',(A3)+  *Add to bad string
00001148  16FC 006C                173              MOVE.B      #'l',(A3)+ 
0000114C  16FC 006C                174              MOVE.B      #'l',(A3)+    
00001150  16FC 0065                175              MOVE.B      #'e',(A3)+ 
00001154  16FC 0067                176              MOVE.B      #'g',(A3)+ 
00001158  16FC 0061                177              MOVE.B      #'a',(A3)+ 
0000115C  16FC 006C                178              MOVE.B      #'l',(A3)+ 
00001160  16FC 003A                179              MOVE.B      #':',(A3)+
00001164  16FC 0020                180              MOVE.B      #' ',(A3)+ 
00001168  16FC 0024                181              MOVE.B      #'$',(A3)+  
0000116C                           182              
0000116C  4EB9 00001194            183              JSR         HEX_ASCII_B *Now convert opcode to ASCII
00001172                           184              
00001172  16FC 0020                185              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001176  16FC 0020                186              MOVE.B      #' ',(A3)+
0000117A                           187              
0000117A                           188              *Add 'Illegal: ', then add opcode (must go from from hex to ascii)
0000117A                           189              
0000117A  4E75                     190              RTS
0000117C                           191  
0000117C                           192  *-------------------GS_CLEAN--------------------------------
0000117C                           193  * This subroutine "cleans" the end of the good string.
0000117C                           194  * Prevents the previous string from showing content in the
0000117C                           195  * current string.
0000117C                           196  *-----------------------------------------------------------
0000117C  4280                     197  CLEAN_GS    CLR.L       D0
0000117E  103C 000F                198              MOVE.B      #15,D0      *Max 15 chars to clean
00001182                           199  
00001182  0C00 0000                200  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001186  6700 000A                201              BEQ         D_CLEAN
0000118A  18FC 0020                202              MOVE.B      #' ',(A4)+
0000118E  5300                     203              SUBI.B      #$1,D0
00001190  60F0                     204              BRA         GS_LOOP
00001192  4E75                     205  D_CLEAN     RTS
00001194                           206              
00001194                           207              
00001194                           208  *-------------------HEX_ASCII_B-----------------------------
00001194  4280                     209  HEX_ASCII_B CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     210              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     211              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     212              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  3207                     213              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000119E  103C 0004                214              MOVE.B      #$4,D0      *Counter
000011A2  6000 0002                215              BRA         ISO_DIG_B   *Begin isolating chars
000011A6                           216              
000011A6  E959                     217  ISO_DIG_B   ROL.W       #4,D1       *Move first significant hex char to least sig position
000011A8                           218              
000011A8  2401                     219              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AA                           220              
000011AA  163C 001C                221              MOVE.B      #28,D3      *Shift left 28 times
000011AE  E7AA                     222              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B0  E99A                     223              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B2                           224              
000011B2  0C02 0009                225              CMPI.B      #$9,D2      *Is it a number?
000011B6  6F00 0006                226              BLE         NUM_B       *If it is, process number
000011BA  6000 000A                227              BRA         LET_B       *If not, process letter
000011BE                           228  
000011BE  0602 0030                229  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
000011C2  6000 000A                230              BRA         ADD_CHAR_B  *add to strings and continue
000011C6                           231              
000011C6  0602 0037                232  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
000011CA  6000 0002                233              BRA         ADD_CHAR_B  *add to strings and continue
000011CE                           234              
000011CE  16C2                     235  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to bad data string
000011D0  5300                     236              SUBI.B      #$1,D0      *decrement counter
000011D2  0C00 0000                237              CMPI.B      #$0,D0      *Check if we're done            
000011D6  6ECE                     238              BGT         ISO_DIG_B   *If not, continue tranlation   
000011D8                           239              
000011D8  4E75                     240              RTS
000011DA                           241              
000011DA                           242  *-------------------HEX_ASCII_G-------------------------------            
000011DA  4280                     243  HEX_ASCII_G CLR.L       D0          *Make sure D0 is empty (Counter)
000011DC  4281                     244              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011DE  4282                     245              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E0  4283                     246              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E2  220D                     247              MOVE.L      A5,D1       *Copy address into D1
000011E4  5501                     248              SUBI.B      #2,D1       *Move addres back one byte (for post increment)
000011E6  103C 0008                249              MOVE.B      #$8,D0      *Counter
000011EA  6000 0002                250              BRA         ISO_DIG_G   *Begin isolating chars
000011EE                           251              
000011EE  E999                     252  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F0                           253              
000011F0  2401                     254              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F2                           255              
000011F2  163C 001C                256              MOVE.B      #28,D3      *Shift left 28 times
000011F6  E7AA                     257              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011F8  E99A                     258              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FA                           259              
000011FA  0C02 0009                260              CMPI.B      #$9,D2      *Is it a number?
000011FE  6F00 0006                261              BLE         NUM_G       *If it is, process number
00001202  6000 000A                262              BRA         LET_G       *If not, process letter
00001206                           263              
00001206  0602 0030                264  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
0000120A  6000 000A                265              BRA         ADD_CHAR_G  *add to strings and continue
0000120E                           266              
0000120E  0602 0037                267  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
00001212  6000 0002                268              BRA         ADD_CHAR_G  *add to strings and continue
00001216                           269  
00001216  18C2                     270  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
00001218  5300                     271              SUBI.B      #$1,D0      *decrement counter
0000121A  0C00 0000                272              CMPI.B      #$0,D0      *Check if we're done            
0000121E  6ECE                     273              BGT         ISO_DIG_G    *If not, continue tranlation   
00001220                           274              
00001220  4E75                     275              RTS
00001222                           276              
00001222                           277  *-------------------PRINT_G---------------------------------
00001222  18FC 0020                278  PRINT_G     MOVE.B      #' ',(A4)+
00001226  16FC 0000                279              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
0000122A  43F9 00001ADE            280              LEA         GOOD_STR,A1 *Load good data for printing
00001230  103C 000D                281              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001234  4E4F                     282              TRAP        #15         *Display string
00001236                           283            
00001236  4E75                     284              RTS 
00001238                           285  
00001238                           286  *-------------------PRINT_B---------------------------------
00001238  18FC 0020                287  PRINT_B     MOVE.B      #' ',(A4)+
0000123C  18FC 0000                288              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001240  43F9 00001A9E            289              LEA         BAD_STR,A1 *Load good data for printing
00001246  103C 000D                290              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000124A  4E4F                     291              TRAP        #15         *Display string
0000124C                           292              
0000124C  4E75                     293              RTS 
0000124E                           294  
0000124E                           295  *-------------------END_OPT---------------------------------
0000124E  4EF9 00001254            296  END_OPT     JMP         DONE        *Jump to done for now untill end options logic is implemented
00001254                           297              
00001254                           298  *-----------------------DONE--------------------------------
00001254  103C 0009                299  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
00001258  4E4F                     300              TRAP        #15         *Halt program, Trap#15 task 9
0000125A                           301              
0000125A                           302  *---------------Variables and Constants---------------------
0000125A                           303              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
0000125A                           304  
0000125A                           305  
0000125A  4282                     306  JMP_TBL     CLR.L       D2
0000125C  3407                     307              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000125E  4281                     308              CLR.L       D1
00001260  123C 000C                309              MOVE.B      #12,D1      *Moves 12 into D1
00001264  E26A                     310              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
00001266                           311                          
00001266  B43C 0000                312  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
0000126A  6600 000A                313              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
0000126E  4EB9 00001392            314              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
00001274  4E75                     315              RTS                     *Finished all jumping; whole instruction should be identified at this point
00001276                           316              
00001276  B43C 0001                317  JMP_1       CMP.B       #$1,D2
0000127A  6600 000A                318              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
0000127E  4EB9 0000145E            319              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
00001284  4E75                     320              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
00001286                           321             
00001286  B43C 0002                322  JMP_2       CMP.B       #$2,D2
0000128A  6600 000A                323              BNE         JMP_3 
0000128E  4EB9 000013BC            324              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
00001294  4E75                     325              RTS
00001296                           326              
00001296  B43C 0003                327  JMP_3       CMP.B       #$3,D2
0000129A  6600 000A                328              BNE         JMP_4
0000129E  4EB9 000013E0            329              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
000012A4  4E75                     330              RTS
000012A6                           331           
000012A6  B43C 0004                332  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
000012AA  6600 000A                333              BNE         JMP_5
000012AE  4EB9 00001404            334              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
000012B4  4E75                     335              RTS
000012B6                           336              
000012B6  B43C 0005                337  JMP_5       CMP.B       #$5,D2
000012BA  6600 000A                338              BNE         JMP_6
000012BE  4EB9 00001488            339              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
000012C4  4E75                     340              RTS
000012C6                           341              
000012C6  B43C 0006                342  JMP_6       CMP.B       #$6,D2
000012CA  6600 000A                343              BNE         JMP_7
000012CE  4EB9 00001442            344              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
000012D4  4E75                     345              RTS
000012D6                           346              
000012D6  B43C 0007                347  JMP_7       CMP.B       #$7,D2
000012DA  6600 000A                348              BNE         JMP_8
000012DE  4EB9 000014AA            349              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
000012E4  4E75                     350              RTS
000012E6                           351              
000012E6  B43C 0008                352  JMP_8       CMP.B       #$8,D2
000012EA  6600 000A                353              BNE         JMP_9
000012EE  4EB9 00001446            354              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000012F4  4E75                     355              RTS
000012F6                           356              
000012F6  B43C 0009                357  JMP_9       CMP.B       #$9,D2
000012FA  6600 000A                358              BNE         JMP_A
000012FE  4EB9 000014C8            359              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
00001304  4E75                     360              RTS
00001306                           361              
00001306  B43C 000A                362  JMP_A       CMP.B       #$A,D2
0000130A  6600 0008                363              BNE         JMP_B
0000130E  4EB8 10E0                364              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
00001312  4E75                     365              RTS
00001314                           366              
00001314  B43C 000B                367  JMP_B       CMP.B       #$B,D2
00001318  6600 0008                368              BNE         JMP_C
0000131C  4EB8 10E0                369              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
00001320  4E75                     370              RTS
00001322                           371              
00001322  B43C 000C                372  JMP_C       CMP.B       #$C,D2
00001326  6600 000A                373              BNE         JMP_D
0000132A  4EB9 0000144A            374              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
00001330  4E75                     375              RTS
00001332                           376              
00001332  B43C 000D                377  JMP_D       CMP.B       #$D,D2
00001336  6600 000A                378              BNE         JMP_E   
0000133A  4EB9 0000144E            379              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
00001340  4E75                     380              RTS
00001342                           381              
00001342  B43C 000F                382  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
00001346  6700 FD98                383              BEQ         INVALID     *If first hex value is F, jump to INVALID
0000134A  4EB9 00001452            384              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001350  4E75                     385              RTS
00001352                           386   
00001352  4282                     387  J_CLR4      CLR.L       D2                                
00001354  3407                     388              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001356  4281                     389              CLR.L       D1
00001358  E94A                     390              LSL.W       #4,D2       *Clear the most sig hex digit
0000135A  123C 000C                391              MOVE.B      #12,D1      *Moves 12 into D1
0000135E  E26A                     392              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001360  4E75                     393              RTS                     *Return back to JMP_Xn    
00001362                           394              
00001362  4282                     395  J_CLR3      CLR.L       D2          
00001364  3407                     396              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001366  4281                     397              CLR.L       D1
00001368  E94A                     398              LSL.W       #4,D2       *Clear the most sig hex digit
0000136A  123C 000D                399              MOVE.B      #13,D1      *Moves 13 into D1
0000136E  E26A                     400              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001370  4E75                     401              RTS                     *Return back to JMP_Xn  
00001372                           402  
00001372  4282                     403  J_CLR1  CLR.L       D2          
00001374  3407                     404          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001376  4281                     405          CLR.L       D1
00001378  EF4A                     406          LSL.W       #7,D2           *Clear the most sig 7 bits
0000137A  123C 0010                407          MOVE.B      #16,D1          *Moves 16 into D1
0000137E  E26A                     408          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001380  4E75                     409          RTS                         *Return back to JMP_Xn  
00001382                           410       
00001382  4282                     411  J_CLR_DM    CLR.L       D2          
00001384  3407                     412              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001386  4281                     413              CLR.L       D1
00001388  EF4A                     414              LSL.W       #7,D2       *Clear the most sig 7 bits
0000138A  123C 0011                415              MOVE.B      #17,D1      *Moves 17 into D1
0000138E  E26A                     416              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001390  4E75                     417              RTS                     *Return back to JMP_Xn     
00001392                           418   
00001392                           419  
00001392                           420          
00001392  4EB8 1352                421  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
00001396  B43C 0004                422              CMP.B       #$4,D2      *Is the next hex digit 4?
0000139A  6700 0010                423              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
0000139E  B43C 0005                424              CMP.B       #$5,D2      *Is the next hex digit 5?
000013A2  6700 0010                425              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
000013A6  4EB8 10E0                426              JSR         INVALID     *If neither, OPCODE is invalid
000013AA  4E75                     427              RTS
000013AC                           428  
000013AC  4EB9 00001456            429  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
000013B2  4E75                     430              RTS
000013B4                           431              
000013B4  4EB9 0000145A            432  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
000013BA  4E75                     433              RTS              
000013BC                           434  
000013BC  4EB8 1382                435  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013C0  B43C 0001                436              CMP.B       #$1,D2      *is the DEST MODE 1?
000013C4  6700 000A                437              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000013C8  4EB9 000013D8            438              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000013CE  4E75                     439              RTS
000013D0                           440  
000013D0  4EB9 000014EA            441  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000013D6  4E75                     442              RTS
000013D8                           443  
000013D8  4EB9 000014EC            444  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000013DE  4E75                     445              RTS                           
000013E0  4EB8 1382                446  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013E4  B43C 0001                447              CMP.B       #$1,D2      *is the DEST MODE 1?
000013E8  6700 000A                448              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000013EC  4EB9 000013FC            449              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000013F2  4E75                     450              RTS
000013F4                           451  
000013F4  4EB9 000014EE            452  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000013FA  4E75                     453              RTS
000013FC                           454  
000013FC  4EB9 000014F0            455  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
00001402  4E75                     456              RTS
00001404  4EB8 1352                457  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
00001408  B43C 0007                458              CMP.B       #7,D2       *Is the next hex digit 7?
0000140C  6700 001C                459              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001410  4EB8 1372                460              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
00001414  B43C 0001                461              CMP.B       #1,D2       *Is the last bit 1?
00001418  6700 0018                462              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
0000141C  B43C 0000                463              CMP.B       #0,D2       *Is the last bit 0?
00001420  6700 0018                464              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
00001424  4EB8 10E0                465              JSR         INVALID     *If none of the above, OPCODE is invalid
00001428  4E75                     466              RTS
0000142A                           467                                           
0000142A                           468              
0000142A  4EB9 0000145E            469  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001430  4E75                     470              RTS
00001432                           471              
00001432  4EB9 000014E6            472  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
00001438  4E75                     473              RTS
0000143A                           474              
0000143A  4EB9 000014E8            475  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001440  4E75                     476              RTS
00001442                           477              
00001442                           478  
00001442  4EB8 10E0                479  JMP_6X      JSR         INVALID     *Temp, remove once implemented
00001446                           480  
00001446  4EB8 10E0                481  JMP_8X      JSR         INVALID     *Temp, remove once implemented
0000144A                           482  
0000144A  4EB8 10E0                483  JMP_CX      JSR         INVALID     *Temp, remove once implemented
0000144E                           484  
0000144E  4EB8 10E0                485  JMP_DX      JSR         INVALID     *Temp, remove once implemented
00001452                           486  
00001452  4EB8 10E0                487  JMP_EX      JSR         INVALID     *Temp, remove once implemented
00001456                           488  
00001456                           489     
00001456  4EB8 10E0                490  OPC_04XX    JSR         INVALID     *Temp, remove once implemented
0000145A                           491  
0000145A  4EB8 10E0                492  OPC_05XX    JSR         INVALID     *Temp, remove once implemented
0000145E                           493  
0000145E                           494  JMP_47X      
0000145E                           495  
0000145E                           496  
0000145E                           497  
0000145E  18FC 004D                498  OPC_1XXX    MOVE.B      #'M',(A4)+
00001462  18FC 004F                499              MOVE.B      #'O',(A4)+
00001466  18FC 0056                500              MOVE.B      #'V',(A4)+
0000146A  18FC 0045                501              MOVE.B      #'E',(A4)+
0000146E  18FC 002E                502              MOVE.B      #'.',(A4)+
00001472  18FC 0042                503              MOVE.B      #'B',(A4)+
00001476  18FC 0020                504              MOVE.B      #' ',(A4)+
0000147A  18FC 0020                505              MOVE.B      #' ',(A4)+
0000147E                           506              *YOU DO NOT NEED TO MANUALLY SET SIZE CODE IF YOU USE A
0000147E                           507              *GET SIZE SUBROUTINE CALL.
0000147E  4284                     508              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001480  4EB9 0000166A            509              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001486  4E75                     510              RTS
00001488                           511  
00001488  18FC 0041                512  OPC_5XXX    MOVE.B      #'A',(A4)+
0000148C  18FC 0044                513              MOVE.B      #'D',(A4)+
00001490  18FC 0044                514              MOVE.B      #'D',(A4)+
00001494  18FC 0051                515              MOVE.B      #'Q',(A4)+
00001498  18FC 002E                516              MOVE.B      #'.',(A4)+
0000149C                           517              *NEED to Determine sizes here
0000149C  4EB9 00001544            518              JSR         GET_SIZE_2   *Get size code (placed in D4)
000014A2  4EB9 000014F2            519              JSR         ADD_SIZE     *Add size character to string (B/W/L)
000014A8                           520              
000014A8                           521              
000014A8                           522              *JUMP to EACODE table
000014A8  4E75                     523              RTS
000014AA                           524  
000014AA  18FC 004D                525  OPC_7XXX    MOVE.B      #'M',(A4)+
000014AE  18FC 004F                526              MOVE.B      #'O',(A4)+
000014B2  18FC 0056                527              MOVE.B      #'V',(A4)+
000014B6  18FC 0045                528              MOVE.B      #'E',(A4)+
000014BA  18FC 0051                529              MOVE.B      #'Q',(A4)+
000014BE  18FC 002E                530              MOVE.B      #'.',(A4)+
000014C2  18FC 004C                531              MOVE.B      #'L',(A4)+
000014C6                           532              
000014C6                           533              *Needs special EA decode logic
000014C6                           534              *jump to EACODE table
000014C6  4E75                     535              RTS
000014C8                           536  
000014C8  18FC 0053                537  OPC_9XXX    MOVE.B      #'S',(A4)+
000014CC  18FC 0055                538              MOVE.B      #'U',(A4)+
000014D0  18FC 0042                539              MOVE.B      #'B',(A4)+
000014D4  18FC 002E                540              MOVE.B      #'.',(A4)+
000014D8                           541              *NEED to Determine sizes here (opmode 3 bits)
000014D8  4EB9 00001534            542              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000014DE  4EB9 0000156A            543              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
000014E4                           544              *jump to EACODE table
000014E4  4E75                     545              RTS
000014E6                           546  
000014E6  4E75                     547  OPC_LEA     RTS
000014E8                           548  
000014E8                           549  
000014E8  4E75                     550  OPC_MOVEM   RTS
000014EA                           551  
000014EA  4E75                     552  OPC_MOVEAL  RTS
000014EC                           553  
000014EC  4E75                     554  OPC_MOVEL   RTS
000014EE                           555  
000014EE  4E75                     556  OPC_MOVEAW RTS
000014F0                           557  
000014F0  4E75                     558  OPC_MOVEW  RTS
000014F2                           559  
000014F2                           560  
000014F2  B83C 0000                561  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn
000014F6  6700 0012                562              BEQ         B_SIZE
000014FA  B83C 0001                563              CMP.B       #1,D4       *Is it a W, <ea>,dn
000014FE  6700 0018                564              BEQ         W_SIZE
00001502  B83C 0002                565              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001506  6700 001E                566              BEQ         L_SIZE 
0000150A                           567              
0000150A  18FC 0042                568  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
0000150E  18FC 0020                569              MOVE.B      #' ',(A4)+
00001512  18FC 0020                570              MOVE.B      #' ',(A4)+
00001516  4E75                     571              RTS
00001518                           572  
00001518  18FC 0057                573  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
0000151C  18FC 0020                574              MOVE.B      #' ',(A4)+
00001520  18FC 0020                575              MOVE.B      #' ',(A4)+
00001524  4E75                     576              RTS
00001526                           577  
00001526  18FC 004C                578  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
0000152A  18FC 0020                579              MOVE.B      #' ',(A4)+
0000152E  18FC 0020                580              MOVE.B      #' ',(A4)+
00001532  4E75                     581              RTS
00001534                           582  
00001534  4284                     583  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001536  3807                     584              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001538  EF4C                     585              LSL.W       #7,D4       *Clear more significant bits
0000153A  4283                     586              CLR.L       D3          *Make sure D3 is clear for shifting
0000153C  163C 000D                587              MOVE.B      #13,D3      *Shifting 13 times
00001540  E66C                     588              LSR.W       D3,D4       *Move size bits to LSB position
00001542  4E75                     589              RTS
00001544                           590  
00001544  4284                     591  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001546  3807                     592              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001548  E14C                     593              LSL.W       #8,D4       *Clear more significant bits
0000154A  4283                     594              CLR.L       D3          *Make sure D3 is clear for shifting
0000154C  163C 000E                595              MOVE.B      #14,D3      *Shifting 14 times
00001550  E66C                     596              LSR.W       D3,D4       *Move size bits to LSB position
00001552  4E75                     597              RTS
00001554                           598  
00001554  4284                     599  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001556  3807                     600              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001558  4283                     601              CLR.L       D3          *Make sure D3 is clear for shifting
0000155A  163C 0009                602              MOVE.B      #9,D3       *Shift 9 times to the left
0000155E  E76C                     603              LSL.W       D3,D4       *Clear more significant bits
00001560  4283                     604              CLR.L       D3          *Make sure D3 is clear for shifting
00001562  163C 000F                605              MOVE.B      #15,D3      *Shifting 15 times
00001566  E66C                     606              LSR.W       D3,D4       *Move size bits to LSB position
00001568  4E75                     607              RTS
0000156A                           608  
0000156A  B83C 0000                609  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
0000156E  6700 002E                610              BEQ         B_EA
00001572  B83C 0001                611              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001576  6700 003A                612              BEQ         W_EA
0000157A  B83C 0002                613              CMP.B       #2,D4       *Is it a L, <ea>,dn
0000157E  6700 0046                614              BEQ         L_EA
00001582                           615  
00001582  B83C 0004                616              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001586  6700 0052                617              BEQ         B_DN
0000158A  B83C 0005                618              CMP.B       #5,D4       *Is it a W, dn,<ea>
0000158E  6700 005E                619              BEQ         W_DN
00001592  B83C 0006                620              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001596  6700 006A                621              BEQ         L_DN        
0000159A  6000 FB44                622              BRA         INVALID     *Got here, must be invalid data.
0000159E                           623              
0000159E  18FC 0042                624  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
000015A2  18FC 0020                625              MOVE.B      #' ',(A4)+
000015A6  18FC 0020                626              MOVE.B      #' ',(A4)+
000015AA  4EB9 00001616            627              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
000015B0  4E75                     628              RTS
000015B2                           629  
000015B2  18FC 0057                630  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
000015B6  18FC 0020                631              MOVE.B      #' ',(A4)+
000015BA  18FC 0020                632              MOVE.B      #' ',(A4)+
000015BE  4EB9 00001616            633              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
000015C4  4E75                     634              RTS
000015C6                           635  
000015C6  18FC 004C                636  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
000015CA  18FC 0020                637              MOVE.B      #' ',(A4)+
000015CE  18FC 0020                638              MOVE.B      #' ',(A4)+
000015D2  4EB9 00001616            639              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
000015D8  4E75                     640              RTS
000015DA                           641  
000015DA  18FC 0042                642  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
000015DE  18FC 0020                643              MOVE.B      #' ',(A4)+
000015E2  18FC 0020                644              MOVE.B      #' ',(A4)+
000015E6  4EB9 0000162C            645              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015EC  4E75                     646              RTS
000015EE                           647  
000015EE  18FC 0057                648  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
000015F2  18FC 0020                649              MOVE.B      #' ',(A4)+
000015F6  18FC 0020                650              MOVE.B      #' ',(A4)+
000015FA  4EB9 0000162C            651              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001600  4E75                     652              RTS
00001602                           653  
00001602  18FC 004C                654  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001606  18FC 0020                655              MOVE.B      #' ',(A4)+
0000160A  18FC 0020                656              MOVE.B      #' ',(A4)+
0000160E  4EB9 0000162C            657              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001614  4E75                     658              RTS            
00001616                           659              
00001616                           660              
00001616                           661              
00001616                           662              
00001616                           663              
00001616                           664              
00001616                           665              
00001616                           666  
00001616                           667  
00001616                           668  
00001616                           669  -------------------- end include --------------------
00001616                           670              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001616                           671  
00001616                           672  
00001616  4EB9 00001648            673  EA_SRC      JSR         GEN_EA_CODE *Deal with EA code First
0000161C  18FC 002C                674              MOVE.B      #',',(A4)+
00001620  18FC 0044                675              MOVE.B      #'D',(A4)+
00001624  4EB9 000016B0            676              JSR         REG_CODE    *Decode Dn and add number to string
0000162A  4E75                     677              RTS
0000162C                           678  
0000162C  18FC 0044                679  DN_SRC      MOVE.B      #'D',(A4)+
00001630  4EB9 000016B0            680              JSR         REG_CODE     *Decode Dn and add number to string
00001636  18FC 002C                681              MOVE.B      #',',(A4)+
0000163A  4EB9 00001648            682              JSR         GEN_EA_CODE *Deal with EA code Second
00001640  4E75                     683              RTS
00001642                           684  
00001642                           685  MM_OP_ORD 
00001642  4E75                     686              RTS
00001644                           687  
00001644                           688  MM_EA_SRC   *Deal with EA code first
00001644                           689              *Deal with list second
00001644  4E75                     690              RTS
00001646                           691  
00001646                           692  MM_LS_SRC   *Deal with list first
00001646                           693              *Deal with EA code second
00001646  4E75                     694              RTS
00001648                           695  
00001648                           696  
00001648                           697  
00001648  4283                     698  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
0000164A  4286                     699              CLR.L       D6          *Make sure D6 is clear
0000164C  4281                     700              CLR.L       D1          *Make sure D1 is clear for shifting
0000164E                           701              
0000164E  3607                     702              MOVE.W      D7,D3       *Move untouched opcode into D3
00001650  3C07                     703              MOVE.W      D7,D6       *Move untouched opcode into D6
00001652                           704              
00001652  123C 000A                705              MOVE.B      #10,D1      *Shifting to isolate MODE
00001656  E36E                     706              LSL.W       D1,D6       
00001658  123C 000D                707              MOVE.B      #13,D1
0000165C  E26E                     708              LSR.W       D1,D6       *Move MODE bits to LSB position
0000165E                           709              
0000165E  E36B                     710              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001660  E26B                     711              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001662                           712              
00001662  4EB9 000016C6            713              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001668  4E75                     714              RTS
0000166A                           715              
0000166A  4283                     716  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
0000166C  4286                     717              CLR.L       D6          *Make sure D6 is clear
0000166E  4281                     718              CLR.L       D1          *Make sure D1 is clear for shifting
00001670                           719              
00001670  3607                     720              MOVE.W      D7,D3       *Move untouched opcode into D3
00001672  3C07                     721              MOVE.W      D7,D6       *Move untouched opcode into D6
00001674                           722              
00001674  123C 000A                723              MOVE.B      #10,D1      *Shifting to isolate MODE
00001678  E36E                     724              LSL.W       D1,D6       
0000167A  123C 000D                725              MOVE.B      #13,D1
0000167E  E26E                     726              LSR.W       D1,D6       *Move MODE bits to LSB position
00001680                           727              
00001680  E36B                     728              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001682  E26B                     729              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001684                           730              
00001684  4EB9 000016C6            731              JSR         EA_TBL      *Decode MODE to select correct <EA>
0000168A                           732              
0000168A  18FC 002C                733              MOVE.B      #',',(A4)+  *SEPERATOR
0000168E                           734              
0000168E  4283                     735              CLR.L       D3          *Make sure D3 is clear
00001690  4286                     736              CLR.L       D6          *Make sure D6 is clear
00001692  4281                     737              CLR.L       D1          *Make sure D1 is clear for shifting
00001694                           738              
00001694  3607                     739              MOVE.W      D7,D3       *Move untouched opcode into D3
00001696  3C07                     740              MOVE.W      D7,D6       *Move untouched opcode into D6
00001698                           741              
00001698  123C 0007                742              MOVE.B      #7,D1      *Shifting to isolate MODE
0000169C  E36E                     743              LSL.W       D1,D6       
0000169E  123C 000D                744              MOVE.B      #13,D1
000016A2  E26E                     745              LSR.W       D1,D6       *Move MODE bits to LSB position
000016A4                           746              
000016A4  E94B                     747              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
000016A6  E26B                     748              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
000016A8                           749              
000016A8  4EB9 000016C6            750              JSR         EA_TBL      *Decode MODE to select correct <EA>
000016AE                           751              
000016AE  4E75                     752              RTS
000016B0                           753              
000016B0                           754              
000016B0  4283                     755  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
000016B2  3607                     756              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
000016B4  E94B                     757              LSL.W       #4,D3       *Isolate bits and move to LSB position
000016B6  4282                     758              CLR.L       D2
000016B8  143C 000D                759              MOVE.B      #13,D2
000016BC  E46B                     760              LSR.W       D2,D3
000016BE  4EB9 0000175E            761              JSR         REG_TBL     *Jump to register table.
000016C4  4E75                     762              RTS
000016C6                           763  
000016C6                           764  
000016C6  BC3C 0000                765  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
000016CA  6700 002E                766              BEQ         DRD
000016CE  BC3C 0001                767              CMP.B       #1,D6
000016D2  6700 0032                768              BEQ         ARD
000016D6  BC3C 0002                769              CMP.B       #2,D6
000016DA  6700 0036                770              BEQ         ARI
000016DE  BC3C 0003                771              CMP.B       #3,D6
000016E2  6700 0042                772              BEQ         ARI_INC
000016E6  BC3C 0004                773              CMP.B       #4,D6
000016EA  6700 0052                774              BEQ         ARI_DEC
000016EE  BC3C 0007                775              CMP.B       #7,D6
000016F2  6700 0062                776              BEQ         ABS_ADDR
000016F6  4EF8 10E0                777              JMP         INVALID     *Got here? Must be bad data.
000016FA                           778  
000016FA  18FC 0044                779  DRD         MOVE.B      #'D',(A4)+
000016FE  4EB9 0000175E            780              JSR         REG_TBL     *Reg num should be in D3
00001704  4E75                     781              RTS
00001706                           782  
00001706  18FC 0041                783  ARD         MOVE.B      #'A',(A4)+
0000170A  4EB9 0000175E            784              JSR         REG_TBL     *Reg num should be in D3
00001710  4E75                     785              RTS
00001712                           786  
00001712  18FC 0028                787  ARI         MOVE.B      #'(',(A4)+
00001716  18FC 0041                788              MOVE.B      #'A',(A4)+
0000171A  4EB9 0000175E            789              JSR         REG_TBL     *Reg num should be in D3
00001720  18FC 0029                790              MOVE.B      #')',(A4)+
00001724  4E75                     791              RTS
00001726                           792  
00001726  18FC 0028                793  ARI_INC     MOVE.B      #'(',(A4)+
0000172A  18FC 0041                794              MOVE.B      #'A',(A4)+
0000172E  4EB9 0000175E            795              JSR         REG_TBL     *Reg num should be in D3
00001734  18FC 0029                796              MOVE.B      #')',(A4)+
00001738  18FC 002B                797              MOVE.B      #'+',(A4)+
0000173C  4E75                     798              RTS
0000173E                           799  
0000173E  18FC 002D                800  ARI_DEC     MOVE.B      #'-',(A4)+
00001742  18FC 0028                801              MOVE.B      #'(',(A4)+
00001746  18FC 0041                802              MOVE.B      #'A',(A4)+
0000174A  4EB9 0000175E            803              JSR         REG_TBL     *Reg num should be in D3
00001750  18FC 0029                804              MOVE.B      #')',(A4)+
00001754  4E75                     805              RTS
00001756                           806  
00001756  4EB9 000017D2            807  ABS_ADDR    JSR         ABS_TBL
0000175C  4E75                     808              RTS
0000175E                           809              
0000175E  B63C 0000                810  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001762  6700 003E                811              BEQ         NUM_0
00001766  B63C 0001                812              CMP.B       #1,D3
0000176A  6700 003C                813              BEQ         NUM_1
0000176E  B63C 0002                814              CMP.B       #2,D3
00001772  6700 003A                815              BEQ         NUM_2
00001776  B63C 0003                816              CMP.B       #3,D3
0000177A  6700 0038                817              BEQ         NUM_3
0000177E  B63C 0004                818              CMP.B       #4,D3
00001782  6700 0036                819              BEQ         NUM_4
00001786  B63C 0005                820              CMP.B       #5,D3
0000178A  6700 0034                821              BEQ         NUM_5
0000178E  B63C 0006                822              CMP.B       #6,D3
00001792  6700 0032                823              BEQ         NUM_6
00001796  B63C 0007                824              CMP.B       #7,D3
0000179A  6700 0030                825              BEQ         NUM_7
0000179E  4EF8 10E0                826              JMP         INVALID     *Got here? Must be bad data.
000017A2                           827              
000017A2  18FC 0030                828  NUM_0       MOVE.B      #'0',(A4)+
000017A6  4E75                     829              RTS              
000017A8  18FC 0031                830  NUM_1       MOVE.B      #'1',(A4)+
000017AC  4E75                     831              RTS
000017AE  18FC 0032                832  NUM_2       MOVE.B      #'2',(A4)+
000017B2  4E75                     833              RTS
000017B4  18FC 0033                834  NUM_3       MOVE.B      #'3',(A4)+
000017B8  4E75                     835              RTS
000017BA  18FC 0034                836  NUM_4       MOVE.B      #'4',(A4)+
000017BE  4E75                     837              RTS
000017C0  18FC 0035                838  NUM_5       MOVE.B      #'5',(A4)+
000017C4  4E75                     839              RTS
000017C6  18FC 0036                840  NUM_6       MOVE.B      #'6',(A4)+
000017CA  4E75                     841              RTS
000017CC  18FC 0037                842  NUM_7       MOVE.B      #'7',(A4)+
000017D0  4E75                     843              RTS
000017D2                           844  
000017D2  B63C 0000                845  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
000017D6  6700 0016                846              BEQ         ABW
000017DA  B63C 0001                847              CMP.B       #1,D3
000017DE  6700 001E                848              BEQ         ABL
000017E2  B63C 0004                849              CMP.B       #4,D3
000017E6  6700 0026                850              BEQ         IDATA
000017EA  4EF8 10E0                851              JMP         INVALID     *Got here? Must be bad data.
000017EE                           852              
000017EE  18FC 0024                853  ABW         MOVE.B      #'$',(A4)+
000017F2  4281                     854              CLR.L       D1          *Make sure D1 is clear
000017F4  321D                     855              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
000017F6  4EB9 000018B8            856              JSR         W_H2A       *convert absolute value to ascii and add to good string
000017FC  4E75                     857              RTS
000017FE                           858  
000017FE  18FC 0024                859  ABL         MOVE.B      #'$',(A4)+
00001802  4281                     860              CLR.L       D1          *Make sure D1 is clear
00001804  221D                     861              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
00001806  4EB9 000018FA            862              JSR         L_H2A
0000180C  4E75                     863              RTS
0000180E                           864              
0000180E  18FC 0023                865  IDATA       MOVE.B      #'#',(A4)+
00001812  18FC 0024                866              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
00001816  4EB9 0000181E            867              JSR         IMD_TBL
0000181C  4E75                     868              RTS
0000181E                           869              
0000181E  B83C 0000                870  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
00001822  6700 002E                871              BEQ         B_IMD       
00001826  B83C 0004                872              CMP.B       #4,D4
0000182A  6700 0026                873              BEQ         B_IMD
0000182E                           874  
0000182E  B83C 0001                875              CMP.B       #1,D4       *Is it a word size code?
00001832  6700 002A                876              BEQ         W_IMD
00001836  B83C 0005                877              CMP.B       #5,D4
0000183A  6700 0022                878              BEQ         W_IMD
0000183E                           879              
0000183E  B83C 0002                880              CMP.B       #2,D4       *Is it a long word size code?
00001842  6700 0026                881              BEQ         L_IMD
00001846  B83C 0006                882              CMP.B       #6,D4
0000184A  6700 001E                883              BEQ         L_IMD
0000184E                           884              
0000184E  6000 F890                885              BRA         INVALID     *Got here? Must be bad data.
00001852                           886              
00001852  4281                     887  B_IMD       CLR.L       D1
00001854  321D                     888              MOVE.W      (A5)+,D1    *Make sure D1 is clear
00001856  4EB9 00001876            889              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
0000185C  4E75                     890              RTS
0000185E                           891  
0000185E  4281                     892  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001860  321D                     893              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001862  4EB9 000018B8            894              JSR         W_H2A
00001868  4E75                     895              RTS
0000186A                           896  
0000186A  4281                     897  L_IMD       CLR.L       D1          *Make sure D1 is clear
0000186C  221D                     898              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
0000186E  4EB9 000018FA            899              JSR         L_H2A
00001874  4E75                     900              RTS
00001876                           901                                 
00001876                           902  
00001876                           903  
00001876                           904  
00001876  4280                     905  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001878  4282                     906              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000187A  4283                     907              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000187C  103C 0002                908              MOVE.B      #$2,D0      *Counter
00001880  6000 0002                909              BRA         B_ISO_DIG   *Begin isolating chars
00001884                           910              
00001884  E919                     911  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
00001886                           912              
00001886  1401                     913              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001888                           914              
00001888  163C 0004                915              MOVE.B      #4,D3      *Shift left 28 times
0000188C  E72A                     916              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
0000188E  E91A                     917              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00001890                           918              
00001890  0C02 0009                919              CMPI.B      #$9,D2      *Is it a number?
00001894  6F00 0006                920              BLE         B_NUM       *If it is, process number
00001898  6000 000A                921              BRA         B_LET       *If not, process letter
0000189C                           922              
0000189C  0602 0030                923  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000018A0  6000 000A                924              BRA         B_ADD_CHAR  *add to strings and continue
000018A4                           925              
000018A4  0602 0037                926  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000018A8  6000 0002                927              BRA         B_ADD_CHAR  *add to strings and continue
000018AC                           928  
000018AC  18C2                     929  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018AE  5300                     930              SUBI.B      #$1,D0      *decrement counter
000018B0  0C00 0000                931              CMPI.B      #$0,D0      *Check if we're done            
000018B4  6ECE                     932              BGT         B_ISO_DIG   *If not, continue tranlation   
000018B6                           933              
000018B6  4E75                     934              RTS
000018B8                           935  
000018B8  4280                     936  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000018BA  4282                     937              CLR.L       D2          *Make sure D2 is empty (each individual char)
000018BC  4283                     938              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000018BE  103C 0004                939              MOVE.B      #$4,D0      *Counter
000018C2  6000 0002                940              BRA         W_ISO_DIG   *Begin isolating chars
000018C6                           941              
000018C6  E959                     942  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
000018C8                           943              
000018C8  1401                     944              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
000018CA                           945              
000018CA  163C 000C                946              MOVE.B      #12,D3      *Shift left 28 times
000018CE  E76A                     947              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
000018D0  E95A                     948              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
000018D2                           949              
000018D2  0C02 0009                950              CMPI.B      #$9,D2      *Is it a number?
000018D6  6F00 0006                951              BLE         W_NUM       *If it is, process number
000018DA  6000 000A                952              BRA         W_LET       *If not, process letter
000018DE                           953              
000018DE  0602 0030                954  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000018E2  6000 000A                955              BRA         W_ADD_CHAR  *add to strings and continue
000018E6                           956              
000018E6  0602 0037                957  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000018EA  6000 0002                958              BRA         W_ADD_CHAR  *add to strings and continue
000018EE                           959  
000018EE  18C2                     960  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018F0  5300                     961              SUBI.B      #$1,D0      *decrement counter
000018F2  0C00 0000                962              CMPI.B      #$0,D0      *Check if we're done            
000018F6  6ECE                     963              BGT         W_ISO_DIG   *If not, continue tranlation   
000018F8                           964              
000018F8  4E75                     965              RTS
000018FA  4280                     966  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000018FC  4282                     967              CLR.L       D2          *Make sure D2 is empty (each individual char)
000018FE  4283                     968              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001900  103C 0008                969              MOVE.B      #$8,D0      *Counter
00001904  6000 0002                970              BRA         L_ISO_DIG   *Begin isolating chars
00001908                           971              
00001908  E999                     972  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
0000190A                           973              
0000190A  1401                     974              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000190C                           975              
0000190C  163C 001C                976              MOVE.B      #28,D3      *Shift left 28 times
00001910  E7AA                     977              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001912  E99A                     978              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001914                           979              
00001914  0C02 0009                980              CMPI.B      #$9,D2      *Is it a number?
00001918  6F00 0006                981              BLE         L_NUM       *If it is, process number
0000191C  6000 000A                982              BRA         L_LET       *If not, process letter
00001920                           983              
00001920  0602 0030                984  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001924  6000 000A                985              BRA         L_ADD_CHAR  *add to strings and continue
00001928                           986              
00001928  0602 0037                987  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000192C  6000 0002                988              BRA         L_ADD_CHAR  *add to strings and continue
00001930                           989  
00001930  18C2                     990  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001932  5300                     991              SUBI.B      #$1,D0      *decrement counter
00001934  0C00 0000                992              CMPI.B      #$0,D0      *Check if we're done            
00001938  6ECE                     993              BGT         L_ISO_DIG   *If not, continue tranlation   
0000193A                           994              
0000193A  4E75                     995              RTS
0000193C                           996  
0000193C                           997  
0000193C                           998  
0000193C                           999  
0000193C                          1000  
0000193C                          1001  -------------------- end include --------------------
0000193C                          1002  
0000193C  =0000000D               1003  CR          EQU         $0D
0000193C  =0000000A               1004  LF          EQU         $0A
0000193C                          1005  
0000193C= 2D 2D 2D 2D 2D 2D ...   1006  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
00001966= 48 65 6E 72 79 20 ...   1007              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
0000198F= 43 53 53 20 34 32 ...   1008              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
000019B8= 2D 2D 2D 2D 2D 2D ...   1009              DC.B        '----------------------------------------',CR,LF,0
000019E3                          1010              
000019E3= 45 6E 74 65 72 20 ...   1011  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
00001A06= 45 6E 74 65 72 20 ...   1012  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
00001A27= 50 72 65 73 73 20 ...   1013  NXT_PG      DC.B        'Press enter key to contiune reading',CR,LF,0
00001A4D                          1014  
00001A4D                          1015  STA_ADDR    DS.B        40
00001A75                          1016  END_ADDR    DS.B        40
00001A9D                          1017  
00001A9D                          1018  
00001A9D                          1019  
00001A9D                          1020  
00001A9E= 00000001                1021  BAD_STR     DC.L        1
00001AA2                          1022  
00001AA2= 00000050                1023  SPACER11    DC.L        80
00001AA6= 00000050                1024  SPACER22    DC.L        80
00001AAA= 00000050                1025  SPACER33    DC.L        80
00001AAE= 00000050                1026  SPACER44    DC.L        80
00001AB2= 00000050                1027  SPACER55    DC.L        80
00001AB6= 00000050                1028  SPACER66    DC.L        80
00001ABA= 00000050                1029  SPACER77    DC.L        80
00001ABE= 00000050                1030  SPACER88    DC.L        80
00001AC2= 00000050                1031  SPACER99    DC.L        80
00001AC6= 00000050                1032  SPACERAA    DC.L        80
00001ACA= 00000050                1033  SPACERBB    DC.L        80
00001ACE= 00000050                1034  SPACERCC    DC.L        80
00001AD2= 00000050                1035  SPACERDD    DC.L        80
00001AD6= 00000050                1036  SPACEREE    DC.L        80
00001ADA= 00000050                1037  SPACERFF    DC.L        80
00001ADE                          1038  
00001ADE= 00000001                1039  GOOD_STR    DC.L        1
00001AE2                          1040  
00001AE2= 00000050                1041  SPACER1     DC.L        80
00001AE6= 00000050                1042  SPACER2     DC.L        80
00001AEA= 00000050                1043  SPACER3     DC.L        80
00001AEE= 00000050                1044  SPACER4     DC.L        80
00001AF2= 00000050                1045  SPACER5     DC.L        80
00001AF6= 00000050                1046  SPACER6     DC.L        80
00001AFA= 00000050                1047  SPACER7     DC.L        80
00001AFE= 00000050                1048  SPACER8     DC.L        80
00001B02= 00000050                1049  SPACER9     DC.L        80
00001B06= 00000050                1050  SPACERA     DC.L        80
00001B0A= 00000050                1051  SPACERB     DC.L        80
00001B0E= 00000050                1052  SPACERC     DC.L        80
00001B12= 00000050                1053  SPACERD     DC.L        80
00001B16= 00000050                1054  SPACERE     DC.L        80
00001B1A= 00000050                1055  SPACERF     DC.L        80
00001B1E                          1056  
00001B1E                          1057              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 17FE
ABS_ADDR            1756
ABS_TBL             17D2
ABW                 17EE
ADD_CHAR_B          11CE
ADD_CHAR_G          1216
ADD_SIZE            14F2
AH_DONE             1092
ARD                 1706
ARI                 1712
ARI_DEC             173E
ARI_INC             1726
ASCII_HEX           107A
BAD_STR             1A9E
B_ADD_CHAR          18AC
B_DN                15DA
B_EA                159E
B_H2A               1876
B_IMD               1852
B_ISO_DIG           1884
B_LET               18A4
B_NUM               189C
B_SIZE              150A
CLEAN_GS            117C
CONTINUE            10EA
CR                  D
DECODE_LOOP         10B6
DN_SRC              162C
DONE                1254
DRD                 16FA
D_CLEAN             1192
EA_SRC              1616
EA_TBL              16C6
END_ADDR            1A75
END_MSG             1A06
END_OPT             124E
FORMAT              10A8
GEN_EA_CODE         1648
GET_INPUT           1020
GET_SIZE_1          1554
GET_SIZE_2          1544
GET_SIZE_3          1534
GOOD_STR            1ADE
GS_LOOP             1182
HEX_ASCII_B         1194
HEX_ASCII_G         11DA
IDATA               180E
IMD_TBL             181E
INIT_BAD            1144
INIT_GOOD           1130
INIT_STRS           1122
INTRO               1012
INVALID             10E0
ISO_DIG_B           11A6
ISO_DIG_G           11EE
JMP_0               1266
JMP_0X              1392
JMP_1               1276
JMP_2               1286
JMP_2X              13BC
JMP_3               1296
JMP_3X              13E0
JMP_4               12A6
JMP_47X             145E
JMP_4X              1404
JMP_5               12B6
JMP_6               12C6
JMP_6X              1442
JMP_7               12D6
JMP_8               12E6
JMP_8X              1446
JMP_9               12F6
JMP_A               1306
JMP_B               1314
JMP_C               1322
JMP_CX              144A
JMP_D               1332
JMP_DX              144E
JMP_E               1342
JMP_EX              1452
JMP_TBL             125A
J_47X               142A
J_ADDI              13B4
J_CLR1              1372
J_CLR3              1362
J_CLR4              1352
J_CLR_DM            1382
J_LEA               1432
J_MOVEAL            13D0
J_MOVEAW            13F4
J_MOVEL             13D8
J_MOVEM             143A
J_MOVEW             13FC
J_SUBI              13AC
LET                 109E
LET_B               11C6
LET_G               120E
LF                  A
L_ADD_CHAR          1930
L_DN                1602
L_EA                15C6
L_H2A               18FA
L_IMD               186A
L_ISO_DIG           1908
L_LET               1928
L_NUM               1920
L_SIZE              1526
MM_EA_SRC           1644
MM_LS_SRC           1646
MM_OP_ORD           1642
MOV_EA_CODE         166A
NEXT_PAGE           10FC
NL_INTRO            193C
NUM                 1094
NUM_0               17A2
NUM_1               17A8
NUM_2               17AE
NUM_3               17B4
NUM_4               17BA
NUM_5               17C0
NUM_6               17C6
NUM_7               17CC
NUM_B               11BE
NUM_G               1206
NXT_PG              1A27
OPC_04XX            1456
OPC_05XX            145A
OPC_1XXX            145E
OPC_5XXX            1488
OPC_7XXX            14AA
OPC_9XXX            14C8
OPC_LEA             14E6
OPC_MOVEAL          14EA
OPC_MOVEAW          14EE
OPC_MOVEL           14EC
OPC_MOVEM           14E8
OPC_MOVEW           14F0
OR_ADD_SIZE         156A
PRINT_B             1238
PRINT_G             1222
PRINT_GOOD          10D6
PROC_END            106E
PROC_STA            1062
REG_CODE            16B0
REG_TBL             175E
SPACER1             1AE2
SPACER11            1AA2
SPACER2             1AE6
SPACER22            1AA6
SPACER3             1AEA
SPACER33            1AAA
SPACER4             1AEE
SPACER44            1AAE
SPACER5             1AF2
SPACER55            1AB2
SPACER6             1AF6
SPACER66            1AB6
SPACER7             1AFA
SPACER77            1ABA
SPACER8             1AFE
SPACER88            1ABE
SPACER9             1B02
SPACER99            1AC2
SPACERA             1B06
SPACERAA            1AC6
SPACERB             1B0A
SPACERBB            1ACA
SPACERC             1B0E
SPACERCC            1ACE
SPACERD             1B12
SPACERDD            1AD2
SPACERE             1B16
SPACEREE            1AD6
SPACERF             1B1A
SPACERFF            1ADA
START               1000
STA_ADDR            1A4D
STA_MSG             19E3
W_ADD_CHAR          18EE
W_DN                15EE
W_EA                15B2
W_H2A               18B8
W_IMD               185E
W_ISO_DIG           18C6
W_LET               18E6
W_NUM               18DE
W_SIZE              1518
