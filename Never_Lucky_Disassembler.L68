00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/23/2017 4:38:12 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010B6             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 000018EE             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 00001995             28  GET_INPUT   LEA         STA_MSG,A1  *Load STA_MSG into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display start address msg
0000102A  4E4F                      30              TRAP        #15         
0000102C                            31              
0000102C  43F9 000019FF             32              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
00001032  103C 0002                 33              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  4EB9 00001062             36              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000103E  4281                      37              CLR.L       D1          *Clear input length from D1
00001040                            38              
00001040  43F9 000019B8             39              LEA         END_MSG,A1  *Load END_MSG into A1
00001046  103C 000E                 40              MOVE.B      #14,D0      *Trap task 14, display end address msg
0000104A  4E4F                      41              TRAP        #15
0000104C                            42              
0000104C  43F9 00001A27             43              LEA         END_ADDR,A1 *Store input in END_ADDR variable
00001052  103C 0002                 44              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001056  4E4F                      45              TRAP        #15         
00001058                            46              
00001058  4EB9 0000106E             47              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000105E  4281                      48              CLR.L       D1          *Clear input length from D1
00001060                            49              
00001060  4E75                      50              RTS
00001062                            51              
00001062                            52  *--------------------PROC_STA-------------------------------
00001062                            53  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
00001062  4EB9 0000107A             54              JSR         ASCII_HEX   *Convert input into Hex
00001068                            55              
00001068                            56              *assuming all error checking is done before the next instruction (not yet implemented)
00001068                            57              
00001068  2A43                      58              MOVEA.L     D3,A5       *Move hex to STA_ADDR
0000106A  4283                      59              CLR.L       D3          *Clear D3
0000106C  4E75                      60              RTS                     
0000106E                            61  
0000106E                            62  *--------------------PROC_END-------------------------------
0000106E                            63  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000106E                            64              *      does not fall before start
0000106E  4EB9 0000107A             65              JSR         ASCII_HEX   *Convert input into Hex
00001074                            66              
00001074                            67              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            68              
00001074  2C43                      69              MOVE.L      D3,A6       *Move hex to END_ADDR
00001076  4283                      70              CLR.L       D3          *Clear D3
00001078  4E75                      71              RTS
0000107A                            72  
0000107A                            73  *-------------------ASCII_HEX-------------------------------
0000107A  0C01 0000                 74  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000107E  6700 0012                 75              BEQ         AH_DONE     *End subroutine if all converted
00001082  1419                      76              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001084  183C 0039                 77              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001088  B404                      78              CMP.B       D4,D2       *Check if ascii code is for a number or letter
0000108A  6F00 0008                 79              BLE         NUM         *Codes less than $39 imply a number, so branch
0000108E  6000 000E                 80              BRA         LET         *If not a number, must be a letter.            
00001092  4E75                      81  AH_DONE     RTS
00001094                            82  
00001094  183C 0030                 83  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
00001098  9404                      84              SUB.B       D4,D2       *convert to hexadecimal number
0000109A  6000 000C                 85              BRA         FORMAT      *branch to subroutine to store converted hex number
0000109E                            86              
0000109E  183C 0037                 87  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010A2  9404                      88              SUB.B       D4,D2       *convert to hexadecimal letter
000010A4  6000 0002                 89              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010A8                            90  
000010A8  5301                      91  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010AA  D602                      92              ADD.B       D2,D3       *Store converted number in D3
000010AC  0C01 0000                 93              CMPI.B      #$0,D1      *Check if we're all done converting
000010B0  67C8                      94              BEQ         ASCII_HEX   *If not continue conversion
000010B2  E983                      95              ASL.L       #4,D3       *Shift bits to the left to correct position
000010B4  60C4                      96              BRA         ASCII_HEX   *Branch back to label
000010B6                            97              
000010B6                            98  *-------------------DECODE_LOOP-----------------------------
000010B6  3E1D                      99  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010B8  47F9 00001A50            100              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010BE  49F9 00001A90            101              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010C4                           102              
000010C4  4EB9 00001122            103              JSR         INIT_STRS   *Initialize Bad and Good Str
000010CA                           104              
000010CA  4EB9 0000125A            105              JSR         JMP_TBL     *Start opcode identification waterfall
000010D0                           106              
000010D0  4EB9 0000117C            107              JSR         CLEAN_GS    *end of output string.
000010D6                           108              
000010D6  4EB9 00001222            109  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010DC  6000 000C                110              BRA         CONTINUE    *Continue the loop
000010E0  4EB9 00001238            111  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010E6  6000 0002                112              BRA         CONTINUE    *Continue the loop            
000010EA                           113              
000010EA  BCCD                     114  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010EC  6700 0160                115              BEQ         END_OPT     *if we're done, move to end options (ask user what to do)
000010F0                           116              
000010F0                           117                          
000010F0  5205                     118              ADDQ.B      #1,D5       *Increment line counter
000010F2  BA3C 0018                119              CMP.B       #24,D5      *See if page is full
000010F6  6700 0004                120              BEQ         NEXT_PAGE   *Jump to next page prompt
000010FA                           121              
000010FA  60BA                     122              BRA         DECODE_LOOP * Continue loop
000010FC                           123  
000010FC                           124  *-------------------NEXT_PAGE-----------------------------
000010FC  43F9 000019D9            125  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001102  4280                     126              CLR.L       D0          *Make sure D0 is empty
00001104  103C 000E                127              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001108  4E4F                     128              TRAP        #15            
0000110A                           129              
0000110A  103C 000C                130              MOVE.B      #12,D0      *Keyboard echo trap task
0000110E  4281                     131              CLR.L       D1          *Start keyboard echo trap
00001110  4E4F                     132              TRAP        #15         
00001112                           133              
00001112  103C 0005                134              MOVE.B      #5,D0       *Single char trap task
00001116  4E4F                     135              TRAP        #15         
00001118                           136              
00001118  B23C 000D                137              CMP.B       #$D,D1      *Check if ENTER key was pressed
0000111C  66DE                     138              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
0000111E                           139              
0000111E  4285                     140              CLR.L       D5          *Reset page counter
00001120                           141              
00001120  6094                     142              BRA         DECODE_LOOP *Continue the loop         
00001122                           143              
00001122                           144  *-------------------INIT_STRS-----------------------------
00001122  4EB9 00001130            145  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001128  4EB9 00001144            146              JSR         INIT_BAD    *Initialize the bad string
0000112E  4E75                     147              RTS
00001130                           148  *-------------------INIT_GOOD-----------------------------
00001130                           149  INIT_GOOD   
00001130                           150  *            MOVE.B      #'L',(A4)+  *Add to good string  
00001130                           151  *            MOVE.B      #'e',(A4)+ 
00001130                           152  *            MOVE.B      #'g',(A4)+ 
00001130                           153  *            MOVE.B      #'a',(A4)+ 
00001130                           154  *            MOVE.B      #'l',(A4)+
00001130                           155  *            MOVE.B      #' ',(A4)+
00001130                           156  *            MOVE.B      #' ',(A4)+ 
00001130                           157  *            MOVE.B      #':',(A4)+
00001130                           158  *            MOVE.B      #' ',(A4)+ 
00001130                           159  
00001130  18FC 0024                160              MOVE.B      #'$',(A4)+ 
00001134  4EB9 000011DA            161              JSR         HEX_ASCII_G *Now convert opcode to ASCII
0000113A                           162              
0000113A  18FC 0020                163              MOVE.B      #' ',(A4)+  *Add spaces after memory location added
0000113E  18FC 0020                164              MOVE.B      #' ',(A4)+
00001142                           165              
00001142                           166              *Add 'Legal: ', then add opcode (must go from hex to ascii)
00001142                           167              
00001142                           168              
00001142  4E75                     169              RTS
00001144                           170  
00001144                           171  *-------------------INIT_BAD------------------------------            
00001144  16FC 0049                172  INIT_BAD    MOVE.B      #'I',(A3)+  *Add to bad string
00001148  16FC 006C                173              MOVE.B      #'l',(A3)+ 
0000114C  16FC 006C                174              MOVE.B      #'l',(A3)+    
00001150  16FC 0065                175              MOVE.B      #'e',(A3)+ 
00001154  16FC 0067                176              MOVE.B      #'g',(A3)+ 
00001158  16FC 0061                177              MOVE.B      #'a',(A3)+ 
0000115C  16FC 006C                178              MOVE.B      #'l',(A3)+ 
00001160  16FC 003A                179              MOVE.B      #':',(A3)+
00001164  16FC 0020                180              MOVE.B      #' ',(A3)+ 
00001168  16FC 0024                181              MOVE.B      #'$',(A3)+  
0000116C                           182              
0000116C  4EB9 00001194            183              JSR         HEX_ASCII_B *Now convert opcode to ASCII
00001172                           184              
00001172  16FC 0020                185              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001176  16FC 0020                186              MOVE.B      #' ',(A3)+
0000117A                           187              
0000117A                           188              *Add 'Illegal: ', then add opcode (must go from from hex to ascii)
0000117A                           189              
0000117A  4E75                     190              RTS
0000117C                           191  
0000117C                           192  *-------------------GS_CLEAN--------------------------------
0000117C                           193  * This subroutine "cleans" the end of the good string.
0000117C                           194  * Prevents the previous string from showing content in the
0000117C                           195  * current string.
0000117C                           196  *-----------------------------------------------------------
0000117C  4280                     197  CLEAN_GS    CLR.L       D0
0000117E  103C 000F                198              MOVE.B      #15,D0      *Max 15 chars to clean
00001182                           199  
00001182  0C00 0000                200  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001186  6700 000A                201              BEQ         D_CLEAN
0000118A  18FC 0020                202              MOVE.B      #' ',(A4)+
0000118E  5300                     203              SUBI.B      #$1,D0
00001190  60F0                     204              BRA         GS_LOOP
00001192  4E75                     205  D_CLEAN     RTS
00001194                           206              
00001194                           207              
00001194                           208  *-------------------HEX_ASCII_B-----------------------------
00001194  4280                     209  HEX_ASCII_B CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     210              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     211              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     212              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  3207                     213              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000119E  103C 0004                214              MOVE.B      #$4,D0      *Counter
000011A2  6000 0002                215              BRA         ISO_DIG_B   *Begin isolating chars
000011A6                           216              
000011A6  E959                     217  ISO_DIG_B   ROL.W       #4,D1       *Move first significant hex char to least sig position
000011A8                           218              
000011A8  2401                     219              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AA                           220              
000011AA  163C 001C                221              MOVE.B      #28,D3      *Shift left 28 times
000011AE  E7AA                     222              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B0  E99A                     223              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B2                           224              
000011B2  0C02 0009                225              CMPI.B      #$9,D2      *Is it a number?
000011B6  6F00 0006                226              BLE         NUM_B       *If it is, process number
000011BA  6000 000A                227              BRA         LET_B       *If not, process letter
000011BE                           228  
000011BE  0602 0030                229  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
000011C2  6000 000A                230              BRA         ADD_CHAR_B  *add to strings and continue
000011C6                           231              
000011C6  0602 0037                232  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
000011CA  6000 0002                233              BRA         ADD_CHAR_B  *add to strings and continue
000011CE                           234              
000011CE  16C2                     235  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to bad data string
000011D0  5300                     236              SUBI.B      #$1,D0      *decrement counter
000011D2  0C00 0000                237              CMPI.B      #$0,D0      *Check if we're done            
000011D6  6ECE                     238              BGT         ISO_DIG_B   *If not, continue tranlation   
000011D8                           239              
000011D8  4E75                     240              RTS
000011DA                           241              
000011DA                           242  *-------------------HEX_ASCII_G-------------------------------            
000011DA  4280                     243  HEX_ASCII_G CLR.L       D0          *Make sure D0 is empty (Counter)
000011DC  4281                     244              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011DE  4282                     245              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E0  4283                     246              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E2  220D                     247              MOVE.L      A5,D1       *Copy address into D1
000011E4  5501                     248              SUBI.B      #2,D1       *Move addres back one byte (for post increment)
000011E6  103C 0008                249              MOVE.B      #$8,D0      *Counter
000011EA  6000 0002                250              BRA         ISO_DIG_G   *Begin isolating chars
000011EE                           251              
000011EE  E999                     252  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F0                           253              
000011F0  2401                     254              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F2                           255              
000011F2  163C 001C                256              MOVE.B      #28,D3      *Shift left 28 times
000011F6  E7AA                     257              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011F8  E99A                     258              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FA                           259              
000011FA  0C02 0009                260              CMPI.B      #$9,D2      *Is it a number?
000011FE  6F00 0006                261              BLE         NUM_G       *If it is, process number
00001202  6000 000A                262              BRA         LET_G       *If not, process letter
00001206                           263              
00001206  0602 0030                264  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
0000120A  6000 000A                265              BRA         ADD_CHAR_G  *add to strings and continue
0000120E                           266              
0000120E  0602 0037                267  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
00001212  6000 0002                268              BRA         ADD_CHAR_G  *add to strings and continue
00001216                           269  
00001216  18C2                     270  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
00001218  5300                     271              SUBI.B      #$1,D0      *decrement counter
0000121A  0C00 0000                272              CMPI.B      #$0,D0      *Check if we're done            
0000121E  6ECE                     273              BGT         ISO_DIG_G    *If not, continue tranlation   
00001220                           274              
00001220  4E75                     275              RTS
00001222                           276              
00001222                           277  *-------------------PRINT_G---------------------------------
00001222  18FC 0020                278  PRINT_G     MOVE.B      #' ',(A4)+
00001226  16FC 0000                279              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
0000122A  43F9 00001A90            280              LEA         GOOD_STR,A1 *Load good data for printing
00001230  103C 000D                281              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001234  4E4F                     282              TRAP        #15         *Display string
00001236                           283            
00001236  4E75                     284              RTS 
00001238                           285  
00001238                           286  *-------------------PRINT_B---------------------------------
00001238  18FC 0020                287  PRINT_B     MOVE.B      #' ',(A4)+
0000123C  18FC 0000                288              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001240  43F9 00001A50            289              LEA         BAD_STR,A1 *Load good data for printing
00001246  103C 000D                290              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000124A  4E4F                     291              TRAP        #15         *Display string
0000124C                           292              
0000124C  4E75                     293              RTS 
0000124E                           294  
0000124E                           295  *-------------------END_OPT---------------------------------
0000124E  4EF9 00001254            296  END_OPT     JMP         DONE        *Jump to done for now untill end options logic is implemented
00001254                           297              
00001254                           298  *-----------------------DONE--------------------------------
00001254  103C 0009                299  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
00001258  4E4F                     300              TRAP        #15         *Halt program, Trap#15 task 9
0000125A                           301              
0000125A                           302  *---------------Variables and Constants---------------------
0000125A                           303              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
0000125A                           304  
0000125A                           305  
0000125A  4282                     306  JMP_TBL     CLR.L       D2
0000125C  3407                     307              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000125E  4281                     308              CLR.L       D1
00001260  123C 000C                309              MOVE.B      #12,D1      *Moves 12 into D1
00001264  E26A                     310              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
00001266                           311                          
00001266  B43C 0000                312  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
0000126A  6600 000A                313              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
0000126E  4EB9 00001392            314              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
00001274  4E75                     315              RTS                     *Finished all jumping; whole instruction should be identified at this point
00001276                           316              
00001276  B43C 0001                317  JMP_1       CMP.B       #$1,D2
0000127A  6600 000A                318              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
0000127E  4EB9 0000145E            319              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
00001284  4E75                     320              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
00001286                           321             
00001286  B43C 0002                322  JMP_2       CMP.B       #$2,D2
0000128A  6600 000A                323              BNE         JMP_3 
0000128E  4EB9 000013BC            324              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
00001294  4E75                     325              RTS
00001296                           326              
00001296  B43C 0003                327  JMP_3       CMP.B       #$3,D2
0000129A  6600 000A                328              BNE         JMP_4
0000129E  4EB9 000013E0            329              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
000012A4  4E75                     330              RTS
000012A6                           331           
000012A6  B43C 0004                332  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
000012AA  6600 000A                333              BNE         JMP_5
000012AE  4EB9 00001404            334              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
000012B4  4E75                     335              RTS
000012B6                           336              
000012B6  B43C 0005                337  JMP_5       CMP.B       #$5,D2
000012BA  6600 000A                338              BNE         JMP_6
000012BE  4EB9 00001488            339              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
000012C4  4E75                     340              RTS
000012C6                           341              
000012C6  B43C 0006                342  JMP_6       CMP.B       #$6,D2
000012CA  6600 000A                343              BNE         JMP_7
000012CE  4EB9 00001442            344              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
000012D4  4E75                     345              RTS
000012D6                           346              
000012D6  B43C 0007                347  JMP_7       CMP.B       #$7,D2
000012DA  6600 000A                348              BNE         JMP_8
000012DE  4EB9 0000149E            349              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
000012E4  4E75                     350              RTS
000012E6                           351              
000012E6  B43C 0008                352  JMP_8       CMP.B       #$8,D2
000012EA  6600 000A                353              BNE         JMP_9
000012EE  4EB9 00001446            354              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000012F4  4E75                     355              RTS
000012F6                           356              
000012F6  B43C 0009                357  JMP_9       CMP.B       #$9,D2
000012FA  6600 000A                358              BNE         JMP_A
000012FE  4EB9 000014BC            359              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
00001304  4E75                     360              RTS
00001306                           361              
00001306  B43C 000A                362  JMP_A       CMP.B       #$A,D2
0000130A  6600 0008                363              BNE         JMP_B
0000130E  4EB8 10E0                364              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
00001312  4E75                     365              RTS
00001314                           366              
00001314  B43C 000B                367  JMP_B       CMP.B       #$B,D2
00001318  6600 0008                368              BNE         JMP_C
0000131C  4EB8 10E0                369              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
00001320  4E75                     370              RTS
00001322                           371              
00001322  B43C 000C                372  JMP_C       CMP.B       #$C,D2
00001326  6600 000A                373              BNE         JMP_D
0000132A  4EB9 0000144A            374              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
00001330  4E75                     375              RTS
00001332                           376              
00001332  B43C 000D                377  JMP_D       CMP.B       #$D,D2
00001336  6600 000A                378              BNE         JMP_E   
0000133A  4EB9 0000144E            379              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
00001340  4E75                     380              RTS
00001342                           381              
00001342  B43C 000F                382  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
00001346  6700 FD98                383              BEQ         INVALID     *If first hex value is F, jump to INVALID
0000134A  4EB9 00001452            384              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001350  4E75                     385              RTS
00001352                           386   
00001352  4282                     387  J_CLR4      CLR.L       D2                                
00001354  3407                     388              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001356  4281                     389              CLR.L       D1
00001358  E94A                     390              LSL.W       #4,D2       *Clear the most sig hex digit
0000135A  123C 000C                391              MOVE.B      #12,D1      *Moves 12 into D1
0000135E  E26A                     392              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001360  4E75                     393              RTS                     *Return back to JMP_Xn    
00001362                           394              
00001362  4282                     395  J_CLR3      CLR.L       D2          
00001364  3407                     396              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001366  4281                     397              CLR.L       D1
00001368  E94A                     398              LSL.W       #4,D2       *Clear the most sig hex digit
0000136A  123C 000D                399              MOVE.B      #13,D1      *Moves 13 into D1
0000136E  E26A                     400              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001370  4E75                     401              RTS                     *Return back to JMP_Xn  
00001372                           402  
00001372  4282                     403  J_CLR1  CLR.L       D2          
00001374  3407                     404          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001376  4281                     405          CLR.L       D1
00001378  EF4A                     406          LSL.W       #7,D2           *Clear the most sig 7 bits
0000137A  123C 0010                407          MOVE.B      #16,D1          *Moves 16 into D1
0000137E  E26A                     408          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001380  4E75                     409          RTS                         *Return back to JMP_Xn  
00001382                           410       
00001382  4282                     411  J_CLR_DM    CLR.L       D2          
00001384  3407                     412              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001386  4281                     413              CLR.L       D1
00001388  EF4A                     414              LSL.W       #7,D2       *Clear the most sig 7 bits
0000138A  123C 0011                415              MOVE.B      #17,D1      *Moves 17 into D1
0000138E  E26A                     416              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001390  4E75                     417              RTS                     *Return back to JMP_Xn     
00001392                           418   
00001392                           419  
00001392                           420          
00001392  4EB8 1352                421  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
00001396  B43C 0004                422              CMP.B       #$4,D2      *Is the next hex digit 4?
0000139A  6700 0010                423              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
0000139E  B43C 0005                424              CMP.B       #$5,D2      *Is the next hex digit 5?
000013A2  6700 0010                425              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
000013A6  4EB8 10E0                426              JSR         INVALID     *If neither, OPCODE is invalid
000013AA  4E75                     427              RTS
000013AC                           428  
000013AC  4EB9 00001456            429  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
000013B2  4E75                     430              RTS
000013B4                           431              
000013B4  4EB9 0000145A            432  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
000013BA  4E75                     433              RTS              
000013BC                           434  
000013BC  4EB8 1382                435  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013C0  B43C 0001                436              CMP.B       #$1,D2      *is the DEST MODE 1?
000013C4  6700 000A                437              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000013C8  4EB9 000013D8            438              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000013CE  4E75                     439              RTS
000013D0                           440  
000013D0  4EB9 000014DE            441  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000013D6  4E75                     442              RTS
000013D8                           443  
000013D8  4EB9 000014E0            444  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000013DE  4E75                     445              RTS                           
000013E0  4EB8 1382                446  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013E4  B43C 0001                447              CMP.B       #$1,D2      *is the DEST MODE 1?
000013E8  6700 000A                448              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000013EC  4EB9 000013FC            449              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000013F2  4E75                     450              RTS
000013F4                           451  
000013F4  4EB9 000014E2            452  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000013FA  4E75                     453              RTS
000013FC                           454  
000013FC  4EB9 000014E4            455  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
00001402  4E75                     456              RTS
00001404  4EB8 1352                457  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
00001408  B43C 0007                458              CMP.B       #7,D2       *Is the next hex digit 7?
0000140C  6700 001C                459              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001410  4EB8 1372                460              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
00001414  B43C 0001                461              CMP.B       #1,D2       *Is the last bit 1?
00001418  6700 0018                462              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
0000141C  B43C 0000                463              CMP.B       #0,D2       *Is the last bit 0?
00001420  6700 0018                464              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
00001424  4EB8 10E0                465              JSR         INVALID     *If none of the above, OPCODE is invalid
00001428  4E75                     466              RTS
0000142A                           467                                           
0000142A                           468              
0000142A  4EB9 0000145E            469  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001430  4E75                     470              RTS
00001432                           471              
00001432  4EB9 000014DA            472  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
00001438  4E75                     473              RTS
0000143A                           474              
0000143A  4EB9 000014DC            475  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001440  4E75                     476              RTS
00001442                           477              
00001442                           478  
00001442  4EB8 10E0                479  JMP_6X      JSR         INVALID     *Temp, remove once implemented
00001446                           480  
00001446  4EB8 10E0                481  JMP_8X      JSR         INVALID     *Temp, remove once implemented
0000144A                           482  
0000144A  4EB8 10E0                483  JMP_CX      JSR         INVALID     *Temp, remove once implemented
0000144E                           484  
0000144E  4EB8 10E0                485  JMP_DX      JSR         INVALID     *Temp, remove once implemented
00001452                           486  
00001452  4EB8 10E0                487  JMP_EX      JSR         INVALID     *Temp, remove once implemented
00001456                           488  
00001456                           489     
00001456  4EB8 10E0                490  OPC_04XX    JSR         INVALID     *Temp, remove once implemented
0000145A                           491  
0000145A  4EB8 10E0                492  OPC_05XX    JSR         INVALID     *Temp, remove once implemented
0000145E                           493  
0000145E                           494  JMP_47X      
0000145E                           495  
0000145E                           496  
0000145E                           497  
0000145E  18FC 004D                498  OPC_1XXX    MOVE.B      #'M',(A4)+
00001462  18FC 004F                499              MOVE.B      #'O',(A4)+
00001466  18FC 0056                500              MOVE.B      #'V',(A4)+
0000146A  18FC 0045                501              MOVE.B      #'E',(A4)+
0000146E  18FC 002E                502              MOVE.B      #'.',(A4)+
00001472  18FC 0042                503              MOVE.B      #'B',(A4)+
00001476  18FC 0020                504              MOVE.B      #' ',(A4)+
0000147A  18FC 0020                505              MOVE.B      #' ',(A4)+
0000147E                           506              
0000147E  4284                     507              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001480  4EB9 0000161C            508              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001486  4E75                     509              RTS
00001488                           510  
00001488  18FC 0041                511  OPC_5XXX    MOVE.B      #'A',(A4)+
0000148C  18FC 0044                512              MOVE.B      #'D',(A4)+
00001490  18FC 0044                513              MOVE.B      #'D',(A4)+
00001494  18FC 0051                514              MOVE.B      #'Q',(A4)+
00001498  18FC 002E                515              MOVE.B      #'.',(A4)+
0000149C                           516              *NEED to Determine sizes here
0000149C                           517              *JUMP to EACODE table
0000149C  4E75                     518              RTS
0000149E                           519  
0000149E  18FC 004D                520  OPC_7XXX    MOVE.B      #'M',(A4)+
000014A2  18FC 004F                521              MOVE.B      #'O',(A4)+
000014A6  18FC 0056                522              MOVE.B      #'V',(A4)+
000014AA  18FC 0045                523              MOVE.B      #'E',(A4)+
000014AE  18FC 0051                524              MOVE.B      #'Q',(A4)+
000014B2  18FC 002E                525              MOVE.B      #'.',(A4)+
000014B6  18FC 004C                526              MOVE.B      #'L',(A4)+
000014BA                           527              *jump to EACODE table
000014BA  4E75                     528              RTS
000014BC                           529  
000014BC  18FC 0053                530  OPC_9XXX    MOVE.B      #'S',(A4)+
000014C0  18FC 0055                531              MOVE.B      #'U',(A4)+
000014C4  18FC 0042                532              MOVE.B      #'B',(A4)+
000014C8  18FC 002E                533              MOVE.B      #'.',(A4)+
000014CC                           534              *NEED to Determine sizes here (opmode 3 bits)
000014CC  4EB9 000014E6            535              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000014D2  4EB9 0000151C            536              JSR         ADD_SIZE    * This will add size characters and start operand decode sequence
000014D8                           537              *jump to EACODE table
000014D8  4E75                     538              RTS
000014DA                           539  
000014DA  4E75                     540  OPC_LEA     RTS
000014DC                           541  
000014DC                           542  
000014DC  4E75                     543  OPC_MOVEM   RTS
000014DE                           544  
000014DE  4E75                     545  OPC_MOVEAL  RTS
000014E0                           546  
000014E0  4E75                     547  OPC_MOVEL   RTS
000014E2                           548  
000014E2  4E75                     549  OPC_MOVEAW RTS
000014E4                           550  
000014E4  4E75                     551  OPC_MOVEW  RTS
000014E6                           552  
000014E6                           553  
000014E6                           554  
000014E6  4284                     555  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
000014E8  3807                     556              MOVE.W      D7,D4       *Copy untouched opcode into D4
000014EA  EF4C                     557              LSL.W       #7,D4       *Clear more significant bits
000014EC  4283                     558              CLR.L       D3          *Make sure D3 is clear for shifting
000014EE  163C 000D                559              MOVE.B      #13,D3      *Shifting 13 times
000014F2  E66C                     560              LSR.W       D3,D4       *Move size bits to LSB position
000014F4  4E75                     561              RTS
000014F6                           562  
000014F6  4284                     563  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
000014F8  3807                     564              MOVE.W      D7,D4       *Copy untouched opcode into D4
000014FA  E14C                     565              LSL.W       #8,D4       *Clear more significant bits
000014FC  4283                     566              CLR.L       D3          *Make sure D3 is clear for shifting
000014FE  163C 000E                567              MOVE.B      #14,D3      *Shifting 14 times
00001502  E66C                     568              LSR.W       D3,D4       *Move size bits to LSB position
00001504  4E75                     569              RTS
00001506                           570  
00001506  4284                     571  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001508  3807                     572              MOVE.W      D7,D4       *Copy untouched opcode into D4
0000150A  4283                     573              CLR.L       D3          *Make sure D3 is clear for shifting
0000150C  163C 0009                574              MOVE.B      #9,D3       *Shift 9 times to the left
00001510  E76C                     575              LSL.W       D3,D4       *Clear more significant bits
00001512  4283                     576              CLR.L       D3          *Make sure D3 is clear for shifting
00001514  163C 000F                577              MOVE.B      #15,D3      *Shifting 15 times
00001518  E66C                     578              LSR.W       D3,D4       *Move size bits to LSB position
0000151A  4E75                     579              RTS
0000151C                           580  
0000151C  B83C 0000                581  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn
00001520  6700 002E                582              BEQ         B_EA
00001524  B83C 0001                583              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001528  6700 003A                584              BEQ         W_EA
0000152C  B83C 0002                585              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001530  6700 0046                586              BEQ         L_EA
00001534                           587  
00001534  B83C 0004                588              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001538  6700 0052                589              BEQ         B_DN
0000153C  B83C 0005                590              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001540  6700 005E                591              BEQ         W_DN
00001544  B83C 0006                592              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001548  6700 006A                593              BEQ         L_DN        
0000154C  6000 FB92                594              BRA         INVALID     *Got here, must be invalid data.
00001550                           595              
00001550  18FC 0042                596  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
00001554  18FC 0020                597              MOVE.B      #' ',(A4)+
00001558  18FC 0020                598              MOVE.B      #' ',(A4)+
0000155C  4EB9 000015C8            599              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
00001562  4E75                     600              RTS
00001564                           601  
00001564  18FC 0057                602  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
00001568  18FC 0020                603              MOVE.B      #' ',(A4)+
0000156C  18FC 0020                604              MOVE.B      #' ',(A4)+
00001570  4EB9 000015C8            605              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
00001576  4E75                     606              RTS
00001578                           607  
00001578  18FC 004C                608  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
0000157C  18FC 0020                609              MOVE.B      #' ',(A4)+
00001580  18FC 0020                610              MOVE.B      #' ',(A4)+
00001584  4EB9 000015C8            611              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
0000158A  4E75                     612              RTS
0000158C                           613  
0000158C  18FC 0042                614  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001590  18FC 0020                615              MOVE.B      #' ',(A4)+
00001594  18FC 0020                616              MOVE.B      #' ',(A4)+
00001598  4EB9 000015DE            617              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
0000159E  4E75                     618              RTS
000015A0                           619  
000015A0  18FC 0057                620  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
000015A4  18FC 0020                621              MOVE.B      #' ',(A4)+
000015A8  18FC 0020                622              MOVE.B      #' ',(A4)+
000015AC  4EB9 000015DE            623              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015B2  4E75                     624              RTS
000015B4                           625  
000015B4  18FC 004C                626  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
000015B8  18FC 0020                627              MOVE.B      #' ',(A4)+
000015BC  18FC 0020                628              MOVE.B      #' ',(A4)+
000015C0  4EB9 000015DE            629              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015C6  4E75                     630              RTS            
000015C8                           631              
000015C8                           632              
000015C8                           633              
000015C8                           634              
000015C8                           635              
000015C8                           636              
000015C8                           637              
000015C8                           638  
000015C8                           639  
000015C8                           640  
000015C8                           641  -------------------- end include --------------------
000015C8                           642              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
000015C8                           643  
000015C8                           644  
000015C8  4EB9 000015FA            645  EA_SRC      JSR         GEN_EA_CODE *Deal with EA code First
000015CE  18FC 002C                646              MOVE.B      #',',(A4)+
000015D2  18FC 0044                647              MOVE.B      #'D',(A4)+
000015D6  4EB9 00001662            648              JSR         REG_CODE    *Decode Dn and add number to string
000015DC  4E75                     649              RTS
000015DE                           650  
000015DE  18FC 0044                651  DN_SRC      MOVE.B      #'D',(A4)+
000015E2  4EB9 00001662            652              JSR         REG_CODE     *Decode Dn and add number to string
000015E8  18FC 002C                653              MOVE.B      #',',(A4)+
000015EC  4EB9 000015FA            654              JSR         GEN_EA_CODE *Deal with EA code Second
000015F2  4E75                     655              RTS
000015F4                           656  
000015F4                           657  MM_OP_ORD 
000015F4  4E75                     658              RTS
000015F6                           659  
000015F6                           660  MM_EA_SRC   *Deal with EA code first
000015F6                           661              *Deal with list second
000015F6  4E75                     662              RTS
000015F8                           663  
000015F8                           664  MM_LS_SRC   *Deal with list first
000015F8                           665              *Deal with EA code second
000015F8  4E75                     666              RTS
000015FA                           667  
000015FA                           668  
000015FA                           669  
000015FA  4283                     670  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
000015FC  4286                     671              CLR.L       D6          *Make sure D6 is clear
000015FE  4281                     672              CLR.L       D1          *Make sure D1 is clear for shifting
00001600                           673              
00001600  3607                     674              MOVE.W      D7,D3       *Move untouched opcode into D3
00001602  3C07                     675              MOVE.W      D7,D6       *Move untouched opcode into D6
00001604                           676              
00001604  123C 000A                677              MOVE.B      #10,D1      *Shifting to isolate MODE
00001608  E36E                     678              LSL.W       D1,D6       
0000160A  123C 000D                679              MOVE.B      #13,D1
0000160E  E26E                     680              LSR.W       D1,D6       *Move MODE bits to LSB position
00001610                           681              
00001610  E36B                     682              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001612  E26B                     683              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001614                           684              
00001614  4EB9 00001678            685              JSR         EA_TBL      *Decode MODE to select correct <EA>
0000161A  4E75                     686              RTS
0000161C                           687              
0000161C  4283                     688  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
0000161E  4286                     689              CLR.L       D6          *Make sure D6 is clear
00001620  4281                     690              CLR.L       D1          *Make sure D1 is clear for shifting
00001622                           691              
00001622  3607                     692              MOVE.W      D7,D3       *Move untouched opcode into D3
00001624  3C07                     693              MOVE.W      D7,D6       *Move untouched opcode into D6
00001626                           694              
00001626  123C 000A                695              MOVE.B      #10,D1      *Shifting to isolate MODE
0000162A  E36E                     696              LSL.W       D1,D6       
0000162C  123C 000D                697              MOVE.B      #13,D1
00001630  E26E                     698              LSR.W       D1,D6       *Move MODE bits to LSB position
00001632                           699              
00001632  E36B                     700              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001634  E26B                     701              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001636                           702              
00001636  4EB9 00001678            703              JSR         EA_TBL      *Decode MODE to select correct <EA>
0000163C                           704              
0000163C  18FC 002C                705              MOVE.B      #',',(A4)+  *SEPERATOR
00001640                           706              
00001640  4283                     707              CLR.L       D3          *Make sure D3 is clear
00001642  4286                     708              CLR.L       D6          *Make sure D6 is clear
00001644  4281                     709              CLR.L       D1          *Make sure D1 is clear for shifting
00001646                           710              
00001646  3607                     711              MOVE.W      D7,D3       *Move untouched opcode into D3
00001648  3C07                     712              MOVE.W      D7,D6       *Move untouched opcode into D6
0000164A                           713              
0000164A  123C 0007                714              MOVE.B      #7,D1      *Shifting to isolate MODE
0000164E  E36E                     715              LSL.W       D1,D6       
00001650  123C 000D                716              MOVE.B      #13,D1
00001654  E26E                     717              LSR.W       D1,D6       *Move MODE bits to LSB position
00001656                           718              
00001656  E94B                     719              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001658  E26B                     720              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
0000165A                           721              
0000165A  4EB9 00001678            722              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001660                           723              
00001660  4E75                     724              RTS
00001662                           725              
00001662                           726              
00001662  4283                     727  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
00001664  3607                     728              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
00001666  E94B                     729              LSL.W       #4,D3       *Isolate bits and move to LSB position
00001668  4282                     730              CLR.L       D2
0000166A  143C 000D                731              MOVE.B      #13,D2
0000166E  E46B                     732              LSR.W       D2,D3
00001670  4EB9 00001710            733              JSR         REG_TBL     *Jump to register table.
00001676  4E75                     734              RTS
00001678                           735  
00001678                           736  
00001678  BC3C 0000                737  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
0000167C  6700 002E                738              BEQ         DRD
00001680  BC3C 0001                739              CMP.B       #1,D6
00001684  6700 0032                740              BEQ         ARD
00001688  BC3C 0002                741              CMP.B       #2,D6
0000168C  6700 0036                742              BEQ         ARI
00001690  BC3C 0003                743              CMP.B       #3,D6
00001694  6700 0042                744              BEQ         ARI_INC
00001698  BC3C 0004                745              CMP.B       #4,D6
0000169C  6700 0052                746              BEQ         ARI_DEC
000016A0  BC3C 0007                747              CMP.B       #7,D6
000016A4  6700 0062                748              BEQ         ABS_ADDR
000016A8  4EF8 10E0                749              JMP         INVALID     *Got here? Must be bad data.
000016AC                           750  
000016AC  18FC 0044                751  DRD         MOVE.B      #'D',(A4)+
000016B0  4EB9 00001710            752              JSR         REG_TBL     *Reg num should be in D3
000016B6  4E75                     753              RTS
000016B8                           754  
000016B8  18FC 0041                755  ARD         MOVE.B      #'A',(A4)+
000016BC  4EB9 00001710            756              JSR         REG_TBL     *Reg num should be in D3
000016C2  4E75                     757              RTS
000016C4                           758  
000016C4  18FC 0028                759  ARI         MOVE.B      #'(',(A4)+
000016C8  18FC 0041                760              MOVE.B      #'A',(A4)+
000016CC  4EB9 00001710            761              JSR         REG_TBL     *Reg num should be in D3
000016D2  18FC 0029                762              MOVE.B      #')',(A4)+
000016D6  4E75                     763              RTS
000016D8                           764  
000016D8  18FC 0028                765  ARI_INC     MOVE.B      #'(',(A4)+
000016DC  18FC 0041                766              MOVE.B      #'A',(A4)+
000016E0  4EB9 00001710            767              JSR         REG_TBL     *Reg num should be in D3
000016E6  18FC 0029                768              MOVE.B      #')',(A4)+
000016EA  18FC 002B                769              MOVE.B      #'+',(A4)+
000016EE  4E75                     770              RTS
000016F0                           771  
000016F0  18FC 002D                772  ARI_DEC     MOVE.B      #'-',(A4)+
000016F4  18FC 0028                773              MOVE.B      #'(',(A4)+
000016F8  18FC 0041                774              MOVE.B      #'A',(A4)+
000016FC  4EB9 00001710            775              JSR         REG_TBL     *Reg num should be in D3
00001702  18FC 0029                776              MOVE.B      #')',(A4)+
00001706  4E75                     777              RTS
00001708                           778  
00001708  4EB9 00001784            779  ABS_ADDR    JSR         ABS_TBL
0000170E  4E75                     780              RTS
00001710                           781              
00001710  B63C 0000                782  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001714  6700 003E                783              BEQ         NUM_0
00001718  B63C 0001                784              CMP.B       #1,D3
0000171C  6700 003C                785              BEQ         NUM_1
00001720  B63C 0002                786              CMP.B       #2,D3
00001724  6700 003A                787              BEQ         NUM_2
00001728  B63C 0003                788              CMP.B       #3,D3
0000172C  6700 0038                789              BEQ         NUM_3
00001730  B63C 0004                790              CMP.B       #4,D3
00001734  6700 0036                791              BEQ         NUM_4
00001738  B63C 0005                792              CMP.B       #5,D3
0000173C  6700 0034                793              BEQ         NUM_5
00001740  B63C 0006                794              CMP.B       #6,D3
00001744  6700 0032                795              BEQ         NUM_6
00001748  B63C 0007                796              CMP.B       #7,D3
0000174C  6700 0030                797              BEQ         NUM_7
00001750  4EF8 10E0                798              JMP         INVALID     *Got here? Must be bad data.
00001754                           799              
00001754  18FC 0030                800  NUM_0       MOVE.B      #'0',(A4)+
00001758  4E75                     801              RTS              
0000175A  18FC 0031                802  NUM_1       MOVE.B      #'1',(A4)+
0000175E  4E75                     803              RTS
00001760  18FC 0032                804  NUM_2       MOVE.B      #'2',(A4)+
00001764  4E75                     805              RTS
00001766  18FC 0033                806  NUM_3       MOVE.B      #'3',(A4)+
0000176A  4E75                     807              RTS
0000176C  18FC 0034                808  NUM_4       MOVE.B      #'4',(A4)+
00001770  4E75                     809              RTS
00001772  18FC 0035                810  NUM_5       MOVE.B      #'5',(A4)+
00001776  4E75                     811              RTS
00001778  18FC 0036                812  NUM_6       MOVE.B      #'6',(A4)+
0000177C  4E75                     813              RTS
0000177E  18FC 0037                814  NUM_7       MOVE.B      #'7',(A4)+
00001782  4E75                     815              RTS
00001784                           816  
00001784  B63C 0000                817  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001788  6700 0016                818              BEQ         ABW
0000178C  B63C 0001                819              CMP.B       #1,D3
00001790  6700 001E                820              BEQ         ABL
00001794  B63C 0004                821              CMP.B       #4,D3
00001798  6700 0026                822              BEQ         IDATA
0000179C  4EF8 10E0                823              JMP         INVALID     *Got here? Must be bad data.
000017A0                           824              
000017A0  18FC 0024                825  ABW         MOVE.B      #'$',(A4)+
000017A4  4281                     826              CLR.L       D1          *Make sure D1 is clear
000017A6  321D                     827              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
000017A8  4EB9 0000186A            828              JSR         W_H2A       *convert absolute value to ascii and add to good string
000017AE  4E75                     829              RTS
000017B0                           830  
000017B0  18FC 0024                831  ABL         MOVE.B      #'$',(A4)+
000017B4  4281                     832              CLR.L       D1          *Make sure D1 is clear
000017B6  221D                     833              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
000017B8  4EB9 000018AC            834              JSR         L_H2A
000017BE  4E75                     835              RTS
000017C0                           836              
000017C0  18FC 0023                837  IDATA       MOVE.B      #'#',(A4)+
000017C4  18FC 0024                838              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
000017C8  4EB9 000017D0            839              JSR         IMD_TBL
000017CE  4E75                     840              RTS
000017D0                           841              
000017D0  B83C 0000                842  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
000017D4  6700 002E                843              BEQ         B_IMD       
000017D8  B83C 0004                844              CMP.B       #4,D4
000017DC  6700 0026                845              BEQ         B_IMD
000017E0                           846  
000017E0  B83C 0001                847              CMP.B       #1,D4       *Is it a word size code?
000017E4  6700 002A                848              BEQ         W_IMD
000017E8  B83C 0005                849              CMP.B       #5,D4
000017EC  6700 0022                850              BEQ         W_IMD
000017F0                           851              
000017F0  B83C 0002                852              CMP.B       #2,D4       *Is it a long word size code?
000017F4  6700 0026                853              BEQ         L_IMD
000017F8  B83C 0006                854              CMP.B       #6,D4
000017FC  6700 001E                855              BEQ         L_IMD
00001800                           856              
00001800  6000 F8DE                857              BRA         INVALID     *Got here? Must be bad data.
00001804                           858              
00001804  4281                     859  B_IMD       CLR.L       D1
00001806  321D                     860              MOVE.W      (A5)+,D1    *Make sure D1 is clear
00001808  4EB9 00001828            861              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
0000180E  4E75                     862              RTS
00001810                           863  
00001810  4281                     864  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001812  321D                     865              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001814  4EB9 0000186A            866              JSR         W_H2A
0000181A  4E75                     867              RTS
0000181C                           868  
0000181C  4281                     869  L_IMD       CLR.L       D1          *Make sure D1 is clear
0000181E  221D                     870              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
00001820  4EB9 000018AC            871              JSR         L_H2A
00001826  4E75                     872              RTS
00001828                           873                                 
00001828                           874  
00001828                           875  
00001828                           876  
00001828  4280                     877  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
0000182A  4282                     878              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000182C  4283                     879              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000182E  103C 0002                880              MOVE.B      #$2,D0      *Counter
00001832  6000 0002                881              BRA         B_ISO_DIG   *Begin isolating chars
00001836                           882              
00001836  E919                     883  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
00001838                           884              
00001838  1401                     885              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000183A                           886              
0000183A  163C 0004                887              MOVE.B      #4,D3      *Shift left 28 times
0000183E  E72A                     888              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00001840  E91A                     889              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00001842                           890              
00001842  0C02 0009                891              CMPI.B      #$9,D2      *Is it a number?
00001846  6F00 0006                892              BLE         B_NUM       *If it is, process number
0000184A  6000 000A                893              BRA         B_LET       *If not, process letter
0000184E                           894              
0000184E  0602 0030                895  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001852  6000 000A                896              BRA         B_ADD_CHAR  *add to strings and continue
00001856                           897              
00001856  0602 0037                898  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000185A  6000 0002                899              BRA         B_ADD_CHAR  *add to strings and continue
0000185E                           900  
0000185E  18C2                     901  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001860  5300                     902              SUBI.B      #$1,D0      *decrement counter
00001862  0C00 0000                903              CMPI.B      #$0,D0      *Check if we're done            
00001866  6ECE                     904              BGT         B_ISO_DIG   *If not, continue tranlation   
00001868                           905              
00001868  4E75                     906              RTS
0000186A                           907  
0000186A  4280                     908  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
0000186C  4282                     909              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000186E  4283                     910              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001870  103C 0004                911              MOVE.B      #$4,D0      *Counter
00001874  6000 0002                912              BRA         W_ISO_DIG   *Begin isolating chars
00001878                           913              
00001878  E959                     914  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
0000187A                           915              
0000187A  1401                     916              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000187C                           917              
0000187C  163C 000C                918              MOVE.B      #12,D3      *Shift left 28 times
00001880  E76A                     919              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
00001882  E95A                     920              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
00001884                           921              
00001884  0C02 0009                922              CMPI.B      #$9,D2      *Is it a number?
00001888  6F00 0006                923              BLE         W_NUM       *If it is, process number
0000188C  6000 000A                924              BRA         W_LET       *If not, process letter
00001890                           925              
00001890  0602 0030                926  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001894  6000 000A                927              BRA         W_ADD_CHAR  *add to strings and continue
00001898                           928              
00001898  0602 0037                929  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000189C  6000 0002                930              BRA         W_ADD_CHAR  *add to strings and continue
000018A0                           931  
000018A0  18C2                     932  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018A2  5300                     933              SUBI.B      #$1,D0      *decrement counter
000018A4  0C00 0000                934              CMPI.B      #$0,D0      *Check if we're done            
000018A8  6ECE                     935              BGT         W_ISO_DIG   *If not, continue tranlation   
000018AA                           936              
000018AA  4E75                     937              RTS
000018AC  4280                     938  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000018AE  4282                     939              CLR.L       D2          *Make sure D2 is empty (each individual char)
000018B0  4283                     940              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000018B2  103C 0008                941              MOVE.B      #$8,D0      *Counter
000018B6  6000 0002                942              BRA         L_ISO_DIG   *Begin isolating chars
000018BA                           943              
000018BA  E999                     944  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
000018BC                           945              
000018BC  1401                     946              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
000018BE                           947              
000018BE  163C 001C                948              MOVE.B      #28,D3      *Shift left 28 times
000018C2  E7AA                     949              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000018C4  E99A                     950              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000018C6                           951              
000018C6  0C02 0009                952              CMPI.B      #$9,D2      *Is it a number?
000018CA  6F00 0006                953              BLE         L_NUM       *If it is, process number
000018CE  6000 000A                954              BRA         L_LET       *If not, process letter
000018D2                           955              
000018D2  0602 0030                956  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000018D6  6000 000A                957              BRA         L_ADD_CHAR  *add to strings and continue
000018DA                           958              
000018DA  0602 0037                959  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000018DE  6000 0002                960              BRA         L_ADD_CHAR  *add to strings and continue
000018E2                           961  
000018E2  18C2                     962  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018E4  5300                     963              SUBI.B      #$1,D0      *decrement counter
000018E6  0C00 0000                964              CMPI.B      #$0,D0      *Check if we're done            
000018EA  6ECE                     965              BGT         L_ISO_DIG   *If not, continue tranlation   
000018EC                           966              
000018EC  4E75                     967              RTS
000018EE                           968  
000018EE                           969  
000018EE                           970  
000018EE                           971  
000018EE                           972  
000018EE                           973  -------------------- end include --------------------
000018EE                           974  
000018EE  =0000000D                975  CR          EQU         $0D
000018EE  =0000000A                976  LF          EQU         $0A
000018EE                           977  
000018EE= 2D 2D 2D 2D 2D 2D ...    978  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
00001918= 48 65 6E 72 79 20 ...    979              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00001941= 43 53 53 20 34 32 ...    980              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
0000196A= 2D 2D 2D 2D 2D 2D ...    981              DC.B        '----------------------------------------',CR,LF,0
00001995                           982              
00001995= 45 6E 74 65 72 20 ...    983  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
000019B8= 45 6E 74 65 72 20 ...    984  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000019D9= 50 72 65 73 73 20 ...    985  NXT_PG      DC.B        'Press enter key to contiune reading',CR,LF,0
000019FF                           986  
000019FF                           987  STA_ADDR    DS.B        40
00001A27                           988  END_ADDR    DS.B        40
00001A4F                           989  
00001A4F                           990  
00001A4F                           991  
00001A4F                           992  
00001A50= 00000001                 993  BAD_STR     DC.L        1
00001A54                           994  
00001A54= 00000050                 995  SPACER11    DC.L        80
00001A58= 00000050                 996  SPACER22    DC.L        80
00001A5C= 00000050                 997  SPACER33    DC.L        80
00001A60= 00000050                 998  SPACER44    DC.L        80
00001A64= 00000050                 999  SPACER55    DC.L        80
00001A68= 00000050                1000  SPACER66    DC.L        80
00001A6C= 00000050                1001  SPACER77    DC.L        80
00001A70= 00000050                1002  SPACER88    DC.L        80
00001A74= 00000050                1003  SPACER99    DC.L        80
00001A78= 00000050                1004  SPACERAA    DC.L        80
00001A7C= 00000050                1005  SPACERBB    DC.L        80
00001A80= 00000050                1006  SPACERCC    DC.L        80
00001A84= 00000050                1007  SPACERDD    DC.L        80
00001A88= 00000050                1008  SPACEREE    DC.L        80
00001A8C= 00000050                1009  SPACERFF    DC.L        80
00001A90                          1010  
00001A90= 00000001                1011  GOOD_STR    DC.L        1
00001A94                          1012  
00001A94= 00000050                1013  SPACER1     DC.L        80
00001A98= 00000050                1014  SPACER2     DC.L        80
00001A9C= 00000050                1015  SPACER3     DC.L        80
00001AA0= 00000050                1016  SPACER4     DC.L        80
00001AA4= 00000050                1017  SPACER5     DC.L        80
00001AA8= 00000050                1018  SPACER6     DC.L        80
00001AAC= 00000050                1019  SPACER7     DC.L        80
00001AB0= 00000050                1020  SPACER8     DC.L        80
00001AB4= 00000050                1021  SPACER9     DC.L        80
00001AB8= 00000050                1022  SPACERA     DC.L        80
00001ABC= 00000050                1023  SPACERB     DC.L        80
00001AC0= 00000050                1024  SPACERC     DC.L        80
00001AC4= 00000050                1025  SPACERD     DC.L        80
00001AC8= 00000050                1026  SPACERE     DC.L        80
00001ACC= 00000050                1027  SPACERF     DC.L        80
00001AD0                          1028  
00001AD0                          1029              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 17B0
ABS_ADDR            1708
ABS_TBL             1784
ABW                 17A0
ADD_CHAR_B          11CE
ADD_CHAR_G          1216
ADD_SIZE            151C
AH_DONE             1092
ARD                 16B8
ARI                 16C4
ARI_DEC             16F0
ARI_INC             16D8
ASCII_HEX           107A
BAD_STR             1A50
B_ADD_CHAR          185E
B_DN                158C
B_EA                1550
B_H2A               1828
B_IMD               1804
B_ISO_DIG           1836
B_LET               1856
B_NUM               184E
CLEAN_GS            117C
CONTINUE            10EA
CR                  D
DECODE_LOOP         10B6
DN_SRC              15DE
DONE                1254
DRD                 16AC
D_CLEAN             1192
EA_SRC              15C8
EA_TBL              1678
END_ADDR            1A27
END_MSG             19B8
END_OPT             124E
FORMAT              10A8
GEN_EA_CODE         15FA
GET_INPUT           1020
GET_SIZE_1          1506
GET_SIZE_2          14F6
GET_SIZE_3          14E6
GOOD_STR            1A90
GS_LOOP             1182
HEX_ASCII_B         1194
HEX_ASCII_G         11DA
IDATA               17C0
IMD_TBL             17D0
INIT_BAD            1144
INIT_GOOD           1130
INIT_STRS           1122
INTRO               1012
INVALID             10E0
ISO_DIG_B           11A6
ISO_DIG_G           11EE
JMP_0               1266
JMP_0X              1392
JMP_1               1276
JMP_2               1286
JMP_2X              13BC
JMP_3               1296
JMP_3X              13E0
JMP_4               12A6
JMP_47X             145E
JMP_4X              1404
JMP_5               12B6
JMP_6               12C6
JMP_6X              1442
JMP_7               12D6
JMP_8               12E6
JMP_8X              1446
JMP_9               12F6
JMP_A               1306
JMP_B               1314
JMP_C               1322
JMP_CX              144A
JMP_D               1332
JMP_DX              144E
JMP_E               1342
JMP_EX              1452
JMP_TBL             125A
J_47X               142A
J_ADDI              13B4
J_CLR1              1372
J_CLR3              1362
J_CLR4              1352
J_CLR_DM            1382
J_LEA               1432
J_MOVEAL            13D0
J_MOVEAW            13F4
J_MOVEL             13D8
J_MOVEM             143A
J_MOVEW             13FC
J_SUBI              13AC
LET                 109E
LET_B               11C6
LET_G               120E
LF                  A
L_ADD_CHAR          18E2
L_DN                15B4
L_EA                1578
L_H2A               18AC
L_IMD               181C
L_ISO_DIG           18BA
L_LET               18DA
L_NUM               18D2
MM_EA_SRC           15F6
MM_LS_SRC           15F8
MM_OP_ORD           15F4
MOV_EA_CODE         161C
NEXT_PAGE           10FC
NL_INTRO            18EE
NUM                 1094
NUM_0               1754
NUM_1               175A
NUM_2               1760
NUM_3               1766
NUM_4               176C
NUM_5               1772
NUM_6               1778
NUM_7               177E
NUM_B               11BE
NUM_G               1206
NXT_PG              19D9
OPC_04XX            1456
OPC_05XX            145A
OPC_1XXX            145E
OPC_5XXX            1488
OPC_7XXX            149E
OPC_9XXX            14BC
OPC_LEA             14DA
OPC_MOVEAL          14DE
OPC_MOVEAW          14E2
OPC_MOVEL           14E0
OPC_MOVEM           14DC
OPC_MOVEW           14E4
PRINT_B             1238
PRINT_G             1222
PRINT_GOOD          10D6
PROC_END            106E
PROC_STA            1062
REG_CODE            1662
REG_TBL             1710
SPACER1             1A94
SPACER11            1A54
SPACER2             1A98
SPACER22            1A58
SPACER3             1A9C
SPACER33            1A5C
SPACER4             1AA0
SPACER44            1A60
SPACER5             1AA4
SPACER55            1A64
SPACER6             1AA8
SPACER66            1A68
SPACER7             1AAC
SPACER77            1A6C
SPACER8             1AB0
SPACER88            1A70
SPACER9             1AB4
SPACER99            1A74
SPACERA             1AB8
SPACERAA            1A78
SPACERB             1ABC
SPACERBB            1A7C
SPACERC             1AC0
SPACERCC            1A80
SPACERD             1AC4
SPACERDD            1A84
SPACERE             1AC8
SPACEREE            1A88
SPACERF             1ACC
SPACERFF            1A8C
START               1000
STA_ADDR            19FF
STA_MSG             1995
W_ADD_CHAR          18A0
W_DN                15A0
W_EA                1564
W_H2A               186A
W_IMD               1810
W_ISO_DIG           1878
W_LET               1898
W_NUM               1890
