00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/31/2017 8:19:23 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010C2             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 000020C2             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 00002169             28  GET_INPUT   LEA         IN_WARN,A1 *Load INTRO1 message into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display intro
0000102A  4E4F                      30              TRAP        #15 
0000102C                            31  
0000102C  43F9 00002430             32              LEA         STA_MSG,A1  *Load STA_MSG into A1
00001032  103C 000E                 33              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  43F9 000024E5             36              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
0000103E  103C 0002                 37              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001042  4E4F                      38              TRAP        #15         
00001044                            39              
00001044  4EB9 0000106E             40              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000104A  4281                      41              CLR.L       D1          *Clear input length from D1
0000104C                            42              
0000104C  43F9 00002453             43              LEA         END_MSG,A1  *Load END_MSG into A1
00001052  103C 000E                 44              MOVE.B      #14,D0      *Trap task 14, display end address msg
00001056  4E4F                      45              TRAP        #15
00001058                            46              
00001058  43F9 0000250D             47              LEA         END_ADDR,A1 *Store input in END_ADDR variable
0000105E  103C 0002                 48              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001062  4E4F                      49              TRAP        #15         
00001064                            50              
00001064  4EB9 0000107A             51              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000106A  4281                      52              CLR.L       D1          *Clear input length from D1
0000106C                            53              
0000106C  4E75                      54              RTS
0000106E                            55              
0000106E                            56  *--------------------PROC_STA-------------------------------
0000106E                            57  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
0000106E  4EB9 00001086             58              JSR         ASCII_HEX   *Convert input into Hex
00001074                            59              
00001074                            60              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            61              
00001074  2A43                      62              MOVEA.L     D3,A5       *Move hex to STA_ADDR
00001076  4283                      63              CLR.L       D3          *Clear D3
00001078  4E75                      64              RTS                     
0000107A                            65  
0000107A                            66  *--------------------PROC_END-------------------------------
0000107A                            67  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000107A                            68              *      does not fall before start
0000107A  4EB9 00001086             69              JSR         ASCII_HEX   *Convert input into Hex
00001080                            70              
00001080                            71              *assuming all error checking is done before the next instruction (not yet implemented)
00001080                            72              
00001080  2C43                      73              MOVE.L      D3,A6       *Move hex to END_ADDR
00001082  4283                      74              CLR.L       D3          *Clear D3
00001084  4E75                      75              RTS
00001086                            76  
00001086                            77  *-------------------ASCII_HEX-------------------------------
00001086  0C01 0000                 78  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000108A  6700 0012                 79              BEQ         AH_DONE     *End subroutine if all converted
0000108E  1419                      80              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001090  183C 0039                 81              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001094  B404                      82              CMP.B       D4,D2       *Check if ascii code is for a number or letter
00001096  6F00 0008                 83              BLE         NUM         *Codes less than $39 imply a number, so branch
0000109A  6000 000E                 84              BRA         LET         *If not a number, must be a letter.            
0000109E  4E75                      85  AH_DONE     RTS
000010A0                            86  
000010A0  183C 0030                 87  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
000010A4  9404                      88              SUB.B       D4,D2       *convert to hexadecimal number
000010A6  6000 000C                 89              BRA         FORMAT      *branch to subroutine to store converted hex number
000010AA                            90              
000010AA  183C 0037                 91  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010AE  9404                      92              SUB.B       D4,D2       *convert to hexadecimal letter
000010B0  6000 0002                 93              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010B4                            94  
000010B4  5301                      95  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010B6  D602                      96              ADD.B       D2,D3       *Store converted number in D3
000010B8  0C01 0000                 97              CMPI.B      #$0,D1      *Check if we're all done converting
000010BC  67C8                      98              BEQ         ASCII_HEX   *If not continue conversion
000010BE  E983                      99              ASL.L       #4,D3       *Shift bits to the left to correct position
000010C0  60C4                     100              BRA         ASCII_HEX   *Branch back to label
000010C2                           101              
000010C2                           102  *-------------------DECODE_LOOP-----------------------------
000010C2  3E1D                     103  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010C4  47F9 00002536            104              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010CA  49F9 00002576            105              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010D0                           106              
000010D0  4EB9 00001140            107              JSR         INIT_STRS   *Initialize Bad and Good Str
000010D6                           108              
000010D6  4EB9 00001310            109              JSR         JMP_TBL     *Start opcode identification waterfall
000010DC                           110              
000010DC  4EB9 0000112A            111              JSR         CLEAN_GS    *end of output string.
000010E2                           112              
000010E2  4EB9 0000126A            113  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010E8  6000 000C                114              BRA         CONTINUE    *Continue the loop
000010EC  4EB9 00001280            115  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010F2  6000 0002                116              BRA         CONTINUE    *Continue the loop            
000010F6                           117              
000010F6  220D                     118  CONTINUE    MOVE.L      A5,D1
000010F8  240E                     119              MOVE.L      A6,D2
000010FA  B481                     120              CMP.L       D1,D2
000010FC  6F00 01E8                121              BLE         END_OPT     *if we're done, move to end options (ask user what to do)
00001100                           122              
00001100                           123                          
00001100  5205                     124              ADDQ.B      #1,D5       *Increment line counter
00001102  BA3C 001D                125              CMP.B       #29,D5      *See if page is full
00001106  6700 0004                126              BEQ         NEXT_PAGE   *Jump to next page prompt
0000110A                           127              
0000110A  60B6                     128              BRA         DECODE_LOOP * Continue loop
0000110C                           129  
0000110C                           130  *-------------------NEXT_PAGE-----------------------------
0000110C  43F9 00002474            131  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001112  4280                     132              CLR.L       D0          *Make sure D0 is empty
00001114  103C 000E                133              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001118  4E4F                     134              TRAP        #15            
0000111A                           135              
0000111A  103C 0005                136              MOVE.B      #5,D0       *Single char trap task
0000111E  4E4F                     137              TRAP        #15         
00001120                           138              
00001120  B23C 000D                139              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001124  66E6                     140              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
00001126                           141              
00001126  4285                     142              CLR.L       D5          *Reset page counter
00001128                           143              
00001128  6098                     144              BRA         DECODE_LOOP *Continue the loop
0000112A                           145              
0000112A                           146  *-------------------GS_CLEAN--------------------------------
0000112A                           147  * This subroutine "cleans" the end of the good string.
0000112A                           148  * Prevents the previous string from showing content in the
0000112A                           149  * current string.
0000112A                           150  *-----------------------------------------------------------
0000112A  4280                     151  CLEAN_GS    CLR.L       D0
0000112C  103C 000F                152              MOVE.B      #15,D0      *Max 15 chars to clean
00001130                           153  
00001130  0C00 0000                154  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001134  6700 0008                155              BEQ         D_CLEAN
00001138  421C                     156              CLR.B       (A4)+
0000113A  5300                     157              SUBI.B      #$1,D0
0000113C  60F2                     158              BRA         GS_LOOP
0000113E  4E75                     159  D_CLEAN     RTS
00001140                           160              
00001140                           161  *-------------------INIT_STRS-----------------------------
00001140  4EB9 0000114E            162  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001146  4EB9 00001162            163              JSR         INIT_BAD    *Initialize the bad string
0000114C  4E75                     164              RTS
0000114E                           165              
0000114E                           166  *-------------------INIT_GOOD-----------------------------
0000114E  18FC 0024                167  INIT_GOOD   MOVE.B      #'$',(A4)+ 
00001152  4EB9 00001194            168              JSR         H2A_G_ADDR *Now convert address to ASCII
00001158                           169              
00001158  18FC 0020                170              MOVE.B      #' ',(A4)+  *Add spaces after addr
0000115C  18FC 0020                171              MOVE.B      #' ',(A4)+
00001160                           172              
00001160  4E75                     173              RTS
00001162                           174  
00001162                           175  *-------------------INIT_BAD------------------------------            
00001162  16FC 0024                176  INIT_BAD    MOVE.B      #'$',(A3)+
00001166  4EB9 000011DC            177              JSR         H2A_B_ADDR  *Add the address to the bad string
0000116C  16FC 0020                178              MOVE.B      #' ',(A3)+    
00001170  16FC 0020                179              MOVE.B      #' ',(A3)+
00001174                           180              
00001174  16FC 0044                181              MOVE.B      #'D',(A3)+  
00001178  16FC 0041                182              MOVE.B      #'A',(A3)+ 
0000117C  16FC 0054                183              MOVE.B      #'T',(A3)+    
00001180  16FC 0041                184              MOVE.B      #'A',(A3)+ 
00001184                           185              
00001184  16FC 0020                186              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001188  16FC 0020                187              MOVE.B      #' ',(A3)+
0000118C  4EB9 00001224            188              JSR         H2A_B_OP   *Add the opcode to the bad string
00001192                           189              
00001192  4E75                     190              RTS
00001194                           191              
00001194                           192  *-------------------H2A_G_ADDR-------------------------------            
00001194  4280                     193  H2A_G_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     194              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     195              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     196              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  220D                     197              MOVE.L      A5,D1       *Copy address into D1
0000119E  5581                     198              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011A0  103C 0008                199              MOVE.B      #$8,D0      *Counter
000011A4  6000 0002                200              BRA         ISO_DIG_G   *Begin isolating chars
000011A8                           201              
000011A8  E999                     202  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011AA                           203              
000011AA  2401                     204              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AC                           205              
000011AC  163C 001C                206              MOVE.B      #28,D3      *Shift left 28 times
000011B0  E7AA                     207              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B2  E99A                     208              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B4                           209              
000011B4  0C02 0009                210              CMPI.B      #$9,D2      *Is it a number?
000011B8  6F00 0006                211              BLE         NUM_G       *If it is, process number
000011BC  6000 000A                212              BRA         LET_G       *If not, process letter
000011C0                           213              
000011C0  0602 0030                214  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
000011C4  6000 000A                215              BRA         ADD_CHAR_G  *add to strings and continue
000011C8                           216              
000011C8  0602 0037                217  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
000011CC  6000 0002                218              BRA         ADD_CHAR_G  *add to strings and continue
000011D0                           219  
000011D0  18C2                     220  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
000011D2  5300                     221              SUBI.B      #$1,D0      *decrement counter
000011D4  0C00 0000                222              CMPI.B      #$0,D0      *Check if we're done            
000011D8  6ECE                     223              BGT         ISO_DIG_G    *If not, continue tranlation   
000011DA                           224              
000011DA  4E75                     225              RTS
000011DC                           226              
000011DC                           227  *-------------------H2A_B_ADDR-------------------------------            
000011DC  4280                     228  H2A_B_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
000011DE  4281                     229              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011E0  4282                     230              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E2  4283                     231              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E4  220D                     232              MOVE.L      A5,D1       *Copy address into D1
000011E6  5581                     233              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011E8  103C 0008                234              MOVE.B      #$8,D0      *Counter
000011EC  6000 0002                235              BRA         ISO_DIG_B   *Begin isolating chars
000011F0                           236              
000011F0  E999                     237  ISO_DIG_B   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F2                           238              
000011F2  2401                     239              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F4                           240              
000011F4  163C 001C                241              MOVE.B      #28,D3      *Shift left 28 times
000011F8  E7AA                     242              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011FA  E99A                     243              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FC                           244              
000011FC  0C02 0009                245              CMPI.B      #$9,D2      *Is it a number?
00001200  6F00 0006                246              BLE         NUM_B       *If it is, process number
00001204  6000 000A                247              BRA         LET_B       *If not, process letter
00001208                           248              
00001208  0602 0030                249  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
0000120C  6000 000A                250              BRA         ADD_CHAR_B  *add to strings and continue
00001210                           251              
00001210  0602 0037                252  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
00001214  6000 0002                253              BRA         ADD_CHAR_B  *add to strings and continue
00001218                           254  
00001218  16C2                     255  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to the good data string
0000121A  5300                     256              SUBI.B      #$1,D0      *decrement counter
0000121C  0C00 0000                257              CMPI.B      #$0,D0      *Check if we're done            
00001220  6ECE                     258              BGT         ISO_DIG_B    *If not, continue tranlation   
00001222                           259              
00001222  4E75                     260              RTS
00001224                           261              
00001224                           262  *-------------------H2A_B_OP--------------------------------
00001224  4280                     263  H2A_B_OP    CLR.L       D0          *Make sure D0 is empty (Counter)
00001226  4281                     264              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001228  4282                     265              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000122A  4283                     266              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000122C  3207                     267              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000122E  103C 0004                268              MOVE.B      #$4,D0      *Counter
00001232  6000 0002                269              BRA         ISODIG_BO   *Begin isolating chars
00001236                           270              
00001236  E959                     271  ISODIG_BO   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001238                           272              
00001238  2401                     273              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
0000123A                           274              
0000123A  163C 001C                275              MOVE.B      #28,D3      *Shift left 28 times
0000123E  E7AA                     276              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001240  E99A                     277              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001242                           278              
00001242  0C02 0009                279              CMPI.B      #$9,D2      *Is it a number?
00001246  6F00 0006                280              BLE         NUM_BO      *If it is, process number
0000124A  6000 000A                281              BRA         LET_BO      *If not, process letter
0000124E                           282  
0000124E  0602 0030                283  NUM_BO      ADDI.B      #$30,D2     *Make it an ascii number
00001252  6000 000A                284              BRA         ADD_CHAR_BO *add to strings and continue
00001256                           285              
00001256  0602 0037                286  LET_BO      ADDI.B      #$37,D2     *Make it an ascii letter
0000125A  6000 0002                287              BRA         ADD_CHAR_BO *add to strings and continue
0000125E                           288              
0000125E  16C2                     289  ADD_CHAR_BO MOVE.B      D2,(A3)+    *Add to bad data string
00001260  5300                     290              SUBI.B      #$1,D0      *decrement counter
00001262  0C00 0000                291              CMPI.B      #$0,D0      *Check if we're done            
00001266  6ECE                     292              BGT         ISODIG_BO  *If not, continue tranlation   
00001268                           293              
00001268  4E75                     294              RTS
0000126A                           295              
0000126A                           296  *-------------------PRINT_G---------------------------------
0000126A  18FC 0020                297  PRINT_G     MOVE.B      #' ',(A4)+
0000126E  16FC 0000                298              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
00001272  43F9 00002576            299              LEA         GOOD_STR,A1 *Load good data for printing
00001278  103C 000D                300              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000127C  4E4F                     301              TRAP        #15         *Display string
0000127E                           302            
0000127E  4E75                     303              RTS 
00001280                           304  
00001280                           305  *-------------------PRINT_B---------------------------------
00001280  18FC 0020                306  PRINT_B     MOVE.B      #' ',(A4)+
00001284  18FC 0000                307              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001288  43F9 00002536            308              LEA         BAD_STR,A1  *Load good data for printing
0000128E  103C 000D                309              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001292  4E4F                     310              TRAP        #15         *Display string
00001294                           311              
00001294  4E75                     312              RTS 
00001296                           313  *-------------------PRG_RESET-------------------------------
00001296  2E7C 01000000            314  PRG_RESET   MOVEA.L     #$01000000,A7   *Reset the stack pointer
0000129C                           315              
0000129C  207C 00000000            316              MOVEA.L     #$00000000,A0   *Clear Address Registers
000012A2  227C 00000000            317              MOVEA.L     #$00000000,A1
000012A8  247C 00000000            318              MOVEA.L     #$00000000,A2
000012AE  267C 00000000            319              MOVEA.L     #$00000000,A3
000012B4  287C 00000000            320              MOVEA.L     #$00000000,A4
000012BA  2A7C 00000000            321              MOVEA.L     #$00000000,A5
000012C0  2C7C 00000000            322              MOVEA.L     #$00000000,A6
000012C6                           323              
000012C6  4280                     324              CLR.L       D0              *Reset Data registers
000012C8  4281                     325              CLR.L       D1
000012CA  4282                     326              CLR.L       D2
000012CC  4283                     327              CLR.L       D3
000012CE  4284                     328              CLR.L       D4
000012D0  4285                     329              CLR.L       D5
000012D2  4286                     330              CLR.L       D6
000012D4  4287                     331              CLR.L       D7
000012D6                           332  
000012D6  103C 000B                333              MOVE.B      #11,D0          *Clear Screen
000012DA  323C FF00                334              MOVE.W      #$FF00,D1
000012DE  4E4F                     335              TRAP        #15
000012E0                           336              
000012E0  4281                     337              CLR.L       D1
000012E2                           338              
000012E2  4EF8 1000                339              JMP         START           *Restart the program
000012E6                           340  
000012E6                           341  *-------------------END_OPT---------------------------------
000012E6  43F9 0000249D            342  END_OPT     LEA         END_PGR,A1  *Display Ending messages
000012EC  4280                     343              CLR.L       D0          
000012EE  103C 000E                344              MOVE.B      #14,D0      
000012F2  4E4F                     345              TRAP        #15             
000012F4                           346              
000012F4  103C 0005                347              MOVE.B      #5,D0       *Single char trap task
000012F8  4E4F                     348              TRAP        #15         
000012FA                           349              
000012FA  B23C 0020                350              CMP.B       #$20,D1     *Check if SPACE key was pressed
000012FE  6796                     351              BEQ         PRG_RESET   *Decode another memory image if enter is pressed
00001300                           352              
00001300  B23C 001B                353              CMP.B       #$1B,D1     *Check if ESC key was pressed
00001304  6700 0004                354              BEQ         DONE        *End program
00001308                           355              
00001308  60DC                     356              BRA         END_OPT     *Else, loop (force space or esc)
0000130A                           357              
0000130A                           358  *-----------------------DONE--------------------------------
0000130A  103C 0009                359  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
0000130E  4E4F                     360              TRAP        #15         *Halt program, Trap#15 task 9
00001310                           361              
00001310                           362  *---------------Variables and Constants---------------------
00001310                           363              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
00001310                           364  
00001310                           365  
00001310  4282                     366  JMP_TBL     CLR.L       D2
00001312  3407                     367              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001314  4281                     368              CLR.L       D1
00001316  123C 000C                369              MOVE.B      #12,D1      *Moves 12 into D1
0000131A  E26A                     370              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000131C                           371                          
0000131C  B43C 0000                372  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00001320  6600 000A                373              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001324  4EB9 0000147A            374              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000132A  4E75                     375              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000132C                           376              
0000132C  B43C 0001                377  JMP_1       CMP.B       #$1,D2
00001330  6600 000A                378              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00001334  4EB9 0000168E            379              JSR         OPC_MOVEB   *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_MOVEB in OPCODE table.
0000133A  4E75                     380              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000133C                           381             
0000133C  B43C 0002                382  JMP_2       CMP.B       #$2,D2
00001340  6600 000A                383              BNE         JMP_3 
00001344  4EB9 000014A4            384              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000134A  4E75                     385              RTS
0000134C                           386              
0000134C  B43C 0003                387  JMP_3       CMP.B       #$3,D2
00001350  6600 000A                388              BNE         JMP_4
00001354  4EB9 000014C8            389              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
0000135A  4E75                     390              RTS
0000135C                           391           
0000135C  B43C 0004                392  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
00001360  6600 000A                393              BNE         JMP_5
00001364  4EB9 000014EC            394              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
0000136A  4E75                     395              RTS
0000136C                           396              
0000136C  B43C 0005                397  JMP_5       CMP.B       #$5,D2
00001370  6600 000A                398              BNE         JMP_6
00001374  4EB9 000016B2            399              JSR         OPC_ADDQ    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_ADDQ in OPCODE table.
0000137A  4E75                     400              RTS
0000137C                           401              
0000137C  B43C 0006                402  JMP_6       CMP.B       #$6,D2
00001380  6600 000A                403              BNE         JMP_7
00001384  4EB9 00001532            404              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
0000138A  4E75                     405              RTS
0000138C                           406              
0000138C  B43C 0007                407  JMP_7       CMP.B       #$7,D2
00001390  6600 000A                408              BNE         JMP_8
00001394  4EB9 000016DA            409              JSR         OPC_MOVEQ    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_MOVEQ in OPCODE table.
0000139A  4E75                     410              RTS
0000139C                           411              
0000139C  B43C 0008                412  JMP_8       CMP.B       #$8,D2
000013A0  6600 000A                413              BNE         JMP_9
000013A4  4EB9 00001556            414              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000013AA  4E75                     415              RTS
000013AC                           416              
000013AC  B43C 0009                417  JMP_9       CMP.B       #$9,D2
000013B0  6600 000A                418              BNE         JMP_A
000013B4  4EB9 000016F6            419              JSR         OPC_SUB    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000013BA  4E75                     420              RTS
000013BC                           421              
000013BC  B43C 000A                422  JMP_A       CMP.B       #$A,D2
000013C0  6600 0008                423              BNE         JMP_B
000013C4  4EB8 10EC                424              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
000013C8  4E75                     425              RTS
000013CA                           426              
000013CA  B43C 000B                427  JMP_B       CMP.B       #$B,D2
000013CE  6600 0008                428              BNE         JMP_C
000013D2  4EB8 10EC                429              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000013D6  4E75                     430              RTS
000013D8                           431              
000013D8  B43C 000C                432  JMP_C       CMP.B       #$C,D2
000013DC  6600 000A                433              BNE         JMP_D
000013E0  4EB9 0000157A            434              JSR         JMP_CX
000013E6                           435        *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000013E6  4E75                     436              RTS
000013E8                           437              
000013E8  B43C 000D                438  JMP_D       CMP.B       #$D,D2
000013EC  6600 000A                439              BNE         JMP_E   
000013F0  4EB9 0000159E            440              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000013F6  4E75                     441              RTS
000013F8                           442              
000013F8  B43C 000F                443  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
000013FC  6700 FCEE                444              BEQ         INVALID     *If first hex value is F, jump to INVALID
00001400  4EB9 00001602            445              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001406                           446              
00001406  4EF8 10EC                447              JMP         INVALID     *Got here? Must be invalid.
0000140A  4E75                     448              RTS
0000140C                           449   
0000140C  4282                     450  J_CLR4      CLR.L       D2                                
0000140E  3407                     451              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001410  4281                     452              CLR.L       D1
00001412  E94A                     453              LSL.W       #4,D2       *Clear the most sig hex digit
00001414  123C 000C                454              MOVE.B      #12,D1      *Moves 12 into D1
00001418  E26A                     455              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
0000141A  4E75                     456              RTS                     *Return back to JMP_Xn    
0000141C                           457              
0000141C  4282                     458  J_CLR3      CLR.L       D2          
0000141E  3407                     459              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001420  4281                     460              CLR.L       D1
00001422  E94A                     461              LSL.W       #4,D2       *Clear the most sig hex digit
00001424  123C 000D                462              MOVE.B      #13,D1      *Moves 13 into D1
00001428  E26A                     463              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000142A  4E75                     464              RTS                     *Return back to JMP_Xn  
0000142C                           465  
0000142C  4282                     466  J_CLR2  CLR.L       D2          
0000142E  3407                     467          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001430  4281                     468          CLR.L       D1
00001432  E14A                     469          LSL.W       #8,D2           *Clear the most sig 7 bits
00001434  123C 000E                470          MOVE.B      #14,D1          *Moves 16 into D1
00001438  E26A                     471          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000143A  4E75                     472          RTS     
0000143C                           473  
0000143C  4282                     474  J_CLR1  CLR.L       D2          
0000143E  3407                     475          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001440  4281                     476          CLR.L       D1
00001442  EF4A                     477          LSL.W       #7,D2           *Clear the most sig 7 bits
00001444  123C 000F                478          MOVE.B      #15,D1          *Moves 16 into D1
00001448  E26A                     479          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000144A  4E75                     480          RTS                         *Return back to JMP_Xn
0000144C                           481          
0000144C                           482          
0000144C  4282                     483  J_CLR_LEA   CLR.L       D2          
0000144E  3407                     484              MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001450  4281                     485              CLR.L       D1
00001452  EF4A                     486              LSL.W       #7,D2           *Clear the most sig 7 bits
00001454  123C 000D                487              MOVE.B      #13,D1          *Moves 16 into D1
00001458  E26A                     488              LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000145A  4E75                     489              RTS    
0000145C                           490              
0000145C                           491  
0000145C  4282                     492  J_CLR_MM    CLR.L       D2          
0000145E  3407                     493              MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001460  4281                     494              CLR.L       D1   
00001462  123C 000B                495              MOVE.B      #11,D1          *Moves 16 into D1
00001466  E26A                     496              LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001468  4E75                     497              RTS  
0000146A                           498       
0000146A  4282                     499  J_CLR_DM    CLR.L       D2          
0000146C  3407                     500              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000146E  4281                     501              CLR.L       D1
00001470  EF4A                     502              LSL.W       #7,D2       *Clear the most sig 7 bits
00001472  123C 000D                503              MOVE.B      #13,D1      *Moves 17 into D1
00001476  E26A                     504              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001478  4E75                     505              RTS                     *Return back to JMP_Xn     
0000147A                           506   
0000147A                           507  
0000147A                           508          
0000147A  4EB8 140C                509  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
0000147E  B43C 0004                510              CMP.B       #$4,D2      *Is the next hex digit 4?
00001482  6700 0010                511              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00001486  B43C 0006                512              CMP.B       #$6,D2      *Is the next hex digit 5?
0000148A  6700 0010                513              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
0000148E  4EB8 10EC                514              JSR         INVALID     *If neither, OPCODE is invalid
00001492  4E75                     515              RTS
00001494                           516  
00001494  4EB9 0000163E            517  J_SUBI      JSR         OPC_SUBI    *Jump to OPC_SUBI in OPCODE table
0000149A  4E75                     518              RTS
0000149C                           519              
0000149C  4EB9 00001666            520  J_ADDI      JSR         OPC_ADDI    *Jump to OPC_ADDI in OPCODE table
000014A2  4E75                     521              RTS              
000014A4                           522  
000014A4                           523  
000014A4  4EB8 146A                524  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014A8  B43C 0001                525              CMP.B       #$1,D2      *is the DEST MODE 1?
000014AC  6700 000A                526              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000014B0  4EB9 000014C0            527              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000014B6  4E75                     528              RTS
000014B8                           529  
000014B8  4EB9 0000177E            530  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000014BE  4E75                     531              RTS
000014C0                           532  
000014C0  4EB9 000017AA            533  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000014C6  4E75                     534              RTS                           
000014C8                           535              
000014C8  4EB8 146A                536  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014CC  B43C 0001                537              CMP.B       #$1,D2      *is the DEST MODE 1?
000014D0  6700 000A                538              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000014D4  4EB9 000014E4            539              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000014DA  4E75                     540              RTS
000014DC                           541  
000014DC  4EB9 000017D2            542  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000014E2  4E75                     543              RTS
000014E4                           544  
000014E4  4EB9 000017FE            545  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
000014EA  4E75                     546              RTS
000014EC  4EB8 140C                547  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
000014F0  B43C 000E                548              CMP.B       #$E,D2      *Is the next hex digit E?
000014F4  6700 0024                549              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
000014F8  4EB8 143C                550              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
000014FC  4EB8 144C                551              JSR         J_CLR_LEA
00001500  B43C 0007                552              CMP.B       #7,D2       *Is the last bit 7?
00001504  6700 001C                553              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
00001508  4EB8 145C                554              JSR         J_CLR_MM
0000150C  B43C 0009                555              CMP.B       #9,D2       *Is the last bit 0?
00001510  6700 0018                556              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
00001514  4EB8 10EC                557              JSR         INVALID     *If none of the above, OPCODE is invalid
00001518  4E75                     558              RTS                                         
0000151A                           559              
0000151A  4EB9 00001606            560  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001520  4E75                     561              RTS
00001522                           562              
00001522  4EB9 00001714            563  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
00001528  4E75                     564              RTS
0000152A                           565              
0000152A  4EB9 00001736            566  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001530  4E75                     567              RTS
00001532                           568              
00001532  4EB8 140C                569  JMP_6X      JSR         J_CLR4       *Isolate next hex digit 
00001536  B43C 0000                570              CMP.B       #0,D2        *Is the next hex digit 0?
0000153A  6700 000A                571              BEQ         J_BRA        *Instruction is determined to be BRA. Jump to intermediate OPCODE table jump
0000153E  4EB9 0000154E            572              JSR         J_Bcc        *Otherwise, Instruction is determined to be some form of Bcc. Jump to intermediate OPCODE table jump
00001544  4E75                     573              RTS
00001546                           574              
00001546  4EB9 00001826            575  J_BRA       JSR         OPC_BRA      *Jump to OPC_BRA in the OPCODE table  
0000154C                           576  
0000154C  4E75                     577              RTS
0000154E                           578  
0000154E  4EB9 00001842            579  J_Bcc       JSR         OPC_Bcc      *Jump to OPC_Bcc in the OPCODE table  
00001554                           580  
00001554  4E75                     581              RTS
00001556                           582              
00001556  4EB8 146A                583  JMP_8X      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
0000155A  B43C 0003                584              CMP.B       #3,D2       *Are the bits equivalent to $3?
0000155E  6700 000A                585              BEQ         J_DIVU      *Instruction is determined to be DIVU. Jump to intermediate OPCODE table jump
00001562  4EB9 00001572            586              JSR         J_OR        *Otherwise, Instruction is determined to be OR. Jump to intermediate OPCODE table jump
00001568  4E75                     587              RTS
0000156A                           588  
0000156A  4EB9 0000184E            589  J_DIVU      JSR         OPC_DIVU    *Jump to OPC_DIVU in the OPCODE table  
00001570  4E75                     590              RTS
00001572                           591              
00001572  4EB9 00001874            592  J_OR        JSR         OPC_OR      *Jump to OPC_OR in the OPCODE table  
00001578  4E75                     593              RTS
0000157A                           594  
0000157A  4EB8 146A                595  JMP_CX      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
0000157E  B43C 0007                596              CMP.B       #7,D2       *Are the bits equivalent to $7?
00001582  6700 000A                597              BEQ         J_MULS      *Instruction is determined to be MULS. Jump to intermediate OPCODE table jump
00001586  4EB9 00001596            598              JSR         J_AND       *Otherwise, Instruction is determined to be AND. Jump to intermediate OPCODE table jump
0000158C  4E75                     599              RTS
0000158E                           600  
0000158E  4EB9 0000188E            601  J_MULS      JSR         OPC_MULS    *Jump to OPC_MULS in the OPCODE table  
00001594  4E75                     602              RTS
00001596                           603              
00001596  4EB9 000018B4            604  J_AND       JSR         OPC_AND     *Jump to OPC_AND in the OPCODE table  
0000159C  4E75                     605              RTS
0000159E                           606  
0000159E  4EB8 146A                607  JMP_DX      JSR         J_CLR_DM    *Isolate OPMODE bits to determine if ADD or ADDA
000015A2  4284                     608              CLR.L       D4          *For adding size (easy to do it here).
000015A4  183C 0001                609              MOVE.B      #1,D4       *Set size to WORD
000015A8  B43C 0003                610              CMP.B       #3,D2       *Is it Word ADDA?
000015AC  6700 0044                611              BEQ         OP_ADDA
000015B0  183C 0002                612              MOVE.B      #2,D4       *set size to LONG
000015B4  B43C 0007                613              CMP.B       #7,D2       *is it Long ADDA?
000015B8  6700 0038                614              BEQ         OP_ADDA
000015BC                           615              
000015BC  4284                     616              CLR.L       D4          *Not ADDA? Clear the manual size sets
000015BE                           617              
000015BE  B83C 0000                618              CMP.B       #0,D4       Is it ADD?
000015C2  6700 0036                619              BEQ         OP_ADD
000015C6  B83C 0001                620              CMP.B       #1,D4       
000015CA  6700 002E                621              BEQ         OP_ADD
000015CE  B83C 0002                622              CMP.B       #2,D4       
000015D2  6700 0026                623              BEQ         OP_ADD
000015D6  B83C 0004                624              CMP.B       #4,D4 
000015DA  6700 001E                625              BEQ         OP_ADD
000015DE  B83C 0005                626              CMP.B       #5,D4     
000015E2  6700 0016                627              BEQ         OP_ADD
000015E6  B83C 0006                628              CMP.B       #6,D4     
000015EA  6700 000E                629              BEQ         OP_ADD       
000015EE                           630           
000015EE  6000 FAFC                631              BRA         INVALID     *Got here, must be invalid data.    
000015F2                           632              
000015F2  4EB9 000018D2            633  OP_ADDA     JSR         OPC_ADDA
000015F8  4E75                     634              RTS
000015FA                           635              
000015FA  4EB9 000018F4            636  OP_ADD      JSR         OPC_ADD
00001600  4E75                     637              RTS
00001602                           638  
00001602                           639  
00001602  4EF8 10EC                640  JMP_EX      JMP         INVALID     
00001606                           641  
00001606                           642     
00001606  BE7C 4E71                643  JMP_47X     CMP.W       #$4E71,D7    *Is it NOP?
0000160A  6700 001A                644              BEQ         O_NOP
0000160E  BE7C 4E75                645              CMP.W       #$4E75,D7       *Is it RTS?
00001612  6700 001A                646              BEQ         O_RTS
00001616  4EB8 142C                647              JSR         J_CLR2       *Isolate the 6th and 7th bit
0000161A  B43C 0002                648              CMP.B       #2,D2        *Is it JSR?
0000161E  6700 0016                649              BEQ         O_JSR
00001622  4EF8 10EC                650              JMP         INVALID      *Got here? Must be invalid data.
00001626                           651  
00001626  4EB9 0000192E            652  O_NOP       JSR         OPC_NOP
0000162C  4E75                     653              RTS
0000162E                           654  
0000162E  4EB9 0000193C            655  O_RTS       JSR         OPC_RTS
00001634  4E75                     656              RTS
00001636                           657  
00001636  4EB9 00001912            658  O_JSR       JSR         OPC_JSR
0000163C  4E75                     659              RTS
0000163E                           660           
0000163E                           661  
0000163E                           662  
0000163E  18FC 0053                663  OPC_SUBI    MOVE.B      #'S',(A4)+
00001642  18FC 0055                664              MOVE.B      #'U',(A4)+
00001646  18FC 0042                665              MOVE.B      #'B',(A4)+
0000164A  18FC 0049                666              MOVE.B      #'I',(A4)+
0000164E  18FC 002E                667              MOVE.B      #'.',(A4)+
00001652                           668              
00001652  4EB9 00001B76            669              JSR         GET_SIZE_2  *Get 2 bit size code
00001658  4EB9 00001B24            670              JSR         ADD_SIZE    *Add the size character based on size code
0000165E                           671              
0000165E  4EB9 00001C8A            672              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
00001664                           673              
00001664  4E75                     674              RTS
00001666                           675  
00001666  18FC 0041                676  OPC_ADDI    MOVE.B      #'A',(A4)+
0000166A  18FC 0044                677              MOVE.B      #'D',(A4)+
0000166E  18FC 0044                678              MOVE.B      #'D',(A4)+
00001672  18FC 0049                679              MOVE.B      #'I',(A4)+
00001676  18FC 002E                680              MOVE.B      #'.',(A4)+
0000167A                           681              
0000167A  4EB9 00001B76            682              JSR         GET_SIZE_2  *Get 2 bit size code
00001680  4EB9 00001B24            683              JSR         ADD_SIZE    *Add the size character based on size code
00001686                           684              
00001686  4EB9 00001C8A            685              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
0000168C                           686              
0000168C  4E75                     687              RTS
0000168E                           688  
0000168E  18FC 004D                689  OPC_MOVEB   MOVE.B      #'M',(A4)+
00001692  18FC 004F                690              MOVE.B      #'O',(A4)+
00001696  18FC 0056                691              MOVE.B      #'V',(A4)+
0000169A  18FC 0045                692              MOVE.B      #'E',(A4)+
0000169E  18FC 002E                693              MOVE.B      #'.',(A4)+
000016A2                           694  
000016A2                           695  
000016A2  4284                     696              CLR.L       D4          *Manually set size to byte (D4 = 0)
000016A4  4EB9 00001B24            697              JSR         ADD_SIZE    *Add size characters
000016AA                           698              
000016AA  4EB9 00001D7C            699              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000016B0                           700              
000016B0  4E75                     701              RTS
000016B2                           702  
000016B2  18FC 0041                703  OPC_ADDQ    MOVE.B      #'A',(A4)+
000016B6  18FC 0044                704              MOVE.B      #'D',(A4)+
000016BA  18FC 0044                705              MOVE.B      #'D',(A4)+
000016BE  18FC 0051                706              MOVE.B      #'Q',(A4)+
000016C2  18FC 002E                707              MOVE.B      #'.',(A4)+
000016C6                           708  
000016C6  4EB9 00001B76            709              JSR         GET_SIZE_2   *Get size code (placed in D4)
000016CC  4EB9 00001B24            710              JSR         ADD_SIZE     *Add size character to string (B/W/L)
000016D2                           711              
000016D2  4EB9 00001D22            712              JSR         ADDQ_EA      *Start the EA/operand decode logic
000016D8                           713   
000016D8  4E75                     714              RTS
000016DA                           715  
000016DA  18FC 004D                716  OPC_MOVEQ   MOVE.B      #'M',(A4)+
000016DE  18FC 004F                717              MOVE.B      #'O',(A4)+
000016E2  18FC 0056                718              MOVE.B      #'V',(A4)+
000016E6  18FC 0045                719              MOVE.B      #'E',(A4)+
000016EA  18FC 0051                720              MOVE.B      #'Q',(A4)+
000016EE                           721              
000016EE  4EB9 00001CEE            722              JSR         MOVEQ_EA     *Start the EA/opderand decode logic for moveq
000016F4                           723            
000016F4  4E75                     724              RTS
000016F6                           725  
000016F6  18FC 0053                726  OPC_SUB     MOVE.B      #'S',(A4)+
000016FA  18FC 0055                727              MOVE.B      #'U',(A4)+
000016FE  18FC 0042                728              MOVE.B      #'B',(A4)+
00001702  18FC 002E                729              MOVE.B      #'.',(A4)+
00001706                           730  
00001706  4EB9 00001B66            731              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
0000170C                           732              
0000170C  4EB9 00001B9C            733              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
00001712                           734  
00001712  4E75                     735              RTS
00001714                           736  
00001714  18FC 004C                737  OPC_LEA     MOVE.B      #'L',(A4)+
00001718  18FC 0045                738              MOVE.B      #'E',(A4)+
0000171C  18FC 0041                739              MOVE.B      #'A',(A4)+
00001720  18FC 0020                740              MOVE.B      #' ',(A4)+
00001724  18FC 0020                741              MOVE.B      #' ',(A4)+
00001728                           742              
00001728  4284                     743              CLR.L       D4          *Manually set size to byte (D4 = 0)
0000172A  183C 0002                744              MOVE.B      #2,D4       *Manually set size to long.
0000172E                           745              
0000172E  4EB9 00001C5E            746              JSR         EASRC_ADES
00001734                           747              
00001734  4E75                     748              RTS
00001736                           749              
00001736  18FC 004D                750  OPC_MOVEM   MOVE.B      #'M',(A4)+
0000173A  18FC 004F                751              MOVE.B      #'O',(A4)+
0000173E  18FC 0056                752              MOVE.B      #'V',(A4)+
00001742  18FC 0045                753              MOVE.B      #'E',(A4)+
00001746  18FC 004D                754              MOVE.B      #'M',(A4)+
0000174A  18FC 002E                755              MOVE.B      #'.',(A4)+
0000174E                           756              
0000174E  4EB9 00001B86            757              JSR         GET_SIZE_1
00001754                           758              
00001754  B83C 0000                759              CMP.B       #0,D4       *Change size code so it matches standard formatting
00001758  6700 000A                760              BEQ         MM_WORD
0000175C  B83C 0001                761              CMP.B       #1,D4
00001760  6700 000A                762              BEQ         MM_LONG
00001764                           763  
00001764  183C 0001                764  MM_WORD     MOVE.B      #1,D4
00001768  6000 0006                765              BRA         MM_ADD_S
0000176C                           766  
0000176C  183C 0002                767  MM_LONG     MOVE.B      #2,D4
00001770                           768         
00001770  4EB9 00001B24            769  MM_ADD_S    JSR         ADD_SIZE
00001776  4EB9 00001C9C            770              JSR         MM_OP_ORD
0000177C                           771              
0000177C  4E75                     772              RTS
0000177E                           773  
0000177E                           774  
0000177E  18FC 004D                775  OPC_MOVEAL  MOVE.B      #'M',(A4)+
00001782  18FC 004F                776              MOVE.B      #'O',(A4)+
00001786  18FC 0056                777              MOVE.B      #'V',(A4)+
0000178A  18FC 0045                778              MOVE.B      #'E',(A4)+
0000178E  18FC 0041                779              MOVE.B      #'A',(A4)+
00001792  18FC 002E                780              MOVE.B      #'.',(A4)+
00001796                           781  
00001796  4284                     782              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001798  183C 0002                783              MOVE.B      #2,D4       *Set size code to long
0000179C  4EB9 00001B24            784              JSR         ADD_SIZE    *Add size characters
000017A2                           785              
000017A2  4EB9 00001D7C            786              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017A8  4E75                     787              RTS
000017AA                           788  
000017AA                           789  
000017AA  18FC 004D                790  OPC_MOVEL   MOVE.B      #'M',(A4)+
000017AE  18FC 004F                791              MOVE.B      #'O',(A4)+
000017B2  18FC 0056                792              MOVE.B      #'V',(A4)+
000017B6  18FC 0045                793              MOVE.B      #'E',(A4)+
000017BA  18FC 002E                794              MOVE.B      #'.',(A4)+
000017BE                           795  
000017BE  4284                     796              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017C0  183C 0002                797              MOVE.B      #2,D4       *Set size code to long
000017C4  4EB9 00001B24            798              JSR         ADD_SIZE    *Add size characters
000017CA                           799              
000017CA  4EB9 00001D7C            800              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017D0  4E75                     801              RTS
000017D2                           802  
000017D2  18FC 004D                803  OPC_MOVEAW  MOVE.B      #'M',(A4)+
000017D6  18FC 004F                804              MOVE.B      #'O',(A4)+
000017DA  18FC 0056                805              MOVE.B      #'V',(A4)+
000017DE  18FC 0045                806              MOVE.B      #'E',(A4)+
000017E2  18FC 0041                807              MOVE.B      #'A',(A4)+
000017E6  18FC 002E                808              MOVE.B      #'.',(A4)+
000017EA                           809  
000017EA  4284                     810              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017EC  183C 0001                811              MOVE.B      #1,D4       *Set size code to word
000017F0  4EB9 00001B24            812              JSR         ADD_SIZE    *Add size characters
000017F6                           813              
000017F6  4EB9 00001D7C            814              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017FC  4E75                     815              RTS
000017FE                           816  
000017FE                           817  
000017FE  18FC 004D                818  OPC_MOVEW   MOVE.B      #'M',(A4)+
00001802  18FC 004F                819              MOVE.B      #'O',(A4)+
00001806  18FC 0056                820              MOVE.B      #'V',(A4)+
0000180A  18FC 0045                821              MOVE.B      #'E',(A4)+
0000180E  18FC 002E                822              MOVE.B      #'.',(A4)+
00001812                           823  
00001812  4284                     824              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001814  183C 0001                825              MOVE.B      #1,D4       *Set size code to word
00001818  4EB9 00001B24            826              JSR         ADD_SIZE    *Add size characters
0000181E                           827              
0000181E  4EB9 00001D7C            828              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001824  4E75                     829              RTS
00001826                           830  
00001826                           831  
00001826  18FC 0042                832  OPC_BRA     MOVE.B      #'B',(A4)+
0000182A  18FC 0052                833              MOVE.B      #'R',(A4)+
0000182E  18FC 0041                834              MOVE.B      #'A',(A4)+
00001832  18FC 0020                835              MOVE.B      #' ',(A4)+
00001836  18FC 0020                836              MOVE.B      #' ',(A4)+
0000183A                           837              
0000183A  4EB9 00001F00            838              JSR         ABW       *Grab the next word value (BRA bug)
00001840                           839                          
00001840  4E75                     840              RTS
00001842                           841  
00001842  18FC 0042                842  OPC_Bcc     MOVE.B      #'B',(A4)+
00001846                           843              *BCC bug, does not use 8bit displacment, but is next word value (ABSW)
00001846  4EB9 0000194A            844              JSR         BCC_CODE    *Get condition code and start decoding
0000184C                           845              
0000184C  4E75                     846              RTS
0000184E                           847  
0000184E  18FC 0044                848  OPC_DIVU    MOVE.B      #'D',(A4)+
00001852  18FC 0049                849              MOVE.B      #'I',(A4)+
00001856  18FC 0056                850              MOVE.B      #'V',(A4)+
0000185A  18FC 0055                851              MOVE.B      #'U',(A4)+
0000185E  18FC 0020                852              MOVE.B      #' ',(A4)+
00001862  18FC 0020                853              MOVE.B      #' ',(A4)+
00001866                           854              
00001866  4284                     855              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001868  183C 0001                856              MOVE.B      #1,D4       *Set size code to word
0000186C                           857              
0000186C  4EB9 00001C48            858              JSR         EASRC_DDES  *Start operand <ea>,Dn
00001872                           859              
00001872                           860              
00001872  4E75                     861              RTS
00001874                           862  
00001874  18FC 004F                863  OPC_OR      MOVE.B      #'O',(A4)+
00001878  18FC 0052                864              MOVE.B      #'R',(A4)+
0000187C  18FC 002E                865              MOVE.B      #'.',(A4)+
00001880                           866  
00001880  4EB9 00001B66            867              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001886                           868              
00001886  4EB9 00001B9C            869              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
0000188C                           870  
0000188C  4E75                     871              RTS
0000188E                           872  
0000188E  18FC 004D                873  OPC_MULS    MOVE.B      #'M',(A4)+
00001892  18FC 0055                874              MOVE.B      #'U',(A4)+
00001896  18FC 004C                875              MOVE.B      #'L',(A4)+
0000189A  18FC 0053                876              MOVE.B      #'S',(A4)+
0000189E  18FC 0020                877              MOVE.B      #' ',(A4)+
000018A2  18FC 0020                878              MOVE.B      #' ',(A4)+
000018A6                           879              
000018A6  4284                     880              CLR.L       D4          *Manually set size to byte (D4 = 0)
000018A8  183C 0001                881              MOVE.B      #1,D4       *Set size code to word
000018AC                           882              
000018AC  4EB9 00001C48            883              JSR         EASRC_DDES  *Jump to <ea>,Dn
000018B2                           884              
000018B2  4E75                     885              RTS
000018B4                           886  
000018B4  18FC 0041                887  OPC_AND     MOVE.B      #'A',(A4)+
000018B8  18FC 004E                888              MOVE.B      #'N',(A4)+
000018BC  18FC 0044                889              MOVE.B      #'D',(A4)+
000018C0  18FC 002E                890              MOVE.B      #'.',(A4)+
000018C4                           891  
000018C4  4EB9 00001B66            892              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000018CA                           893              
000018CA  4EB9 00001B9C            894              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
000018D0                           895  
000018D0  4E75                     896              RTS
000018D2                           897              
000018D2  18FC 0041                898  OPC_ADDA    MOVE.B      #'A',(A4)+
000018D6  18FC 0044                899              MOVE.B      #'D',(A4)+
000018DA  18FC 0044                900              MOVE.B      #'D',(A4)+
000018DE  18FC 0041                901              MOVE.B      #'A',(A4)+
000018E2  18FC 002E                902              MOVE.B      #'.',(A4)+
000018E6                           903              
000018E6  4EB9 00001B24            904              JSR         ADD_SIZE    *Size should already be in D4 (special case for ADDA)
000018EC                           905              
000018EC  4EB9 00001C5E            906              JSR         EASRC_ADES  *Start operand decode for <ea>,An format
000018F2                           907              
000018F2  4E75                     908              RTS
000018F4                           909  
000018F4  18FC 0041                910  OPC_ADD     MOVE.B      #'A',(A4)+
000018F8  18FC 0044                911              MOVE.B      #'D',(A4)+
000018FC  18FC 0044                912              MOVE.B      #'D',(A4)+
00001900  18FC 002E                913              MOVE.B      #'.',(A4)+
00001904                           914  
00001904  4EB9 00001B66            915              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
0000190A                           916              
0000190A  4EB9 00001B9C            917              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
00001910                           918  
00001910  4E75                     919              RTS
00001912                           920  
00001912  18FC 004A                921  OPC_JSR     MOVE.B      #'J',(A4)+
00001916  18FC 0053                922              MOVE.B      #'S',(A4)+
0000191A  18FC 0052                923              MOVE.B      #'R',(A4)+
0000191E  18FC 0020                924              MOVE.B      #' ',(A4)+
00001922  18FC 0020                925              MOVE.B      #' ',(A4)+
00001926  4EB9 00001D5A            926              JSR         GEN_EA_CODE *Get EA code
0000192C                           927              
0000192C  4E75                     928              RTS
0000192E                           929  
0000192E  18FC 004E                930  OPC_NOP     MOVE.B      #'N',(A4)+
00001932  18FC 004F                931              MOVE.B      #'O',(A4)+
00001936  18FC 0050                932              MOVE.B      #'P',(A4)+
0000193A                           933              
0000193A  4E75                     934              RTS
0000193C                           935  
0000193C  18FC 0052                936  OPC_RTS     MOVE.B      #'R',(A4)+
00001940  18FC 0054                937              MOVE.B      #'T',(A4)+
00001944  18FC 0053                938              MOVE.B      #'S',(A4)+
00001948                           939              
00001948  4E75                     940              RTS
0000194A                           941  
0000194A                           942  
0000194A  4283                     943  BCC_CODE    CLR.L       D3          *Make sure D3 is empty to hold condition code
0000194C  3607                     944              MOVE.W      D7,D3       *Move in original address to be shifted
0000194E  E94B                     945              LSL.W       #4,D3
00001950  4282                     946              CLR.L       D2
00001952  143C 000C                947              MOVE.B      #12,D2
00001956  E46B                     948              LSR.W       D2,D3
00001958  4EB9 00001960            949              JSR         BCC_TABLE   *Jump to BCC table now that condition code is in D3
0000195E  4E75                     950              RTS
00001960                           951  
00001960  B63C 0002                952  BCC_TABLE   CMP.B       #$2,D3      *Is it BHI?
00001964  6700 006E                953              BEQ         BCC_HI
00001968  B63C 0003                954              CMP.B       #$3,D3      *Is it BLS?
0000196C  6700 007E                955              BEQ         BCC_LS      
00001970  B63C 0004                956              CMP.B       #$4,D3      *Is it BCC?
00001974  6700 008E                957              BEQ         BCC_CC
00001978  B63C 0005                958              CMP.B       #$5,D3      *Is it BCS?
0000197C  6700 009E                959              BEQ         BCC_CS
00001980  B63C 0006                960              CMP.B       #$6,D3      *Is it BNE?
00001984  6700 00AE                961              BEQ         BCC_NE
00001988  B63C 0007                962              CMP.B       #$7,D3      *Is it BEQ?
0000198C  6700 00BE                963              BEQ         BCC_EQ
00001990  B63C 0008                964              CMP.B       #$8,D3      *Is it BVC?
00001994  6700 00CE                965              BEQ         BCC_VC      
00001998  B63C 0009                966              CMP.B       #$9,D3      *Is it BVS?
0000199C  6700 00DE                967              BEQ         BCC_VS
000019A0  B63C 000A                968              CMP.B       #$A,D3      *Is it BPL?
000019A4  6700 00EE                969              BEQ         BCC_PL
000019A8  B63C 000B                970              CMP.B       #$B,D3      *Is it BMI?
000019AC  6700 00FE                971              BEQ         BCC_MI
000019B0  B63C 000C                972              CMP.B       #$C,D3      *Is it BGE?
000019B4  6700 010E                973              BEQ         BCC_GE
000019B8  B63C 000D                974              CMP.B       #$D,D3      *Is it BLT?
000019BC  6700 011E                975              BEQ         BCC_LT
000019C0  B63C 000E                976              CMP.B       #$E,D3      *Is it BGT?
000019C4  6700 012E                977              BEQ         BCC_GT      
000019C8  B63C 000F                978              CMP.B       #$F,D3      *Is it BLE?
000019CC  6700 013E                979              BEQ         BCC_LE
000019D0  4EF8 10EC                980              JMP         INVALID     *Got here? Something is wrong.
000019D4                           981  
000019D4  18FC 0048                982  BCC_HI      MOVE.B      #'H',(A4)+
000019D8  18FC 0049                983              MOVE.B      #'I',(A4)+
000019DC  18FC 0020                984              MOVE.B      #' ',(A4)+
000019E0  18FC 0020                985              MOVE.B      #' ',(A4)+
000019E4  4EB9 00001F00            986              JSR         ABW         *Add absolute word in next word address.
000019EA  4E75                     987              RTS
000019EC                           988  
000019EC  18FC 004C                989  BCC_LS      MOVE.B      #'L',(A4)+
000019F0  18FC 0053                990              MOVE.B      #'S',(A4)+
000019F4  18FC 0020                991              MOVE.B      #' ',(A4)+
000019F8  18FC 0020                992              MOVE.B      #' ',(A4)+
000019FC  4EB9 00001F00            993              JSR         ABW         *Add absolute word in next word address.
00001A02  4E75                     994              RTS
00001A04                           995  
00001A04  18FC 0043                996  BCC_CC      MOVE.B      #'C',(A4)+
00001A08  18FC 0043                997              MOVE.B      #'C',(A4)+
00001A0C  18FC 0020                998              MOVE.B      #' ',(A4)+
00001A10  18FC 0020                999              MOVE.B      #' ',(A4)+
00001A14  4EB9 00001F00           1000              JSR         ABW         *Add absolute word in next word address.
00001A1A  4E75                    1001              RTS
00001A1C                          1002              
00001A1C  18FC 0043               1003  BCC_CS      MOVE.B      #'C',(A4)+
00001A20  18FC 0053               1004              MOVE.B      #'S',(A4)+
00001A24  18FC 0020               1005              MOVE.B      #' ',(A4)+
00001A28  18FC 0020               1006              MOVE.B      #' ',(A4)+
00001A2C  4EB9 00001F00           1007              JSR         ABW         *Add absolute word in next word address.
00001A32  4E75                    1008              RTS
00001A34                          1009              
00001A34  18FC 004E               1010  BCC_NE      MOVE.B      #'N',(A4)+
00001A38  18FC 0045               1011              MOVE.B      #'E',(A4)+
00001A3C  18FC 0020               1012              MOVE.B      #' ',(A4)+
00001A40  18FC 0020               1013              MOVE.B      #' ',(A4)+
00001A44  4EB9 00001F00           1014              JSR         ABW         *Add absolute word in next word address.
00001A4A  4E75                    1015              RTS
00001A4C                          1016              
00001A4C  18FC 0045               1017  BCC_EQ      MOVE.B      #'E',(A4)+
00001A50  18FC 0051               1018              MOVE.B      #'Q',(A4)+
00001A54  18FC 0020               1019              MOVE.B      #' ',(A4)+
00001A58  18FC 0020               1020              MOVE.B      #' ',(A4)+
00001A5C  4EB9 00001F00           1021              JSR         ABW         *Add absolute word in next word address.
00001A62  4E75                    1022              RTS
00001A64                          1023              
00001A64  18FC 0056               1024  BCC_VC      MOVE.B      #'V',(A4)+
00001A68  18FC 0043               1025              MOVE.B      #'C',(A4)+
00001A6C  18FC 0020               1026              MOVE.B      #' ',(A4)+
00001A70  18FC 0020               1027              MOVE.B      #' ',(A4)+
00001A74  4EB9 00001F00           1028              JSR         ABW         *Add absolute word in next word address.
00001A7A  4E75                    1029              RTS
00001A7C                          1030  
00001A7C  18FC 0056               1031  BCC_VS      MOVE.B      #'V',(A4)+
00001A80  18FC 0053               1032              MOVE.B      #'S',(A4)+
00001A84  18FC 0020               1033              MOVE.B      #' ',(A4)+
00001A88  18FC 0020               1034              MOVE.B      #' ',(A4)+
00001A8C  4EB9 00001F00           1035              JSR         ABW         *Add absolute word in next word address.
00001A92  4E75                    1036              RTS
00001A94                          1037              
00001A94  18FC 0050               1038  BCC_PL      MOVE.B      #'P',(A4)+
00001A98  18FC 004C               1039              MOVE.B      #'L',(A4)+
00001A9C  18FC 0020               1040              MOVE.B      #' ',(A4)+
00001AA0  18FC 0020               1041              MOVE.B      #' ',(A4)+
00001AA4  4EB9 00001F00           1042              JSR         ABW         *Add absolute word in next word address.
00001AAA  4E75                    1043              RTS
00001AAC                          1044              
00001AAC  18FC 004D               1045  BCC_MI      MOVE.B      #'M',(A4)+
00001AB0  18FC 0049               1046              MOVE.B      #'I',(A4)+
00001AB4  18FC 0020               1047              MOVE.B      #' ',(A4)+
00001AB8  18FC 0020               1048              MOVE.B      #' ',(A4)+
00001ABC  4EB9 00001F00           1049              JSR         ABW         *Add absolute word in next word address.
00001AC2  4E75                    1050              RTS
00001AC4                          1051              
00001AC4  18FC 0047               1052  BCC_GE      MOVE.B      #'G',(A4)+
00001AC8  18FC 0045               1053              MOVE.B      #'E',(A4)+
00001ACC  18FC 0020               1054              MOVE.B      #' ',(A4)+
00001AD0  18FC 0020               1055              MOVE.B      #' ',(A4)+
00001AD4  4EB9 00001F00           1056              JSR         ABW         *Add absolute word in next word address.
00001ADA  4E75                    1057              RTS
00001ADC                          1058              
00001ADC  18FC 004C               1059  BCC_LT      MOVE.B      #'L',(A4)+
00001AE0  18FC 0054               1060              MOVE.B      #'T',(A4)+
00001AE4  18FC 0020               1061              MOVE.B      #' ',(A4)+
00001AE8  18FC 0020               1062              MOVE.B      #' ',(A4)+
00001AEC  4EB9 00001F00           1063              JSR         ABW         *Add absolute word in next word address.
00001AF2  4E75                    1064              RTS
00001AF4                          1065              
00001AF4  18FC 0047               1066  BCC_GT      MOVE.B      #'G',(A4)+
00001AF8  18FC 0054               1067              MOVE.B      #'T',(A4)+
00001AFC  18FC 0020               1068              MOVE.B      #' ',(A4)+
00001B00  18FC 0020               1069              MOVE.B      #' ',(A4)+
00001B04  4EB9 00001F00           1070              JSR         ABW         *Add absolute word in next word address.
00001B0A  4E75                    1071              RTS
00001B0C                          1072              
00001B0C  18FC 004C               1073  BCC_LE      MOVE.B      #'L',(A4)+
00001B10  18FC 0045               1074              MOVE.B      #'E',(A4)+
00001B14  18FC 0020               1075              MOVE.B      #' ',(A4)+
00001B18  18FC 0020               1076              MOVE.B      #' ',(A4)+
00001B1C  4EB9 00001F00           1077              JSR         ABW         *Add absolute word in next word address.
00001B22  4E75                    1078              RTS
00001B24                          1079  
00001B24                          1080  
00001B24  B83C 0000               1081  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn/an
00001B28  6700 0012               1082              BEQ         B_SIZE
00001B2C  B83C 0001               1083              CMP.B       #1,D4       *Is it a W, <ea>,dn/an
00001B30  6700 0018               1084              BEQ         W_SIZE
00001B34  B83C 0002               1085              CMP.B       #2,D4       *Is it a L, <ea>,dn/an
00001B38  6700 001E               1086              BEQ         L_SIZE 
00001B3C                          1087              
00001B3C  18FC 0042               1088  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
00001B40  18FC 0020               1089              MOVE.B      #' ',(A4)+
00001B44  18FC 0020               1090              MOVE.B      #' ',(A4)+
00001B48  4E75                    1091              RTS
00001B4A                          1092  
00001B4A  18FC 0057               1093  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
00001B4E  18FC 0020               1094              MOVE.B      #' ',(A4)+
00001B52  18FC 0020               1095              MOVE.B      #' ',(A4)+
00001B56  4E75                    1096              RTS
00001B58                          1097  
00001B58  18FC 004C               1098  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
00001B5C  18FC 0020               1099              MOVE.B      #' ',(A4)+
00001B60  18FC 0020               1100              MOVE.B      #' ',(A4)+
00001B64  4E75                    1101              RTS
00001B66                          1102  
00001B66  4284                    1103  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B68  3807                    1104              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B6A  EF4C                    1105              LSL.W       #7,D4       *Clear more significant bits
00001B6C  4283                    1106              CLR.L       D3          *Make sure D3 is clear for shifting
00001B6E  163C 000D               1107              MOVE.B      #13,D3      *Shifting 13 times
00001B72  E66C                    1108              LSR.W       D3,D4       *Move size bits to LSB position
00001B74  4E75                    1109              RTS
00001B76                          1110  
00001B76  4284                    1111  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B78  3807                    1112              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B7A  E14C                    1113              LSL.W       #8,D4       *Clear more significant bits
00001B7C  4283                    1114              CLR.L       D3          *Make sure D3 is clear for shifting
00001B7E  163C 000E               1115              MOVE.B      #14,D3      *Shifting 14 times
00001B82  E66C                    1116              LSR.W       D3,D4       *Move size bits to LSB position
00001B84  4E75                    1117              RTS
00001B86                          1118  
00001B86  4284                    1119  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B88  3807                    1120              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B8A  4283                    1121              CLR.L       D3          *Make sure D3 is clear for shifting
00001B8C  163C 0009               1122              MOVE.B      #9,D3       *Shift 9 times to the left
00001B90  E76C                    1123              LSL.W       D3,D4       *Clear more significant bits
00001B92  4283                    1124              CLR.L       D3          *Make sure D3 is clear for shifting
00001B94  163C 000F               1125              MOVE.B      #15,D3      *Shifting 15 times
00001B98  E66C                    1126              LSR.W       D3,D4       *Move size bits to LSB position
00001B9A  4E75                    1127              RTS
00001B9C                          1128  
00001B9C  B83C 0000               1129  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00001BA0  6700 002E               1130              BEQ         B_EA
00001BA4  B83C 0001               1131              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001BA8  6700 003A               1132              BEQ         W_EA
00001BAC  B83C 0002               1133              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001BB0  6700 0046               1134              BEQ         L_EA
00001BB4                          1135  
00001BB4  B83C 0004               1136              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001BB8  6700 0052               1137              BEQ         B_DN
00001BBC  B83C 0005               1138              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001BC0  6700 005E               1139              BEQ         W_DN
00001BC4  B83C 0006               1140              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001BC8  6700 006A               1141              BEQ         L_DN        
00001BCC  6000 F51E               1142              BRA         INVALID     *Got here, must be invalid data.
00001BD0                          1143              
00001BD0  18FC 0042               1144  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
00001BD4  18FC 0020               1145              MOVE.B      #' ',(A4)+
00001BD8  18FC 0020               1146              MOVE.B      #' ',(A4)+
00001BDC  4EB9 00001C48           1147              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001BE2  4E75                    1148              RTS
00001BE4                          1149  
00001BE4  18FC 0057               1150  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
00001BE8  18FC 0020               1151              MOVE.B      #' ',(A4)+
00001BEC  18FC 0020               1152              MOVE.B      #' ',(A4)+
00001BF0  4EB9 00001C48           1153              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001BF6  4E75                    1154              RTS
00001BF8                          1155  
00001BF8  18FC 004C               1156  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00001BFC  18FC 0020               1157              MOVE.B      #' ',(A4)+
00001C00  18FC 0020               1158              MOVE.B      #' ',(A4)+
00001C04  4EB9 00001C48           1159              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001C0A  4E75                    1160              RTS
00001C0C                          1161  
00001C0C  18FC 0042               1162  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001C10  18FC 0020               1163              MOVE.B      #' ',(A4)+
00001C14  18FC 0020               1164              MOVE.B      #' ',(A4)+
00001C18  4EB9 00001C74           1165              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C1E  4E75                    1166              RTS
00001C20                          1167  
00001C20  18FC 0057               1168  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
00001C24  18FC 0020               1169              MOVE.B      #' ',(A4)+
00001C28  18FC 0020               1170              MOVE.B      #' ',(A4)+
00001C2C  4EB9 00001C74           1171              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C32  4E75                    1172              RTS
00001C34                          1173  
00001C34  18FC 004C               1174  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001C38  18FC 0020               1175              MOVE.B      #' ',(A4)+
00001C3C  18FC 0020               1176              MOVE.B      #' ',(A4)+
00001C40  4EB9 00001C74           1177              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C46  4E75                    1178              RTS            
00001C48                          1179              
00001C48                          1180              
00001C48                          1181              
00001C48                          1182              
00001C48                          1183              
00001C48                          1184              
00001C48                          1185              
00001C48                          1186  
00001C48                          1187  
00001C48                          1188  
00001C48                          1189  
00001C48                          1190  
00001C48                          1191  
00001C48                          1192  
00001C48                          1193  -------------------- end include --------------------
00001C48                          1194              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001C48                          1195  
00001C48                          1196  
00001C48                          1197  
00001C48  4EB9 00001D5A           1198  EASRC_DDES  JSR         GEN_EA_CODE *Deal with EA code First
00001C4E  18FC 002C               1199              MOVE.B      #',',(A4)+
00001C52  18FC 0044               1200              MOVE.B      #'D',(A4)+
00001C56  4EB9 00001DC2           1201              JSR         REG_CODE    *Decode Dn and add number to string
00001C5C  4E75                    1202              RTS
00001C5E                          1203  
00001C5E  4EB9 00001D5A           1204  EASRC_ADES  JSR         GEN_EA_CODE *Deal with EA code first
00001C64  18FC 002C               1205              MOVE.B      #',',(A4)+
00001C68  18FC 0041               1206              MOVE.B      #'A',(A4)+
00001C6C  4EB9 00001DC2           1207              JSR         REG_CODE    *Decode Dn and add number to string
00001C72  4E75                    1208              RTS        
00001C74                          1209  
00001C74  18FC 0044               1210  DN_SRC      MOVE.B      #'D',(A4)+
00001C78  4EB9 00001DC2           1211              JSR         REG_CODE    *Decode Dn and add number to string
00001C7E  18FC 002C               1212              MOVE.B      #',',(A4)+
00001C82  4EB9 00001D5A           1213              JSR         GEN_EA_CODE *Deal with EA code Second
00001C88  4E75                    1214              RTS
00001C8A                          1215  
00001C8A  4EB9 00001F20           1216  IDATASRC_EA JSR     IDATA       *Add immediate data
00001C90  18FC 002C               1217              MOVE.B  #',',(A4)+  
00001C94  4EB9 00001D5A           1218              JSR     GEN_EA_CODE *Add ea code
00001C9A  4E75                    1219              RTS
00001C9C                          1220  
00001C9C                          1221  
00001C9C  4EB9 00001D4A           1222  MM_OP_ORD   JSR         MM_DR       *Isolate DR bit into D2
00001CA2                          1223  
00001CA2  B43C 0000               1224              CMP.B       #0,D2       *Is it Register to Memory
00001CA6  6700 000A               1225              BEQ         MM_R2M
00001CAA  B43C 0001               1226              CMP.B       #1,D2       *Is it Memory to Register
00001CAE  6700 000A               1227              BEQ         MM_M2R
00001CB2                          1228              
00001CB2  4EB9 00001CD8           1229  MM_R2M      JSR         MM_LS_SRC
00001CB8  4E75                    1230              RTS
00001CBA                          1231  
00001CBA  4EB9 00001CC2           1232  MM_M2R      JSR         MM_EA_SRC
00001CC0  4E75                    1233              RTS
00001CC2                          1234  
00001CC2  4EB9 00001D5A           1235  MM_EA_SRC   JSR         GEN_EA_CODE *Add EA code
00001CC8  18FC 002C               1236              MOVE.B      #',',(A4)+
00001CCC                          1237              *JSR         ISO_MASK    *Isolate the Mask
00001CCC                          1238              
00001CCC                          1239              *Bandaid, instead of decoding list, just display hex value
00001CCC  18FC 0024               1240              MOVE.B      #'$',(A4)+
00001CD0  4EB9 00001F70           1241              JSR         W_IMD
00001CD6                          1242                      
00001CD6                          1243              *deal with list
00001CD6  4E75                    1244              RTS
00001CD8                          1245  
00001CD8                          1246  MM_LS_SRC   *Bandaid, instead of decoding list, just display hex value
00001CD8  18FC 0024               1247              MOVE.B      #'$',(A4)+
00001CDC  4EB9 00001F70           1248              JSR         W_IMD
00001CE2                          1249              
00001CE2                          1250              *Deal with list first
00001CE2  18FC 002C               1251              MOVE.B      #',',(A4)+
00001CE6  4EB9 00001D5A           1252              JSR         GEN_EA_CODE *Add EA code
00001CEC  4E75                    1253              RTS
00001CEE                          1254  
00001CEE  4281                    1255  MOVEQ_EA    CLR.L       D1          *Make sure D1 is clear
00001CF0  3207                    1256              MOVE.W      D7,D1       *copy original opcode
00001CF2  18FC 0020               1257              MOVE.B      #' ',(A4)+
00001CF6  18FC 0020               1258              MOVE.B      #' ',(A4)+
00001CFA  18FC 0023               1259              MOVE.B      #'#',(A4)+
00001CFE  18FC 0024               1260              MOVE.B      #'$',(A4)+
00001D02  4EB9 00001FFC           1261              JSR         B_H2A       *Add data in 8 least sig bits (byte)
00001D08  18FC 002C               1262              MOVE.B      #',',(A4)+
00001D0C  18FC 0044               1263              MOVE.B      #'D',(A4)+
00001D10                          1264              
00001D10  4281                    1265              CLR.L       D1
00001D12  123C 000D               1266              MOVE.B      #13,D1
00001D16  E94B                    1267              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001D18  E26B                    1268              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D1A                          1269              
00001D1A  4EB9 00001DC2           1270              JSR         REG_CODE    *Decode Dn and add number to string            
00001D20                          1271  
00001D20  4E75                    1272              RTS
00001D22                          1273              
00001D22  4281                    1274  ADDQ_EA     CLR.L       D1          *Make sure D1 is clear
00001D24  3207                    1275              MOVE.W      D7,D1       *Move untoched opcode into D1 for Manipulation
00001D26                          1276              
00001D26  E949                    1277              LSL.W       #4,D1       *Clear more sig bits
00001D28  4282                    1278              CLR.L       D2          * for shifting
00001D2A  143C 000D               1279              MOVE.B      #13,D2      *To move data bits into lsb
00001D2E  E469                    1280              LSR.W       D2,D1       *Data now in lsb
00001D30                          1281              
00001D30  18FC 0023               1282              MOVE.B      #'#',(A4)+
00001D34  18FC 0024               1283              MOVE.B      #'$',(A4)+
00001D38  4EB9 00001F88           1284              JSR         ADDQ_ID     *Jump to ADDQ_ID (immeidate data selector)
00001D3E  18FC 002C               1285              MOVE.B      #',',(A4)+  *Add seperator
00001D42  4EB9 00001D5A           1286              JSR         GEN_EA_CODE *Add the ea code
00001D48                          1287              
00001D48  4E75                    1288              RTS
00001D4A                          1289  
00001D4A                          1290  
00001D4A                          1291  
00001D4A  4281                    1292  MM_DR       CLR.L       D1
00001D4C  4282                    1293              CLR.L       D2
00001D4E  3407                    1294              MOVE.W      D7,D2
00001D50  EB4A                    1295              LSL.W       #5,D2
00001D52  123C 000F               1296              MOVE.B      #15,D1
00001D56  E26A                    1297              LSR.W       D1,D2
00001D58  4E75                    1298              RTS
00001D5A                          1299  
00001D5A  4283                    1300  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001D5C  4286                    1301              CLR.L       D6          *Make sure D6 is clear
00001D5E  4281                    1302              CLR.L       D1          *Make sure D1 is clear for shifting
00001D60                          1303              
00001D60  3607                    1304              MOVE.W      D7,D3       *Move untouched opcode into D3
00001D62  3C07                    1305              MOVE.W      D7,D6       *Move untouched opcode into D6
00001D64                          1306              
00001D64  123C 000A               1307              MOVE.B      #10,D1      *Shifting to isolate MODE
00001D68  E36E                    1308              LSL.W       D1,D6       
00001D6A  123C 000D               1309              MOVE.B      #13,D1
00001D6E  E26E                    1310              LSR.W       D1,D6       *Move MODE bits to LSB position
00001D70                          1311              
00001D70  E36B                    1312              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001D72  E26B                    1313              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D74                          1314              
00001D74  4EB9 00001DD8           1315              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001D7A  4E75                    1316              RTS
00001D7C                          1317              
00001D7C  4283                    1318  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001D7E  4286                    1319              CLR.L       D6          *Make sure D6 is clear
00001D80  4281                    1320              CLR.L       D1          *Make sure D1 is clear for shifting
00001D82                          1321              
00001D82  3607                    1322              MOVE.W      D7,D3       *Move untouched opcode into D3
00001D84  3C07                    1323              MOVE.W      D7,D6       *Move untouched opcode into D6
00001D86                          1324              
00001D86  123C 000A               1325              MOVE.B      #10,D1      *Shifting to isolate MODE
00001D8A  E36E                    1326              LSL.W       D1,D6       
00001D8C  123C 000D               1327              MOVE.B      #13,D1
00001D90  E26E                    1328              LSR.W       D1,D6       *Move MODE bits to LSB position
00001D92                          1329              
00001D92  E36B                    1330              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001D94  E26B                    1331              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D96                          1332              
00001D96  4EB9 00001DD8           1333              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001D9C                          1334              
00001D9C  18FC 002C               1335              MOVE.B      #',',(A4)+  *SEPERATOR
00001DA0                          1336              
00001DA0  4283                    1337              CLR.L       D3          *Make sure D3 is clear
00001DA2  4286                    1338              CLR.L       D6          *Make sure D6 is clear
00001DA4  4281                    1339              CLR.L       D1          *Make sure D1 is clear for shifting
00001DA6                          1340              
00001DA6  3607                    1341              MOVE.W      D7,D3       *Move untouched opcode into D3
00001DA8  3C07                    1342              MOVE.W      D7,D6       *Move untouched opcode into D6
00001DAA                          1343              
00001DAA  123C 0007               1344              MOVE.B      #7,D1      *Shifting to isolate MODE
00001DAE  E36E                    1345              LSL.W       D1,D6       
00001DB0  123C 000D               1346              MOVE.B      #13,D1
00001DB4  E26E                    1347              LSR.W       D1,D6       *Move MODE bits to LSB position
00001DB6                          1348              
00001DB6  E94B                    1349              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001DB8  E26B                    1350              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001DBA                          1351              
00001DBA  4EB9 00001DD8           1352              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001DC0                          1353              
00001DC0  4E75                    1354              RTS
00001DC2                          1355              
00001DC2                          1356              
00001DC2  4283                    1357  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
00001DC4  3607                    1358              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
00001DC6  E94B                    1359              LSL.W       #4,D3       *Isolate bits and move to LSB position
00001DC8  4282                    1360              CLR.L       D2
00001DCA  143C 000D               1361              MOVE.B      #13,D2
00001DCE  E46B                    1362              LSR.W       D2,D3
00001DD0  4EB9 00001E70           1363              JSR         REG_TBL     *Jump to register table.
00001DD6  4E75                    1364              RTS
00001DD8                          1365              
00001DD8                          1366  
00001DD8                          1367  
00001DD8                          1368  
00001DD8  BC3C 0000               1369  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
00001DDC  6700 002E               1370              BEQ         DRD
00001DE0  BC3C 0001               1371              CMP.B       #1,D6
00001DE4  6700 0032               1372              BEQ         ARD
00001DE8  BC3C 0002               1373              CMP.B       #2,D6
00001DEC  6700 0036               1374              BEQ         ARI
00001DF0  BC3C 0003               1375              CMP.B       #3,D6
00001DF4  6700 0042               1376              BEQ         ARI_INC
00001DF8  BC3C 0004               1377              CMP.B       #4,D6
00001DFC  6700 0052               1378              BEQ         ARI_DEC
00001E00  BC3C 0007               1379              CMP.B       #7,D6
00001E04  6700 0062               1380              BEQ         ABS_ADDR
00001E08  4EF8 10EC               1381              JMP         INVALID     *Got here? Must be bad data.
00001E0C                          1382  
00001E0C  18FC 0044               1383  DRD         MOVE.B      #'D',(A4)+
00001E10  4EB9 00001E70           1384              JSR         REG_TBL     *Reg num should be in D3
00001E16  4E75                    1385              RTS
00001E18                          1386  
00001E18  18FC 0041               1387  ARD         MOVE.B      #'A',(A4)+
00001E1C  4EB9 00001E70           1388              JSR         REG_TBL     *Reg num should be in D3
00001E22  4E75                    1389              RTS
00001E24                          1390  
00001E24  18FC 0028               1391  ARI         MOVE.B      #'(',(A4)+
00001E28  18FC 0041               1392              MOVE.B      #'A',(A4)+
00001E2C  4EB9 00001E70           1393              JSR         REG_TBL     *Reg num should be in D3
00001E32  18FC 0029               1394              MOVE.B      #')',(A4)+
00001E36  4E75                    1395              RTS
00001E38                          1396  
00001E38  18FC 0028               1397  ARI_INC     MOVE.B      #'(',(A4)+
00001E3C  18FC 0041               1398              MOVE.B      #'A',(A4)+
00001E40  4EB9 00001E70           1399              JSR         REG_TBL     *Reg num should be in D3
00001E46  18FC 0029               1400              MOVE.B      #')',(A4)+
00001E4A  18FC 002B               1401              MOVE.B      #'+',(A4)+
00001E4E  4E75                    1402              RTS
00001E50                          1403  
00001E50  18FC 002D               1404  ARI_DEC     MOVE.B      #'-',(A4)+
00001E54  18FC 0028               1405              MOVE.B      #'(',(A4)+
00001E58  18FC 0041               1406              MOVE.B      #'A',(A4)+
00001E5C  4EB9 00001E70           1407              JSR         REG_TBL     *Reg num should be in D3
00001E62  18FC 0029               1408              MOVE.B      #')',(A4)+
00001E66  4E75                    1409              RTS
00001E68                          1410  
00001E68  4EB9 00001EE4           1411  ABS_ADDR    JSR         ABS_TBL
00001E6E  4E75                    1412              RTS
00001E70                          1413              
00001E70  B63C 0000               1414  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001E74  6700 003E               1415              BEQ         NUM_0
00001E78  B63C 0001               1416              CMP.B       #1,D3
00001E7C  6700 003C               1417              BEQ         NUM_1
00001E80  B63C 0002               1418              CMP.B       #2,D3
00001E84  6700 003A               1419              BEQ         NUM_2
00001E88  B63C 0003               1420              CMP.B       #3,D3
00001E8C  6700 0038               1421              BEQ         NUM_3
00001E90  B63C 0004               1422              CMP.B       #4,D3
00001E94  6700 0036               1423              BEQ         NUM_4
00001E98  B63C 0005               1424              CMP.B       #5,D3
00001E9C  6700 0034               1425              BEQ         NUM_5
00001EA0  B63C 0006               1426              CMP.B       #6,D3
00001EA4  6700 0032               1427              BEQ         NUM_6
00001EA8  B63C 0007               1428              CMP.B       #7,D3
00001EAC  6700 0030               1429              BEQ         NUM_7
00001EB0  4EF8 10EC               1430              JMP         INVALID     *Got here? Must be bad data.
00001EB4                          1431              
00001EB4  18FC 0030               1432  NUM_0       MOVE.B      #'0',(A4)+
00001EB8  4E75                    1433              RTS              
00001EBA  18FC 0031               1434  NUM_1       MOVE.B      #'1',(A4)+
00001EBE  4E75                    1435              RTS
00001EC0  18FC 0032               1436  NUM_2       MOVE.B      #'2',(A4)+
00001EC4  4E75                    1437              RTS
00001EC6  18FC 0033               1438  NUM_3       MOVE.B      #'3',(A4)+
00001ECA  4E75                    1439              RTS
00001ECC  18FC 0034               1440  NUM_4       MOVE.B      #'4',(A4)+
00001ED0  4E75                    1441              RTS
00001ED2  18FC 0035               1442  NUM_5       MOVE.B      #'5',(A4)+
00001ED6  4E75                    1443              RTS
00001ED8  18FC 0036               1444  NUM_6       MOVE.B      #'6',(A4)+
00001EDC  4E75                    1445              RTS
00001EDE  18FC 0037               1446  NUM_7       MOVE.B      #'7',(A4)+
00001EE2  4E75                    1447              RTS
00001EE4                          1448  
00001EE4  B63C 0000               1449  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001EE8  6700 0016               1450              BEQ         ABW
00001EEC  B63C 0001               1451              CMP.B       #1,D3
00001EF0  6700 001E               1452              BEQ         ABL
00001EF4  B63C 0004               1453              CMP.B       #4,D3
00001EF8  6700 0026               1454              BEQ         IDATA
00001EFC  4EF8 10EC               1455              JMP         INVALID     *Got here? Must be bad data.
00001F00                          1456              
00001F00  18FC 0024               1457  ABW         MOVE.B      #'$',(A4)+
00001F04  4281                    1458              CLR.L       D1          *Make sure D1 is clear
00001F06  321D                    1459              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F08  4EB9 0000203E           1460              JSR         W_H2A       *convert absolute value to ascii and add to good string
00001F0E  4E75                    1461              RTS
00001F10                          1462  
00001F10  18FC 0024               1463  ABL         MOVE.B      #'$',(A4)+
00001F14  4281                    1464              CLR.L       D1          *Make sure D1 is clear
00001F16  221D                    1465              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F18  4EB9 00002080           1466              JSR         L_H2A
00001F1E  4E75                    1467              RTS
00001F20                          1468              
00001F20  18FC 0023               1469  IDATA       MOVE.B      #'#',(A4)+
00001F24  18FC 0024               1470              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
00001F28  4EB9 00001F30           1471              JSR         IMD_TBL
00001F2E  4E75                    1472              RTS
00001F30                          1473              
00001F30  B83C 0000               1474  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
00001F34  6700 002E               1475              BEQ         B_IMD       
00001F38  B83C 0004               1476              CMP.B       #4,D4
00001F3C  6700 0026               1477              BEQ         B_IMD
00001F40                          1478  
00001F40  B83C 0001               1479              CMP.B       #1,D4       *Is it a word size code?
00001F44  6700 002A               1480              BEQ         W_IMD
00001F48  B83C 0005               1481              CMP.B       #5,D4
00001F4C  6700 0022               1482              BEQ         W_IMD
00001F50                          1483              
00001F50  B83C 0002               1484              CMP.B       #2,D4       *Is it a long word size code?
00001F54  6700 0026               1485              BEQ         L_IMD
00001F58  B83C 0006               1486              CMP.B       #6,D4
00001F5C  6700 001E               1487              BEQ         L_IMD
00001F60                          1488              
00001F60  6000 F18A               1489              BRA         INVALID     *Got here? Must be bad data.
00001F64                          1490              
00001F64  4281                    1491  B_IMD       CLR.L       D1
00001F66  321D                    1492              MOVE.W      (A5)+,D1    *Make sure D1 is clear
00001F68  4EB9 00001FFC           1493              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
00001F6E  4E75                    1494              RTS
00001F70                          1495  
00001F70  4281                    1496  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001F72  321D                    1497              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F74  4EB9 0000203E           1498              JSR         W_H2A
00001F7A  4E75                    1499              RTS
00001F7C                          1500  
00001F7C  4281                    1501  L_IMD       CLR.L       D1          *Make sure D1 is clear
00001F7E  221D                    1502              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
00001F80  4EB9 00002080           1503              JSR         L_H2A
00001F86  4E75                    1504              RTS
00001F88                          1505  
00001F88  B23C 0000               1506  ADDQ_ID     CMP.B       #0,D1       *Select correct number to add to output strings
00001F8C  6700 003E               1507              BEQ         AQ_0
00001F90  B23C 0001               1508              CMP.B       #1,D1
00001F94  6700 003C               1509              BEQ         AQ_1
00001F98  B23C 0002               1510              CMP.B       #2,D1
00001F9C  6700 003A               1511              BEQ         AQ_2
00001FA0  B23C 0003               1512              CMP.B       #3,D1
00001FA4  6700 0038               1513              BEQ         AQ_3
00001FA8  B23C 0004               1514              CMP.B       #4,D1
00001FAC  6700 0036               1515              BEQ         AQ_4
00001FB0  B23C 0005               1516              CMP.B       #5,D1
00001FB4  6700 0034               1517              BEQ         AQ_5
00001FB8  B23C 0006               1518              CMP.B       #6,D1
00001FBC  6700 0032               1519              BEQ         AQ_6
00001FC0  B23C 0007               1520              CMP.B       #7,D1
00001FC4  6700 0030               1521              BEQ         AQ_7
00001FC8  4EF8 10EC               1522              JMP         INVALID     *Got here? Something is wrong.
00001FCC                          1523              
00001FCC  18FC 0038               1524  AQ_0        MOVE.B      #'8',(A4)+
00001FD0  4E75                    1525              RTS              
00001FD2  18FC 0031               1526  AQ_1        MOVE.B      #'1',(A4)+
00001FD6  4E75                    1527              RTS
00001FD8  18FC 0032               1528  AQ_2        MOVE.B      #'2',(A4)+
00001FDC  4E75                    1529              RTS
00001FDE  18FC 0033               1530  AQ_3        MOVE.B      #'3',(A4)+
00001FE2  4E75                    1531              RTS
00001FE4  18FC 0034               1532  AQ_4        MOVE.B      #'4',(A4)+
00001FE8  4E75                    1533              RTS
00001FEA  18FC 0035               1534  AQ_5        MOVE.B      #'5',(A4)+
00001FEE  4E75                    1535              RTS
00001FF0  18FC 0036               1536  AQ_6        MOVE.B      #'6',(A4)+
00001FF4  4E75                    1537              RTS
00001FF6  18FC 0037               1538  AQ_7        MOVE.B      #'7',(A4)+
00001FFA  4E75                    1539              RTS          
00001FFC                          1540  
00001FFC                          1541              
00001FFC                          1542  
00001FFC                          1543  
00001FFC                          1544  INV_DATA *need to implement currently invalid data is treated as an invalid opcode.
00001FFC                          1545  
00001FFC                          1546  
00001FFC  4280                    1547  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001FFE  4282                    1548              CLR.L       D2          *Make sure D2 is empty (each individual char)
00002000  4283                    1549              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002002  103C 0002               1550              MOVE.B      #$2,D0      *Counter
00002006  6000 0002               1551              BRA         B_ISO_DIG   *Begin isolating chars
0000200A                          1552              
0000200A  E919                    1553  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
0000200C                          1554              
0000200C  1401                    1555              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000200E                          1556              
0000200E  163C 0004               1557              MOVE.B      #4,D3      *Shift left 28 times
00002012  E72A                    1558              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00002014  E91A                    1559              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00002016                          1560              
00002016  0C02 0009               1561              CMPI.B      #$9,D2      *Is it a number?
0000201A  6F00 0006               1562              BLE         B_NUM       *If it is, process number
0000201E  6000 000A               1563              BRA         B_LET       *If not, process letter
00002022                          1564              
00002022  0602 0030               1565  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002026  6000 000A               1566              BRA         B_ADD_CHAR  *add to strings and continue
0000202A                          1567              
0000202A  0602 0037               1568  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000202E  6000 0002               1569              BRA         B_ADD_CHAR  *add to strings and continue
00002032                          1570  
00002032  18C2                    1571  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00002034  5300                    1572              SUBI.B      #$1,D0      *decrement counter
00002036  0C00 0000               1573              CMPI.B      #$0,D0      *Check if we're done            
0000203A  6ECE                    1574              BGT         B_ISO_DIG   *If not, continue tranlation   
0000203C                          1575              
0000203C  4E75                    1576              RTS
0000203E                          1577  
0000203E  4280                    1578  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00002040  4282                    1579              CLR.L       D2          *Make sure D2 is empty (each individual char)
00002042  4283                    1580              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002044  103C 0004               1581              MOVE.B      #$4,D0      *Counter
00002048  6000 0002               1582              BRA         W_ISO_DIG   *Begin isolating chars
0000204C                          1583              
0000204C  E959                    1584  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
0000204E                          1585              
0000204E  1401                    1586              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00002050                          1587              
00002050  163C 000C               1588              MOVE.B      #12,D3      *Shift left 28 times
00002054  E76A                    1589              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
00002056  E95A                    1590              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
00002058                          1591              
00002058  0C02 0009               1592              CMPI.B      #$9,D2      *Is it a number?
0000205C  6F00 0006               1593              BLE         W_NUM       *If it is, process number
00002060  6000 000A               1594              BRA         W_LET       *If not, process letter
00002064                          1595              
00002064  0602 0030               1596  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002068  6000 000A               1597              BRA         W_ADD_CHAR  *add to strings and continue
0000206C                          1598              
0000206C  0602 0037               1599  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00002070  6000 0002               1600              BRA         W_ADD_CHAR  *add to strings and continue
00002074                          1601  
00002074  18C2                    1602  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00002076  5300                    1603              SUBI.B      #$1,D0      *decrement counter
00002078  0C00 0000               1604              CMPI.B      #$0,D0      *Check if we're done            
0000207C  6ECE                    1605              BGT         W_ISO_DIG   *If not, continue tranlation   
0000207E                          1606              
0000207E  4E75                    1607              RTS
00002080  4280                    1608  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00002082  4282                    1609              CLR.L       D2          *Make sure D2 is empty (each individual char)
00002084  4283                    1610              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002086  103C 0008               1611              MOVE.B      #$8,D0      *Counter
0000208A  6000 0002               1612              BRA         L_ISO_DIG   *Begin isolating chars
0000208E                          1613              
0000208E  E999                    1614  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
00002090                          1615              
00002090  1401                    1616              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00002092                          1617              
00002092  163C 001C               1618              MOVE.B      #28,D3      *Shift left 28 times
00002096  E7AA                    1619              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00002098  E99A                    1620              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
0000209A                          1621              
0000209A  0C02 0009               1622              CMPI.B      #$9,D2      *Is it a number?
0000209E  6F00 0006               1623              BLE         L_NUM       *If it is, process number
000020A2  6000 000A               1624              BRA         L_LET       *If not, process letter
000020A6                          1625              
000020A6  0602 0030               1626  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000020AA  6000 000A               1627              BRA         L_ADD_CHAR  *add to strings and continue
000020AE                          1628              
000020AE  0602 0037               1629  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000020B2  6000 0002               1630              BRA         L_ADD_CHAR  *add to strings and continue
000020B6                          1631  
000020B6  18C2                    1632  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000020B8  5300                    1633              SUBI.B      #$1,D0      *decrement counter
000020BA  0C00 0000               1634              CMPI.B      #$0,D0      *Check if we're done            
000020BE  6ECE                    1635              BGT         L_ISO_DIG   *If not, continue tranlation   
000020C0                          1636              
000020C0  4E75                    1637              RTS
000020C2                          1638  
000020C2                          1639  
000020C2                          1640  
000020C2                          1641  
000020C2                          1642  
000020C2                          1643  
000020C2                          1644  
000020C2                          1645  
000020C2                          1646  -------------------- end include --------------------
000020C2                          1647  
000020C2  =0000000D               1648  CR          EQU         $0D
000020C2  =0000000A               1649  LF          EQU         $0A
000020C2                          1650  
000020C2= 2D 2D 2D 2D 2D 2D ...   1651  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
000020EC= 48 65 6E 72 79 20 ...   1652              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00002115= 43 53 53 20 34 32 ...   1653              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
0000213E= 2D 2D 2D 2D 2D 2D ...   1654              DC.B        '----------------------------------------',CR,LF,0
00002169                          1655  
00002169= 59 6F 75 20 4D 55 ...   1656  IN_WARN     DC.B        'You MUST follow the following input rules:',CR,LF
00002195= 31 2E 20 59 6F 75 ...   1657              DC.B        '1. Your starting address must be greater than or equal to $3000',CR,LF
000021D6= 20 20 20 28 74 68 ...   1658              DC.B        '   (this means your data file must be orged at $3000 or greater)',CR,LF
00002218= 32 2E 20 59 6F 75 ...   1659              DC.B        '2. Your ending address must be greater than your starting address',CR,LF
0000225B= 33 2E 20 59 6F 75 ...   1660              DC.B        '3. You must enter something for both starting and ending (no NULL inputs)',CR,LF
000022A6= 34 2E 20 42 6F 74 ...   1661              DC.B        '4. Both your starting and ending address must be in the range of:',CR,LF
000022E9= 20 20 20 5B 24 33 ...   1662              DC.B        '   [$3000,$FFFFFFFF) (interval notation)',CR,LF
00002313= 35 2E 20 59 6F 75 ...   1663              DC.B        '5. Your inputs for both addresses may NOT be ODD values.',CR,LF
0000234D= 36 2E 20 59 6F 75 ...   1664              DC.B        '6. Your inputs for both must ONLY contain standard hexidecimal characters:',CR,LF
00002399= 20 20 20 30 20 31 ...   1665              DC.B        '   0 1 2 3 4 5 6 7 8 9 A B C D E F (Do NOT include spaces or $)',CR,LF
000023DA= 46 61 69 6C 75 72 ...   1666              DC.B        'Failure to follow these instructions WILL result in crash or unexpected behavior.',CR,LF,CR,LF,0
00002430                          1667   
00002430                          1668              
00002430= 45 6E 74 65 72 20 ...   1669  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
00002453= 45 6E 74 65 72 20 ...   1670  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
00002474                          1671  
00002474= 0D 0A 50 72 65 73 ...   1672  NXT_PG      DC.B        CR,LF,'Press ENTER key to contiune reading',CR,CR,LF,0
0000249D                          1673  
0000249D= 0D 0A 50 72 65 73 ...   1674  END_PGR     DC.B        CR,LF,'Prese SPACE to decode another memory image.',CR,LF
000024CC= 50 72 65 73 73 20 ...   1675              DC.B        'Press ESC key to QUIT.',CR,LF,0
000024E5                          1676  
000024E5                          1677  STA_ADDR    DS.B        40
0000250D                          1678  END_ADDR    DS.B        40
00002535                          1679  
00002535                          1680  
00002535                          1681  
00002535                          1682  
00002536= 00000001                1683  BAD_STR     DC.L        1
0000253A                          1684  
0000253A= 00000050                1685  SPACER11    DC.L        80
0000253E= 00000050                1686  SPACER22    DC.L        80
00002542= 00000050                1687  SPACER33    DC.L        80
00002546= 00000050                1688  SPACER44    DC.L        80
0000254A= 00000050                1689  SPACER55    DC.L        80
0000254E= 00000050                1690  SPACER66    DC.L        80
00002552= 00000050                1691  SPACER77    DC.L        80
00002556= 00000050                1692  SPACER88    DC.L        80
0000255A= 00000050                1693  SPACER99    DC.L        80
0000255E= 00000050                1694  SPACERAA    DC.L        80
00002562= 00000050                1695  SPACERBB    DC.L        80
00002566= 00000050                1696  SPACERCC    DC.L        80
0000256A= 00000050                1697  SPACERDD    DC.L        80
0000256E= 00000050                1698  SPACEREE    DC.L        80
00002572= 00000050                1699  SPACERFF    DC.L        80
00002576                          1700  
00002576= 00000001                1701  GOOD_STR    DC.L        1
0000257A                          1702  
0000257A= 00000050                1703  SPACER1     DC.L        80
0000257E= 00000050                1704  SPACER2     DC.L        80
00002582= 00000050                1705  SPACER3     DC.L        80
00002586= 00000050                1706  SPACER4     DC.L        80
0000258A= 00000050                1707  SPACER5     DC.L        80
0000258E= 00000050                1708  SPACER6     DC.L        80
00002592= 00000050                1709  SPACER7     DC.L        80
00002596= 00000050                1710  SPACER8     DC.L        80
0000259A= 00000050                1711  SPACER9     DC.L        80
0000259E= 00000050                1712  SPACERA     DC.L        80
000025A2= 00000050                1713  SPACERB     DC.L        80
000025A6= 00000050                1714  SPACERC     DC.L        80
000025AA= 00000050                1715  SPACERD     DC.L        80
000025AE= 00000050                1716  SPACERE     DC.L        80
000025B2= 00000050                1717  SPACERF     DC.L        80
000025B6                          1718  
000025B6                          1719              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 1F10
ABS_ADDR            1E68
ABS_TBL             1EE4
ABW                 1F00
ADDQ_EA             1D22
ADDQ_ID             1F88
ADD_CHAR_B          1218
ADD_CHAR_BO         125E
ADD_CHAR_G          11D0
ADD_SIZE            1B24
AH_DONE             109E
AQ_0                1FCC
AQ_1                1FD2
AQ_2                1FD8
AQ_3                1FDE
AQ_4                1FE4
AQ_5                1FEA
AQ_6                1FF0
AQ_7                1FF6
ARD                 1E18
ARI                 1E24
ARI_DEC             1E50
ARI_INC             1E38
ASCII_HEX           1086
BAD_STR             2536
BCC_CC              1A04
BCC_CODE            194A
BCC_CS              1A1C
BCC_EQ              1A4C
BCC_GE              1AC4
BCC_GT              1AF4
BCC_HI              19D4
BCC_LE              1B0C
BCC_LS              19EC
BCC_LT              1ADC
BCC_MI              1AAC
BCC_NE              1A34
BCC_PL              1A94
BCC_TABLE           1960
BCC_VC              1A64
BCC_VS              1A7C
B_ADD_CHAR          2032
B_DN                1C0C
B_EA                1BD0
B_H2A               1FFC
B_IMD               1F64
B_ISO_DIG           200A
B_LET               202A
B_NUM               2022
B_SIZE              1B3C
CLEAN_GS            112A
CONTINUE            10F6
CR                  D
DECODE_LOOP         10C2
DN_SRC              1C74
DONE                130A
DRD                 1E0C
D_CLEAN             113E
EASRC_ADES          1C5E
EASRC_DDES          1C48
EA_TBL              1DD8
END_ADDR            250D
END_MSG             2453
END_OPT             12E6
END_PGR             249D
FORMAT              10B4
GEN_EA_CODE         1D5A
GET_INPUT           1020
GET_SIZE_1          1B86
GET_SIZE_2          1B76
GET_SIZE_3          1B66
GOOD_STR            2576
GS_LOOP             1130
H2A_B_ADDR          11DC
H2A_B_OP            1224
H2A_G_ADDR          1194
IDATA               1F20
IDATASRC_EA         1C8A
IMD_TBL             1F30
INIT_BAD            1162
INIT_GOOD           114E
INIT_STRS           1140
INTRO               1012
INVALID             10EC
INV_DATA            1FFC
IN_WARN             2169
ISODIG_BO           1236
ISO_DIG_B           11F0
ISO_DIG_G           11A8
JMP_0               131C
JMP_0X              147A
JMP_1               132C
JMP_2               133C
JMP_2X              14A4
JMP_3               134C
JMP_3X              14C8
JMP_4               135C
JMP_47X             1606
JMP_4X              14EC
JMP_5               136C
JMP_6               137C
JMP_6X              1532
JMP_7               138C
JMP_8               139C
JMP_8X              1556
JMP_9               13AC
JMP_A               13BC
JMP_B               13CA
JMP_C               13D8
JMP_CX              157A
JMP_D               13E8
JMP_DX              159E
JMP_E               13F8
JMP_EX              1602
JMP_TBL             1310
J_47X               151A
J_ADDI              149C
J_AND               1596
J_BCC               154E
J_BRA               1546
J_CLR1              143C
J_CLR2              142C
J_CLR3              141C
J_CLR4              140C
J_CLR_DM            146A
J_CLR_LEA           144C
J_CLR_MM            145C
J_DIVU              156A
J_LEA               1522
J_MOVEAL            14B8
J_MOVEAW            14DC
J_MOVEL             14C0
J_MOVEM             152A
J_MOVEW             14E4
J_MULS              158E
J_OR                1572
J_SUBI              1494
LET                 10AA
LET_B               1210
LET_BO              1256
LET_G               11C8
LF                  A
L_ADD_CHAR          20B6
L_DN                1C34
L_EA                1BF8
L_H2A               2080
L_IMD               1F7C
L_ISO_DIG           208E
L_LET               20AE
L_NUM               20A6
L_SIZE              1B58
MM_ADD_S            1770
MM_DR               1D4A
MM_EA_SRC           1CC2
MM_LONG             176C
MM_LS_SRC           1CD8
MM_M2R              1CBA
MM_OP_ORD           1C9C
MM_R2M              1CB2
MM_WORD             1764
MOVEQ_EA            1CEE
MOV_EA_CODE         1D7C
NEXT_PAGE           110C
NL_INTRO            20C2
NUM                 10A0
NUM_0               1EB4
NUM_1               1EBA
NUM_2               1EC0
NUM_3               1EC6
NUM_4               1ECC
NUM_5               1ED2
NUM_6               1ED8
NUM_7               1EDE
NUM_B               1208
NUM_BO              124E
NUM_G               11C0
NXT_PG              2474
OPC_ADD             18F4
OPC_ADDA            18D2
OPC_ADDI            1666
OPC_ADDQ            16B2
OPC_AND             18B4
OPC_BCC             1842
OPC_BRA             1826
OPC_DIVU            184E
OPC_JSR             1912
OPC_LEA             1714
OPC_MOVEAL          177E
OPC_MOVEAW          17D2
OPC_MOVEB           168E
OPC_MOVEL           17AA
OPC_MOVEM           1736
OPC_MOVEQ           16DA
OPC_MOVEW           17FE
OPC_MULS            188E
OPC_NOP             192E
OPC_OR              1874
OPC_RTS             193C
OPC_SUB             16F6
OPC_SUBI            163E
OP_ADD              15FA
OP_ADDA             15F2
OR_ADD_SIZE         1B9C
O_JSR               1636
O_NOP               1626
O_RTS               162E
PRG_RESET           1296
PRINT_B             1280
PRINT_G             126A
PRINT_GOOD          10E2
PROC_END            107A
PROC_STA            106E
REG_CODE            1DC2
REG_TBL             1E70
SPACER1             257A
SPACER11            253A
SPACER2             257E
SPACER22            253E
SPACER3             2582
SPACER33            2542
SPACER4             2586
SPACER44            2546
SPACER5             258A
SPACER55            254A
SPACER6             258E
SPACER66            254E
SPACER7             2592
SPACER77            2552
SPACER8             2596
SPACER88            2556
SPACER9             259A
SPACER99            255A
SPACERA             259E
SPACERAA            255E
SPACERB             25A2
SPACERBB            2562
SPACERC             25A6
SPACERCC            2566
SPACERD             25AA
SPACERDD            256A
SPACERE             25AE
SPACEREE            256E
SPACERF             25B2
SPACERFF            2572
START               1000
STA_ADDR            24E5
STA_MSG             2430
W_ADD_CHAR          2074
W_DN                1C20
W_EA                1BE4
W_H2A               203E
W_IMD               1F70
W_ISO_DIG           204C
W_LET               206C
W_NUM               2064
W_SIZE              1B4A
