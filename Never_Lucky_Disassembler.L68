00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/30/2017 9:50:07 AM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010C2             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 00001FF6             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 0000209D             28  GET_INPUT   LEA         IN_WARN,A1 *Load INTRO1 message into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display intro
0000102A  4E4F                      30              TRAP        #15 
0000102C                            31  
0000102C  43F9 00002364             32              LEA         STA_MSG,A1  *Load STA_MSG into A1
00001032  103C 000E                 33              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  43F9 00002419             36              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
0000103E  103C 0002                 37              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001042  4E4F                      38              TRAP        #15         
00001044                            39              
00001044  4EB9 0000106E             40              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000104A  4281                      41              CLR.L       D1          *Clear input length from D1
0000104C                            42              
0000104C  43F9 00002387             43              LEA         END_MSG,A1  *Load END_MSG into A1
00001052  103C 000E                 44              MOVE.B      #14,D0      *Trap task 14, display end address msg
00001056  4E4F                      45              TRAP        #15
00001058                            46              
00001058  43F9 00002441             47              LEA         END_ADDR,A1 *Store input in END_ADDR variable
0000105E  103C 0002                 48              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001062  4E4F                      49              TRAP        #15         
00001064                            50              
00001064  4EB9 0000107A             51              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000106A  4281                      52              CLR.L       D1          *Clear input length from D1
0000106C                            53              
0000106C  4E75                      54              RTS
0000106E                            55              
0000106E                            56  *--------------------PROC_STA-------------------------------
0000106E                            57  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
0000106E  4EB9 00001086             58              JSR         ASCII_HEX   *Convert input into Hex
00001074                            59              
00001074                            60              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            61              
00001074  2A43                      62              MOVEA.L     D3,A5       *Move hex to STA_ADDR
00001076  4283                      63              CLR.L       D3          *Clear D3
00001078  4E75                      64              RTS                     
0000107A                            65  
0000107A                            66  *--------------------PROC_END-------------------------------
0000107A                            67  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000107A                            68              *      does not fall before start
0000107A  4EB9 00001086             69              JSR         ASCII_HEX   *Convert input into Hex
00001080                            70              
00001080                            71              *assuming all error checking is done before the next instruction (not yet implemented)
00001080                            72              
00001080  2C43                      73              MOVE.L      D3,A6       *Move hex to END_ADDR
00001082  4283                      74              CLR.L       D3          *Clear D3
00001084  4E75                      75              RTS
00001086                            76  
00001086                            77  *-------------------ASCII_HEX-------------------------------
00001086  0C01 0000                 78  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000108A  6700 0012                 79              BEQ         AH_DONE     *End subroutine if all converted
0000108E  1419                      80              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001090  183C 0039                 81              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001094  B404                      82              CMP.B       D4,D2       *Check if ascii code is for a number or letter
00001096  6F00 0008                 83              BLE         NUM         *Codes less than $39 imply a number, so branch
0000109A  6000 000E                 84              BRA         LET         *If not a number, must be a letter.            
0000109E  4E75                      85  AH_DONE     RTS
000010A0                            86  
000010A0  183C 0030                 87  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
000010A4  9404                      88              SUB.B       D4,D2       *convert to hexadecimal number
000010A6  6000 000C                 89              BRA         FORMAT      *branch to subroutine to store converted hex number
000010AA                            90              
000010AA  183C 0037                 91  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010AE  9404                      92              SUB.B       D4,D2       *convert to hexadecimal letter
000010B0  6000 0002                 93              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010B4                            94  
000010B4  5301                      95  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010B6  D602                      96              ADD.B       D2,D3       *Store converted number in D3
000010B8  0C01 0000                 97              CMPI.B      #$0,D1      *Check if we're all done converting
000010BC  67C8                      98              BEQ         ASCII_HEX   *If not continue conversion
000010BE  E983                      99              ASL.L       #4,D3       *Shift bits to the left to correct position
000010C0  60C4                     100              BRA         ASCII_HEX   *Branch back to label
000010C2                           101              
000010C2                           102  *-------------------DECODE_LOOP-----------------------------
000010C2  3E1D                     103  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010C4  47F9 0000246A            104              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010CA  49F9 000024AA            105              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010D0                           106              
000010D0  4EB9 0000113C            107              JSR         INIT_STRS   *Initialize Bad and Good Str
000010D6                           108              
000010D6  4EB9 0000130C            109              JSR         JMP_TBL     *Start opcode identification waterfall
000010DC                           110              
000010DC  4EB9 00001126            111              JSR         CLEAN_GS    *end of output string.
000010E2                           112              
000010E2  4EB9 00001266            113  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010E8  6000 000C                114              BRA         CONTINUE    *Continue the loop
000010EC  4EB9 0000127C            115  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010F2  6000 0002                116              BRA         CONTINUE    *Continue the loop            
000010F6                           117              
000010F6  BCCD                     118  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010F8  6F00 01E8                119              BLE         END_OPT     *if we're done, move to end options (ask user what to do)
000010FC                           120              
000010FC                           121                          
000010FC  5205                     122              ADDQ.B      #1,D5       *Increment line counter
000010FE  BA3C 001D                123              CMP.B       #29,D5      *See if page is full
00001102  6700 0004                124              BEQ         NEXT_PAGE   *Jump to next page prompt
00001106                           125              
00001106  60BA                     126              BRA         DECODE_LOOP * Continue loop
00001108                           127  
00001108                           128  *-------------------NEXT_PAGE-----------------------------
00001108  43F9 000023A8            129  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
0000110E  4280                     130              CLR.L       D0          *Make sure D0 is empty
00001110  103C 000E                131              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001114  4E4F                     132              TRAP        #15            
00001116                           133              
00001116  103C 0005                134              MOVE.B      #5,D0       *Single char trap task
0000111A  4E4F                     135              TRAP        #15         
0000111C                           136              
0000111C  B23C 000D                137              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001120  66E6                     138              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
00001122                           139              
00001122  4285                     140              CLR.L       D5          *Reset page counter
00001124                           141              
00001124  609C                     142              BRA         DECODE_LOOP *Continue the loop
00001126                           143              
00001126                           144  *-------------------GS_CLEAN--------------------------------
00001126                           145  * This subroutine "cleans" the end of the good string.
00001126                           146  * Prevents the previous string from showing content in the
00001126                           147  * current string.
00001126                           148  *-----------------------------------------------------------
00001126  4280                     149  CLEAN_GS    CLR.L       D0
00001128  103C 000F                150              MOVE.B      #15,D0      *Max 15 chars to clean
0000112C                           151  
0000112C  0C00 0000                152  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001130  6700 0008                153              BEQ         D_CLEAN
00001134  421C                     154              CLR.B       (A4)+
00001136  5300                     155              SUBI.B      #$1,D0
00001138  60F2                     156              BRA         GS_LOOP
0000113A  4E75                     157  D_CLEAN     RTS
0000113C                           158              
0000113C                           159  *-------------------INIT_STRS-----------------------------
0000113C  4EB9 0000114A            160  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001142  4EB9 0000115E            161              JSR         INIT_BAD    *Initialize the bad string
00001148  4E75                     162              RTS
0000114A                           163              
0000114A                           164  *-------------------INIT_GOOD-----------------------------
0000114A  18FC 0024                165  INIT_GOOD   MOVE.B      #'$',(A4)+ 
0000114E  4EB9 00001190            166              JSR         H2A_G_ADDR *Now convert address to ASCII
00001154                           167              
00001154  18FC 0020                168              MOVE.B      #' ',(A4)+  *Add spaces after addr
00001158  18FC 0020                169              MOVE.B      #' ',(A4)+
0000115C                           170              
0000115C  4E75                     171              RTS
0000115E                           172  
0000115E                           173  *-------------------INIT_BAD------------------------------            
0000115E  16FC 0024                174  INIT_BAD    MOVE.B      #'$',(A3)+
00001162  4EB9 000011D8            175              JSR         H2A_B_ADDR  *Add the address to the bad string
00001168  16FC 0020                176              MOVE.B      #' ',(A3)+    
0000116C  16FC 0020                177              MOVE.B      #' ',(A3)+
00001170                           178              
00001170  16FC 0044                179              MOVE.B      #'D',(A3)+  
00001174  16FC 0041                180              MOVE.B      #'A',(A3)+ 
00001178  16FC 0054                181              MOVE.B      #'T',(A3)+    
0000117C  16FC 0041                182              MOVE.B      #'A',(A3)+ 
00001180                           183              
00001180  16FC 0020                184              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001184  16FC 0020                185              MOVE.B      #' ',(A3)+
00001188  4EB9 00001220            186              JSR         H2A_B_OP   *Add the opcode to the bad string
0000118E                           187              
0000118E  4E75                     188              RTS
00001190                           189              
00001190                           190  *-------------------H2A_G_ADDR-------------------------------            
00001190  4280                     191  H2A_G_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
00001192  4281                     192              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001194  4282                     193              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001196  4283                     194              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001198  220D                     195              MOVE.L      A5,D1       *Copy address into D1
0000119A  5581                     196              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
0000119C  103C 0008                197              MOVE.B      #$8,D0      *Counter
000011A0  6000 0002                198              BRA         ISO_DIG_G   *Begin isolating chars
000011A4                           199              
000011A4  E999                     200  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011A6                           201              
000011A6  2401                     202              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011A8                           203              
000011A8  163C 001C                204              MOVE.B      #28,D3      *Shift left 28 times
000011AC  E7AA                     205              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011AE  E99A                     206              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B0                           207              
000011B0  0C02 0009                208              CMPI.B      #$9,D2      *Is it a number?
000011B4  6F00 0006                209              BLE         NUM_G       *If it is, process number
000011B8  6000 000A                210              BRA         LET_G       *If not, process letter
000011BC                           211              
000011BC  0602 0030                212  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
000011C0  6000 000A                213              BRA         ADD_CHAR_G  *add to strings and continue
000011C4                           214              
000011C4  0602 0037                215  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
000011C8  6000 0002                216              BRA         ADD_CHAR_G  *add to strings and continue
000011CC                           217  
000011CC  18C2                     218  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
000011CE  5300                     219              SUBI.B      #$1,D0      *decrement counter
000011D0  0C00 0000                220              CMPI.B      #$0,D0      *Check if we're done            
000011D4  6ECE                     221              BGT         ISO_DIG_G    *If not, continue tranlation   
000011D6                           222              
000011D6  4E75                     223              RTS
000011D8                           224              
000011D8                           225  *-------------------H2A_B_ADDR-------------------------------            
000011D8  4280                     226  H2A_B_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
000011DA  4281                     227              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011DC  4282                     228              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011DE  4283                     229              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E0  220D                     230              MOVE.L      A5,D1       *Copy address into D1
000011E2  5581                     231              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011E4  103C 0008                232              MOVE.B      #$8,D0      *Counter
000011E8  6000 0002                233              BRA         ISO_DIG_B   *Begin isolating chars
000011EC                           234              
000011EC  E999                     235  ISO_DIG_B   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011EE                           236              
000011EE  2401                     237              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F0                           238              
000011F0  163C 001C                239              MOVE.B      #28,D3      *Shift left 28 times
000011F4  E7AA                     240              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011F6  E99A                     241              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011F8                           242              
000011F8  0C02 0009                243              CMPI.B      #$9,D2      *Is it a number?
000011FC  6F00 0006                244              BLE         NUM_B       *If it is, process number
00001200  6000 000A                245              BRA         LET_B       *If not, process letter
00001204                           246              
00001204  0602 0030                247  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
00001208  6000 000A                248              BRA         ADD_CHAR_B  *add to strings and continue
0000120C                           249              
0000120C  0602 0037                250  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
00001210  6000 0002                251              BRA         ADD_CHAR_B  *add to strings and continue
00001214                           252  
00001214  16C2                     253  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to the good data string
00001216  5300                     254              SUBI.B      #$1,D0      *decrement counter
00001218  0C00 0000                255              CMPI.B      #$0,D0      *Check if we're done            
0000121C  6ECE                     256              BGT         ISO_DIG_B    *If not, continue tranlation   
0000121E                           257              
0000121E  4E75                     258              RTS
00001220                           259              
00001220                           260  *-------------------H2A_B_OP--------------------------------
00001220  4280                     261  H2A_B_OP    CLR.L       D0          *Make sure D0 is empty (Counter)
00001222  4281                     262              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001224  4282                     263              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001226  4283                     264              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001228  3207                     265              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000122A  103C 0004                266              MOVE.B      #$4,D0      *Counter
0000122E  6000 0002                267              BRA         ISODIG_BO   *Begin isolating chars
00001232                           268              
00001232  E959                     269  ISODIG_BO   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001234                           270              
00001234  2401                     271              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
00001236                           272              
00001236  163C 001C                273              MOVE.B      #28,D3      *Shift left 28 times
0000123A  E7AA                     274              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
0000123C  E99A                     275              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
0000123E                           276              
0000123E  0C02 0009                277              CMPI.B      #$9,D2      *Is it a number?
00001242  6F00 0006                278              BLE         NUM_BO      *If it is, process number
00001246  6000 000A                279              BRA         LET_BO      *If not, process letter
0000124A                           280  
0000124A  0602 0030                281  NUM_BO      ADDI.B      #$30,D2     *Make it an ascii number
0000124E  6000 000A                282              BRA         ADD_CHAR_BO *add to strings and continue
00001252                           283              
00001252  0602 0037                284  LET_BO      ADDI.B      #$37,D2     *Make it an ascii letter
00001256  6000 0002                285              BRA         ADD_CHAR_BO *add to strings and continue
0000125A                           286              
0000125A  16C2                     287  ADD_CHAR_BO MOVE.B      D2,(A3)+    *Add to bad data string
0000125C  5300                     288              SUBI.B      #$1,D0      *decrement counter
0000125E  0C00 0000                289              CMPI.B      #$0,D0      *Check if we're done            
00001262  6ECE                     290              BGT         ISODIG_BO  *If not, continue tranlation   
00001264                           291              
00001264  4E75                     292              RTS
00001266                           293              
00001266                           294  *-------------------PRINT_G---------------------------------
00001266  18FC 0020                295  PRINT_G     MOVE.B      #' ',(A4)+
0000126A  16FC 0000                296              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
0000126E  43F9 000024AA            297              LEA         GOOD_STR,A1 *Load good data for printing
00001274  103C 000D                298              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001278  4E4F                     299              TRAP        #15         *Display string
0000127A                           300            
0000127A  4E75                     301              RTS 
0000127C                           302  
0000127C                           303  *-------------------PRINT_B---------------------------------
0000127C  18FC 0020                304  PRINT_B     MOVE.B      #' ',(A4)+
00001280  18FC 0000                305              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001284  43F9 0000246A            306              LEA         BAD_STR,A1  *Load good data for printing
0000128A  103C 000D                307              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000128E  4E4F                     308              TRAP        #15         *Display string
00001290                           309              
00001290  4E75                     310              RTS 
00001292                           311  *-------------------PRG_RESET-------------------------------
00001292  2E7C 01000000            312  PRG_RESET   MOVEA.L     #$01000000,A7   *Reset the stack pointer
00001298                           313              
00001298  207C 00000000            314              MOVEA.L     #$00000000,A0   *Clear Address Registers
0000129E  227C 00000000            315              MOVEA.L     #$00000000,A1
000012A4  247C 00000000            316              MOVEA.L     #$00000000,A2
000012AA  267C 00000000            317              MOVEA.L     #$00000000,A3
000012B0  287C 00000000            318              MOVEA.L     #$00000000,A4
000012B6  2A7C 00000000            319              MOVEA.L     #$00000000,A5
000012BC  2C7C 00000000            320              MOVEA.L     #$00000000,A6
000012C2                           321              
000012C2  4280                     322              CLR.L       D0              *Reset Data registers
000012C4  4281                     323              CLR.L       D1
000012C6  4282                     324              CLR.L       D2
000012C8  4283                     325              CLR.L       D3
000012CA  4284                     326              CLR.L       D4
000012CC  4285                     327              CLR.L       D5
000012CE  4286                     328              CLR.L       D6
000012D0  4287                     329              CLR.L       D7
000012D2                           330  
000012D2  103C 000B                331              MOVE.B      #11,D0          *Clear Screen
000012D6  323C FF00                332              MOVE.W      #$FF00,D1
000012DA  4E4F                     333              TRAP        #15
000012DC                           334              
000012DC  4281                     335              CLR.L       D1
000012DE                           336              
000012DE  4EF8 1000                337              JMP         START           *Restart the program
000012E2                           338  
000012E2                           339  *-------------------END_OPT---------------------------------
000012E2  43F9 000023D1            340  END_OPT     LEA         END_PGR,A1  *Display Ending messages
000012E8  4280                     341              CLR.L       D0          
000012EA  103C 000E                342              MOVE.B      #14,D0      
000012EE  4E4F                     343              TRAP        #15             
000012F0                           344              
000012F0  103C 0005                345              MOVE.B      #5,D0       *Single char trap task
000012F4  4E4F                     346              TRAP        #15         
000012F6                           347              
000012F6  B23C 0020                348              CMP.B       #$20,D1     *Check if SPACE key was pressed
000012FA  6796                     349              BEQ         PRG_RESET   *Decode another memory image if enter is pressed
000012FC                           350              
000012FC  B23C 001B                351              CMP.B       #$1B,D1     *Check if ESC key was pressed
00001300  6700 0004                352              BEQ         DONE        *End program
00001304                           353              
00001304  60DC                     354              BRA         END_OPT     *Else, loop (force space or esc)
00001306                           355              
00001306                           356  *-----------------------DONE--------------------------------
00001306  103C 0009                357  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
0000130A  4E4F                     358              TRAP        #15         *Halt program, Trap#15 task 9
0000130C                           359              
0000130C                           360  *---------------Variables and Constants---------------------
0000130C                           361              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
0000130C                           362  
0000130C                           363  
0000130C  4282                     364  JMP_TBL     CLR.L       D2
0000130E  3407                     365              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001310  4281                     366              CLR.L       D1
00001312  123C 000C                367              MOVE.B      #12,D1      *Moves 12 into D1
00001316  E26A                     368              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
00001318                           369                          
00001318  B43C 0000                370  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
0000131C  6600 000A                371              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001320  4EB9 00001458            372              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
00001326  4E75                     373              RTS                     *Finished all jumping; whole instruction should be identified at this point
00001328                           374              
00001328  B43C 0001                375  JMP_1       CMP.B       #$1,D2
0000132C  6600 000A                376              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00001330  4EB9 00001664            377              JSR         OPC_MOVEB   *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_MOVEB in OPCODE table.
00001336  4E75                     378              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
00001338                           379             
00001338  B43C 0002                380  JMP_2       CMP.B       #$2,D2
0000133C  6600 000A                381              BNE         JMP_3 
00001340  4EB9 00001482            382              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
00001346  4E75                     383              RTS
00001348                           384              
00001348  B43C 0003                385  JMP_3       CMP.B       #$3,D2
0000134C  6600 000A                386              BNE         JMP_4
00001350  4EB9 000014A6            387              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
00001356  4E75                     388              RTS
00001358                           389           
00001358  B43C 0004                390  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
0000135C  6600 000A                391              BNE         JMP_5
00001360  4EB9 000014CA            392              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
00001366  4E75                     393              RTS
00001368                           394              
00001368  B43C 0005                395  JMP_5       CMP.B       #$5,D2
0000136C  6600 000A                396              BNE         JMP_6
00001370  4EB9 00001688            397              JSR         OPC_ADDQ    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_ADDQ in OPCODE table.
00001376  4E75                     398              RTS
00001378                           399              
00001378  B43C 0006                400  JMP_6       CMP.B       #$6,D2
0000137C  6600 000A                401              BNE         JMP_7
00001380  4EB9 00001508            402              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
00001386  4E75                     403              RTS
00001388                           404              
00001388  B43C 0007                405  JMP_7       CMP.B       #$7,D2
0000138C  6600 000A                406              BNE         JMP_8
00001390  4EB9 000016B0            407              JSR         OPC_MOVEQ    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_MOVEQ in OPCODE table.
00001396  4E75                     408              RTS
00001398                           409              
00001398  B43C 0008                410  JMP_8       CMP.B       #$8,D2
0000139C  6600 000A                411              BNE         JMP_9
000013A0  4EB9 0000152C            412              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000013A6  4E75                     413              RTS
000013A8                           414              
000013A8  B43C 0009                415  JMP_9       CMP.B       #$9,D2
000013AC  6600 000A                416              BNE         JMP_A
000013B0  4EB9 000016CC            417              JSR         OPC_SUB    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000013B6  4E75                     418              RTS
000013B8                           419              
000013B8  B43C 000A                420  JMP_A       CMP.B       #$A,D2
000013BC  6600 0008                421              BNE         JMP_B
000013C0  4EB8 10EC                422              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
000013C4  4E75                     423              RTS
000013C6                           424              
000013C6  B43C 000B                425  JMP_B       CMP.B       #$B,D2
000013CA  6600 0008                426              BNE         JMP_C
000013CE  4EB8 10EC                427              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000013D2  4E75                     428              RTS
000013D4                           429              
000013D4  B43C 000C                430  JMP_C       CMP.B       #$C,D2
000013D8  6600 000A                431              BNE         JMP_D
000013DC  4EB9 00001550            432              JSR         JMP_CX
000013E2                           433        *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000013E2  4E75                     434              RTS
000013E4                           435              
000013E4  B43C 000D                436  JMP_D       CMP.B       #$D,D2
000013E8  6600 000A                437              BNE         JMP_E   
000013EC  4EB9 00001574            438              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000013F2  4E75                     439              RTS
000013F4                           440              
000013F4  B43C 000F                441  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
000013F8  6700 FCF2                442              BEQ         INVALID     *If first hex value is F, jump to INVALID
000013FC  4EB9 000015D8            443              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001402                           444              
00001402  4EF8 10EC                445              JMP         INVALID     *Got here? Must be invalid.
00001406  4E75                     446              RTS
00001408                           447   
00001408  4282                     448  J_CLR4      CLR.L       D2                                
0000140A  3407                     449              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000140C  4281                     450              CLR.L       D1
0000140E  E94A                     451              LSL.W       #4,D2       *Clear the most sig hex digit
00001410  123C 000C                452              MOVE.B      #12,D1      *Moves 12 into D1
00001414  E26A                     453              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001416  4E75                     454              RTS                     *Return back to JMP_Xn    
00001418                           455              
00001418  4282                     456  J_CLR3      CLR.L       D2          
0000141A  3407                     457              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000141C  4281                     458              CLR.L       D1
0000141E  E94A                     459              LSL.W       #4,D2       *Clear the most sig hex digit
00001420  123C 000D                460              MOVE.B      #13,D1      *Moves 13 into D1
00001424  E26A                     461              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001426  4E75                     462              RTS                     *Return back to JMP_Xn  
00001428                           463  
00001428  4282                     464  J_CLR2  CLR.L       D2          
0000142A  3407                     465          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
0000142C  4281                     466          CLR.L       D1
0000142E  E14A                     467          LSL.W       #8,D2           *Clear the most sig 7 bits
00001430  123C 000E                468          MOVE.B      #14,D1          *Moves 16 into D1
00001434  E26A                     469          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001436  4E75                     470          RTS     
00001438                           471  
00001438  4282                     472  J_CLR1  CLR.L       D2          
0000143A  3407                     473          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
0000143C  4281                     474          CLR.L       D1
0000143E  EF4A                     475          LSL.W       #7,D2           *Clear the most sig 7 bits
00001440  123C 000F                476          MOVE.B      #15,D1          *Moves 16 into D1
00001444  E26A                     477          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001446  4E75                     478          RTS                         *Return back to JMP_Xn  
00001448                           479       
00001448  4282                     480  J_CLR_DM    CLR.L       D2          
0000144A  3407                     481              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000144C  4281                     482              CLR.L       D1
0000144E  EF4A                     483              LSL.W       #7,D2       *Clear the most sig 7 bits
00001450  123C 000D                484              MOVE.B      #13,D1      *Moves 17 into D1
00001454  E26A                     485              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001456  4E75                     486              RTS                     *Return back to JMP_Xn     
00001458                           487   
00001458                           488  
00001458                           489          
00001458  4EB8 1408                490  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
0000145C  B43C 0004                491              CMP.B       #$4,D2      *Is the next hex digit 4?
00001460  6700 0010                492              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00001464  B43C 0006                493              CMP.B       #$6,D2      *Is the next hex digit 5?
00001468  6700 0010                494              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
0000146C  4EB8 10EC                495              JSR         INVALID     *If neither, OPCODE is invalid
00001470  4E75                     496              RTS
00001472                           497  
00001472  4EB9 00001614            498  J_SUBI      JSR         OPC_SUBI    *Jump to OPC_SUBI in OPCODE table
00001478  4E75                     499              RTS
0000147A                           500              
0000147A  4EB9 0000163C            501  J_ADDI      JSR         OPC_ADDI    *Jump to OPC_ADDI in OPCODE table
00001480  4E75                     502              RTS              
00001482                           503  
00001482                           504  
00001482  4EB8 1448                505  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
00001486  B43C 0001                506              CMP.B       #$1,D2      *is the DEST MODE 1?
0000148A  6700 000A                507              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
0000148E  4EB9 0000149E            508              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
00001494  4E75                     509              RTS
00001496                           510  
00001496  4EB9 0000170E            511  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
0000149C  4E75                     512              RTS
0000149E                           513  
0000149E  4EB9 0000173A            514  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000014A4  4E75                     515              RTS                           
000014A6                           516              
000014A6  4EB8 1448                517  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014AA  B43C 0001                518              CMP.B       #$1,D2      *is the DEST MODE 1?
000014AE  6700 000A                519              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000014B2  4EB9 000014C2            520              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000014B8  4E75                     521              RTS
000014BA                           522  
000014BA  4EB9 00001762            523  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000014C0  4E75                     524              RTS
000014C2                           525  
000014C2  4EB9 0000178E            526  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
000014C8  4E75                     527              RTS
000014CA  4EB8 1408                528  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
000014CE  B43C 000E                529              CMP.B       #$E,D2      *Is the next hex digit E?
000014D2  6700 001C                530              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
000014D6  4EB8 1438                531              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
000014DA  B43C 0001                532              CMP.B       #1,D2       *Is the last bit 1?
000014DE  6700 0018                533              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
000014E2  B43C 0000                534              CMP.B       #0,D2       *Is the last bit 0?
000014E6  6700 0018                535              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
000014EA  4EB8 10EC                536              JSR         INVALID     *If none of the above, OPCODE is invalid
000014EE  4E75                     537              RTS                                         
000014F0                           538              
000014F0  4EB9 000015DC            539  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
000014F6  4E75                     540              RTS
000014F8                           541              
000014F8  4EB9 000016EA            542  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
000014FE  4E75                     543              RTS
00001500                           544              
00001500  4EB9 0000170C            545  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001506  4E75                     546              RTS
00001508                           547              
00001508  4EB8 1408                548  JMP_6X      JSR         J_CLR4       *Isolate next hex digit 
0000150C  B43C 0000                549              CMP.B       #0,D2        *Is the next hex digit 0?
00001510  6700 000A                550              BEQ         J_BRA        *Instruction is determined to be BRA. Jump to intermediate OPCODE table jump
00001514  4EB9 00001524            551              JSR         J_Bcc        *Otherwise, Instruction is determined to be some form of Bcc. Jump to intermediate OPCODE table jump
0000151A  4E75                     552              RTS
0000151C                           553              
0000151C  4EB9 000017B6            554  J_BRA       JSR         OPC_BRA      *Jump to OPC_BRA in the OPCODE table  
00001522                           555  
00001522  4E75                     556              RTS
00001524                           557  
00001524  4EB9 000017D2            558  J_Bcc       JSR         OPC_Bcc      *Jump to OPC_Bcc in the OPCODE table  
0000152A                           559  
0000152A  4E75                     560              RTS
0000152C                           561              
0000152C  4EB8 1448                562  JMP_8X      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
00001530  B43C 0003                563              CMP.B       #3,D2       *Are the bits equivalent to $3?
00001534  6700 000A                564              BEQ         J_DIVU      *Instruction is determined to be DIVU. Jump to intermediate OPCODE table jump
00001538  4EB9 00001548            565              JSR         J_OR        *Otherwise, Instruction is determined to be OR. Jump to intermediate OPCODE table jump
0000153E  4E75                     566              RTS
00001540                           567  
00001540  4EB9 000017DE            568  J_DIVU      JSR         OPC_DIVU    *Jump to OPC_DIVU in the OPCODE table  
00001546  4E75                     569              RTS
00001548                           570              
00001548  4EB9 00001804            571  J_OR        JSR         OPC_OR      *Jump to OPC_OR in the OPCODE table  
0000154E  4E75                     572              RTS
00001550                           573  
00001550  4EB8 1448                574  JMP_CX      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
00001554  B43C 0007                575              CMP.B       #7,D2       *Are the bits equivalent to $7?
00001558  6700 000A                576              BEQ         J_MULS      *Instruction is determined to be MULS. Jump to intermediate OPCODE table jump
0000155C  4EB9 0000156C            577              JSR         J_AND       *Otherwise, Instruction is determined to be AND. Jump to intermediate OPCODE table jump
00001562  4E75                     578              RTS
00001564                           579  
00001564  4EB9 0000181E            580  J_MULS      JSR         OPC_MULS    *Jump to OPC_MULS in the OPCODE table  
0000156A  4E75                     581              RTS
0000156C                           582              
0000156C  4EB9 00001844            583  J_AND       JSR         OPC_AND     *Jump to OPC_AND in the OPCODE table  
00001572  4E75                     584              RTS
00001574                           585  
00001574  4EB8 1448                586  JMP_DX      JSR         J_CLR_DM    *Isolate OPMODE bits to determine if ADD or ADDA
00001578  4284                     587              CLR.L       D4          *For adding size (easy to do it here).
0000157A  183C 0001                588              MOVE.B      #1,D4       *Set size to WORD
0000157E  B43C 0003                589              CMP.B       #3,D2       *Is it Word ADDA?
00001582  6700 0044                590              BEQ         OP_ADDA
00001586  183C 0002                591              MOVE.B      #2,D4       *set size to LONG
0000158A  B43C 0007                592              CMP.B       #7,D2       *is it Long ADDA?
0000158E  6700 0038                593              BEQ         OP_ADDA
00001592                           594              
00001592  4284                     595              CLR.L       D4          *Not ADDA? Clear the manual size sets
00001594                           596              
00001594  B83C 0000                597              CMP.B       #0,D4       Is it ADD?
00001598  6700 0036                598              BEQ         OP_ADD
0000159C  B83C 0001                599              CMP.B       #1,D4       
000015A0  6700 002E                600              BEQ         OP_ADD
000015A4  B83C 0002                601              CMP.B       #2,D4       
000015A8  6700 0026                602              BEQ         OP_ADD
000015AC  B83C 0004                603              CMP.B       #4,D4 
000015B0  6700 001E                604              BEQ         OP_ADD
000015B4  B83C 0005                605              CMP.B       #5,D4     
000015B8  6700 0016                606              BEQ         OP_ADD
000015BC  B83C 0006                607              CMP.B       #6,D4     
000015C0  6700 000E                608              BEQ         OP_ADD       
000015C4                           609           
000015C4  6000 FB26                610              BRA         INVALID     *Got here, must be invalid data.    
000015C8                           611              
000015C8  4EB9 00001862            612  OP_ADDA     JSR         OPC_ADDA
000015CE  4E75                     613              RTS
000015D0                           614              
000015D0  4EB9 00001884            615  OP_ADD      JSR         OPC_ADD
000015D6  4E75                     616              RTS
000015D8                           617  
000015D8                           618  
000015D8  4EF8 10EC                619  JMP_EX      JMP         INVALID     
000015DC                           620  
000015DC                           621     
000015DC  BE7C 4E71                622  JMP_47X     CMP.W       #$4E71,D7    *Is it NOP?
000015E0  6700 001A                623              BEQ         O_NOP
000015E4  BE7C 4E75                624              CMP.W       #$4E75,D7       *Is it RTS?
000015E8  6700 001A                625              BEQ         O_RTS
000015EC  4EB8 1428                626              JSR         J_CLR2       *Isolate the 6th and 7th bit
000015F0  B43C 0002                627              CMP.B       #2,D2        *Is it JSR?
000015F4  6700 0016                628              BEQ         O_JSR
000015F8  4EF8 10EC                629              JMP         INVALID      *Got here? Must be invalid data.
000015FC                           630  
000015FC  4EB9 000018BE            631  O_NOP       JSR         OPC_NOP
00001602  4E75                     632              RTS
00001604                           633  
00001604  4EB9 000018CC            634  O_RTS       JSR         OPC_RTS
0000160A  4E75                     635              RTS
0000160C                           636  
0000160C  4EB9 000018A2            637  O_JSR       JSR         OPC_JSR
00001612  4E75                     638              RTS
00001614                           639           
00001614                           640  
00001614                           641  
00001614  18FC 0053                642  OPC_SUBI    MOVE.B      #'S',(A4)+
00001618  18FC 0055                643              MOVE.B      #'U',(A4)+
0000161C  18FC 0042                644              MOVE.B      #'B',(A4)+
00001620  18FC 0049                645              MOVE.B      #'I',(A4)+
00001624  18FC 002E                646              MOVE.B      #'.',(A4)+
00001628                           647              
00001628  4EB9 00001B06            648              JSR         GET_SIZE_2  *Get 2 bit size code
0000162E  4EB9 00001AB4            649              JSR         ADD_SIZE    *Add the size character based on size code
00001634                           650              
00001634  4EB9 00001C1A            651              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
0000163A                           652              
0000163A  4E75                     653              RTS
0000163C                           654  
0000163C  18FC 0041                655  OPC_ADDI    MOVE.B      #'A',(A4)+
00001640  18FC 0044                656              MOVE.B      #'D',(A4)+
00001644  18FC 0044                657              MOVE.B      #'D',(A4)+
00001648  18FC 0049                658              MOVE.B      #'I',(A4)+
0000164C  18FC 002E                659              MOVE.B      #'.',(A4)+
00001650                           660              
00001650  4EB9 00001B06            661              JSR         GET_SIZE_2  *Get 2 bit size code
00001656  4EB9 00001AB4            662              JSR         ADD_SIZE    *Add the size character based on size code
0000165C                           663              
0000165C  4EB9 00001C1A            664              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
00001662                           665              
00001662  4E75                     666              RTS
00001664                           667  
00001664  18FC 004D                668  OPC_MOVEB   MOVE.B      #'M',(A4)+
00001668  18FC 004F                669              MOVE.B      #'O',(A4)+
0000166C  18FC 0056                670              MOVE.B      #'V',(A4)+
00001670  18FC 0045                671              MOVE.B      #'E',(A4)+
00001674  18FC 002E                672              MOVE.B      #'.',(A4)+
00001678                           673  
00001678                           674  
00001678  4284                     675              CLR.L       D4          *Manually set size to byte (D4 = 0)
0000167A  4EB9 00001AB4            676              JSR         ADD_SIZE    *Add size characters
00001680                           677              
00001680  4EB9 00001CB0            678              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001686                           679              
00001686  4E75                     680              RTS
00001688                           681  
00001688  18FC 0041                682  OPC_ADDQ    MOVE.B      #'A',(A4)+
0000168C  18FC 0044                683              MOVE.B      #'D',(A4)+
00001690  18FC 0044                684              MOVE.B      #'D',(A4)+
00001694  18FC 0051                685              MOVE.B      #'Q',(A4)+
00001698  18FC 002E                686              MOVE.B      #'.',(A4)+
0000169C                           687  
0000169C  4EB9 00001B06            688              JSR         GET_SIZE_2   *Get size code (placed in D4)
000016A2  4EB9 00001AB4            689              JSR         ADD_SIZE     *Add size character to string (B/W/L)
000016A8                           690              
000016A8  4EB9 00001C66            691              JSR         ADDQ_EA      *Start the EA/operand decode logic
000016AE                           692   
000016AE  4E75                     693              RTS
000016B0                           694  
000016B0  18FC 004D                695  OPC_MOVEQ   MOVE.B      #'M',(A4)+
000016B4  18FC 004F                696              MOVE.B      #'O',(A4)+
000016B8  18FC 0056                697              MOVE.B      #'V',(A4)+
000016BC  18FC 0045                698              MOVE.B      #'E',(A4)+
000016C0  18FC 0051                699              MOVE.B      #'Q',(A4)+
000016C4                           700              
000016C4  4EB9 00001C32            701              JSR         MOVEQ_EA     *Start the EA/opderand decode logic for moveq
000016CA                           702            
000016CA  4E75                     703              RTS
000016CC                           704  
000016CC  18FC 0053                705  OPC_SUB     MOVE.B      #'S',(A4)+
000016D0  18FC 0055                706              MOVE.B      #'U',(A4)+
000016D4  18FC 0042                707              MOVE.B      #'B',(A4)+
000016D8  18FC 002E                708              MOVE.B      #'.',(A4)+
000016DC                           709  
000016DC  4EB9 00001AF6            710              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000016E2                           711              
000016E2  4EB9 00001B2C            712              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
000016E8                           713  
000016E8  4E75                     714              RTS
000016EA                           715  
000016EA  18FC 004C                716  OPC_LEA     MOVE.B      #'L',(A4)+
000016EE  18FC 0045                717              MOVE.B      #'E',(A4)+
000016F2  18FC 0041                718              MOVE.B      #'A',(A4)+
000016F6  18FC 0020                719              MOVE.B      #' ',(A4)+
000016FA  18FC 0020                720              MOVE.B      #' ',(A4)+
000016FE                           721              
000016FE  4284                     722              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001700  183C 0002                723              MOVE.B      #2,D4       *Manually set size to long.
00001704                           724              
00001704  4EB9 00001BEE            725              JSR         EASRC_ADES
0000170A                           726              
0000170A  4E75                     727              RTS
0000170C                           728              
0000170C  4E75                     729  OPC_MOVEM   RTS
0000170E                           730  
0000170E                           731  
0000170E  18FC 004D                732  OPC_MOVEAL  MOVE.B      #'M',(A4)+
00001712  18FC 004F                733              MOVE.B      #'O',(A4)+
00001716  18FC 0056                734              MOVE.B      #'V',(A4)+
0000171A  18FC 0045                735              MOVE.B      #'E',(A4)+
0000171E  18FC 0041                736              MOVE.B      #'A',(A4)+
00001722  18FC 002E                737              MOVE.B      #'.',(A4)+
00001726                           738  
00001726  4284                     739              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001728  183C 0002                740              MOVE.B      #2,D4       *Set size code to long
0000172C  4EB9 00001AB4            741              JSR         ADD_SIZE    *Add size characters
00001732                           742              
00001732  4EB9 00001CB0            743              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001738  4E75                     744              RTS
0000173A                           745  
0000173A                           746  
0000173A  18FC 004D                747  OPC_MOVEL   MOVE.B      #'M',(A4)+
0000173E  18FC 004F                748              MOVE.B      #'O',(A4)+
00001742  18FC 0056                749              MOVE.B      #'V',(A4)+
00001746  18FC 0045                750              MOVE.B      #'E',(A4)+
0000174A  18FC 002E                751              MOVE.B      #'.',(A4)+
0000174E                           752  
0000174E  4284                     753              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001750  183C 0002                754              MOVE.B      #2,D4       *Set size code to long
00001754  4EB9 00001AB4            755              JSR         ADD_SIZE    *Add size characters
0000175A                           756              
0000175A  4EB9 00001CB0            757              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001760  4E75                     758              RTS
00001762                           759  
00001762  18FC 004D                760  OPC_MOVEAW  MOVE.B      #'M',(A4)+
00001766  18FC 004F                761              MOVE.B      #'O',(A4)+
0000176A  18FC 0056                762              MOVE.B      #'V',(A4)+
0000176E  18FC 0045                763              MOVE.B      #'E',(A4)+
00001772  18FC 0041                764              MOVE.B      #'A',(A4)+
00001776  18FC 002E                765              MOVE.B      #'.',(A4)+
0000177A                           766  
0000177A  4284                     767              CLR.L       D4          *Manually set size to byte (D4 = 0)
0000177C  183C 0001                768              MOVE.B      #1,D4       *Set size code to word
00001780  4EB9 00001AB4            769              JSR         ADD_SIZE    *Add size characters
00001786                           770              
00001786  4EB9 00001CB0            771              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
0000178C  4E75                     772              RTS
0000178E                           773  
0000178E                           774  
0000178E  18FC 004D                775  OPC_MOVEW   MOVE.B      #'M',(A4)+
00001792  18FC 004F                776              MOVE.B      #'O',(A4)+
00001796  18FC 0056                777              MOVE.B      #'V',(A4)+
0000179A  18FC 0045                778              MOVE.B      #'E',(A4)+
0000179E  18FC 002E                779              MOVE.B      #'.',(A4)+
000017A2                           780  
000017A2  4284                     781              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017A4  183C 0001                782              MOVE.B      #1,D4       *Set size code to word
000017A8  4EB9 00001AB4            783              JSR         ADD_SIZE    *Add size characters
000017AE                           784              
000017AE  4EB9 00001CB0            785              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017B4  4E75                     786              RTS
000017B6                           787  
000017B6                           788  
000017B6  18FC 0042                789  OPC_BRA     MOVE.B      #'B',(A4)+
000017BA  18FC 0052                790              MOVE.B      #'R',(A4)+
000017BE  18FC 0041                791              MOVE.B      #'A',(A4)+
000017C2  18FC 0020                792              MOVE.B      #' ',(A4)+
000017C6  18FC 0020                793              MOVE.B      #' ',(A4)+
000017CA                           794              
000017CA  4EB9 00001E34            795              JSR         ABW       *Grab the next word value (BRA bug)
000017D0                           796                          
000017D0  4E75                     797              RTS
000017D2                           798  
000017D2  18FC 0042                799  OPC_Bcc     MOVE.B      #'B',(A4)+
000017D6                           800              *BCC bug, does not use 8bit displacment, but is next word value (ABSW)
000017D6  4EB9 000018DA            801              JSR         BCC_CODE    *Get condition code and start decoding
000017DC                           802              
000017DC  4E75                     803              RTS
000017DE                           804  
000017DE  18FC 0044                805  OPC_DIVU    MOVE.B      #'D',(A4)+
000017E2  18FC 0049                806              MOVE.B      #'I',(A4)+
000017E6  18FC 0056                807              MOVE.B      #'V',(A4)+
000017EA  18FC 0055                808              MOVE.B      #'U',(A4)+
000017EE  18FC 0020                809              MOVE.B      #' ',(A4)+
000017F2  18FC 0020                810              MOVE.B      #' ',(A4)+
000017F6                           811              
000017F6  4284                     812              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017F8  183C 0001                813              MOVE.B      #1,D4       *Set size code to word
000017FC                           814              
000017FC  4EB9 00001BD8            815              JSR         EASRC_DDES  *Start operand <ea>,Dn
00001802                           816              
00001802                           817              
00001802  4E75                     818              RTS
00001804                           819  
00001804  18FC 004F                820  OPC_OR      MOVE.B      #'O',(A4)+
00001808  18FC 0052                821              MOVE.B      #'R',(A4)+
0000180C  18FC 002E                822              MOVE.B      #'.',(A4)+
00001810                           823  
00001810  4EB9 00001AF6            824              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001816                           825              
00001816  4EB9 00001B2C            826              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
0000181C                           827  
0000181C  4E75                     828              RTS
0000181E                           829  
0000181E  18FC 004D                830  OPC_MULS    MOVE.B      #'M',(A4)+
00001822  18FC 0055                831              MOVE.B      #'U',(A4)+
00001826  18FC 004C                832              MOVE.B      #'L',(A4)+
0000182A  18FC 0053                833              MOVE.B      #'S',(A4)+
0000182E  18FC 0020                834              MOVE.B      #' ',(A4)+
00001832  18FC 0020                835              MOVE.B      #' ',(A4)+
00001836                           836              
00001836  4284                     837              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001838  183C 0001                838              MOVE.B      #1,D4       *Set size code to word
0000183C                           839              
0000183C  4EB9 00001BD8            840              JSR         EASRC_DDES  *Jump to <ea>,Dn
00001842                           841              
00001842  4E75                     842              RTS
00001844                           843  
00001844  18FC 0041                844  OPC_AND     MOVE.B      #'A',(A4)+
00001848  18FC 004E                845              MOVE.B      #'N',(A4)+
0000184C  18FC 0044                846              MOVE.B      #'D',(A4)+
00001850  18FC 002E                847              MOVE.B      #'.',(A4)+
00001854                           848  
00001854  4EB9 00001AF6            849              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
0000185A                           850              
0000185A  4EB9 00001B2C            851              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
00001860                           852  
00001860  4E75                     853              RTS
00001862                           854              
00001862  18FC 0041                855  OPC_ADDA    MOVE.B      #'A',(A4)+
00001866  18FC 0044                856              MOVE.B      #'D',(A4)+
0000186A  18FC 0044                857              MOVE.B      #'D',(A4)+
0000186E  18FC 0041                858              MOVE.B      #'A',(A4)+
00001872  18FC 002E                859              MOVE.B      #'.',(A4)+
00001876                           860              
00001876  4EB9 00001AB4            861              JSR         ADD_SIZE    *Size should already be in D4 (special case for ADDA)
0000187C                           862              
0000187C  4EB9 00001BEE            863              JSR         EASRC_ADES  *Start operand decode for <ea>,An format
00001882                           864              
00001882  4E75                     865              RTS
00001884                           866  
00001884  18FC 0041                867  OPC_ADD     MOVE.B      #'A',(A4)+
00001888  18FC 0044                868              MOVE.B      #'D',(A4)+
0000188C  18FC 0044                869              MOVE.B      #'D',(A4)+
00001890  18FC 002E                870              MOVE.B      #'.',(A4)+
00001894                           871  
00001894  4EB9 00001AF6            872              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
0000189A                           873              
0000189A  4EB9 00001B2C            874              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
000018A0                           875  
000018A0  4E75                     876              RTS
000018A2                           877  
000018A2  18FC 004A                878  OPC_JSR     MOVE.B      #'J',(A4)+
000018A6  18FC 0053                879              MOVE.B      #'S',(A4)+
000018AA  18FC 0052                880              MOVE.B      #'R',(A4)+
000018AE  18FC 0020                881              MOVE.B      #' ',(A4)+
000018B2  18FC 0020                882              MOVE.B      #' ',(A4)+
000018B6  4EB9 00001C8E            883              JSR         GEN_EA_CODE *Get EA code
000018BC                           884              
000018BC  4E75                     885              RTS
000018BE                           886  
000018BE  18FC 004E                887  OPC_NOP     MOVE.B      #'N',(A4)+
000018C2  18FC 004F                888              MOVE.B      #'O',(A4)+
000018C6  18FC 0050                889              MOVE.B      #'P',(A4)+
000018CA                           890              
000018CA  4E75                     891              RTS
000018CC                           892  
000018CC  18FC 0052                893  OPC_RTS     MOVE.B      #'R',(A4)+
000018D0  18FC 0054                894              MOVE.B      #'T',(A4)+
000018D4  18FC 0053                895              MOVE.B      #'S',(A4)+
000018D8                           896              
000018D8  4E75                     897              RTS
000018DA                           898  
000018DA                           899  
000018DA  4283                     900  BCC_CODE    CLR.L       D3          *Make sure D3 is empty to hold condition code
000018DC  3607                     901              MOVE.W      D7,D3       *Move in original address to be shifted
000018DE  E94B                     902              LSL.W       #4,D3
000018E0  4282                     903              CLR.L       D2
000018E2  143C 000C                904              MOVE.B      #12,D2
000018E6  E46B                     905              LSR.W       D2,D3
000018E8  4EB9 000018F0            906              JSR         BCC_TABLE   *Jump to BCC table now that condition code is in D3
000018EE  4E75                     907              RTS
000018F0                           908  
000018F0  B63C 0002                909  BCC_TABLE   CMP.B       #$2,D3      *Is it BHI?
000018F4  6700 006E                910              BEQ         BCC_HI
000018F8  B63C 0003                911              CMP.B       #$3,D3      *Is it BLS?
000018FC  6700 007E                912              BEQ         BCC_LS      
00001900  B63C 0004                913              CMP.B       #$4,D3      *Is it BCC?
00001904  6700 008E                914              BEQ         BCC_CC
00001908  B63C 0005                915              CMP.B       #$5,D3      *Is it BCS?
0000190C  6700 009E                916              BEQ         BCC_CS
00001910  B63C 0006                917              CMP.B       #$6,D3      *Is it BNE?
00001914  6700 00AE                918              BEQ         BCC_NE
00001918  B63C 0007                919              CMP.B       #$7,D3      *Is it BEQ?
0000191C  6700 00BE                920              BEQ         BCC_EQ
00001920  B63C 0008                921              CMP.B       #$8,D3      *Is it BVC?
00001924  6700 00CE                922              BEQ         BCC_VC      
00001928  B63C 0009                923              CMP.B       #$9,D3      *Is it BVS?
0000192C  6700 00DE                924              BEQ         BCC_VS
00001930  B63C 000A                925              CMP.B       #$A,D3      *Is it BPL?
00001934  6700 00EE                926              BEQ         BCC_PL
00001938  B63C 000B                927              CMP.B       #$B,D3      *Is it BMI?
0000193C  6700 00FE                928              BEQ         BCC_MI
00001940  B63C 000C                929              CMP.B       #$C,D3      *Is it BGE?
00001944  6700 010E                930              BEQ         BCC_GE
00001948  B63C 000D                931              CMP.B       #$D,D3      *Is it BLT?
0000194C  6700 011E                932              BEQ         BCC_LT
00001950  B63C 000E                933              CMP.B       #$E,D3      *Is it BGT?
00001954  6700 012E                934              BEQ         BCC_GT      
00001958  B63C 000F                935              CMP.B       #$F,D3      *Is it BLE?
0000195C  6700 013E                936              BEQ         BCC_LE
00001960  4EF8 10EC                937              JMP         INVALID     *Got here? Something is wrong.
00001964                           938  
00001964  18FC 0048                939  BCC_HI      MOVE.B      #'H',(A4)+
00001968  18FC 0049                940              MOVE.B      #'I',(A4)+
0000196C  18FC 0020                941              MOVE.B      #' ',(A4)+
00001970  18FC 0020                942              MOVE.B      #' ',(A4)+
00001974  4EB9 00001E34            943              JSR         ABW         *Add absolute word in next word address.
0000197A  4E75                     944              RTS
0000197C                           945  
0000197C  18FC 004C                946  BCC_LS      MOVE.B      #'L',(A4)+
00001980  18FC 0053                947              MOVE.B      #'S',(A4)+
00001984  18FC 0020                948              MOVE.B      #' ',(A4)+
00001988  18FC 0020                949              MOVE.B      #' ',(A4)+
0000198C  4EB9 00001E34            950              JSR         ABW         *Add absolute word in next word address.
00001992  4E75                     951              RTS
00001994                           952  
00001994  18FC 0043                953  BCC_CC      MOVE.B      #'C',(A4)+
00001998  18FC 0043                954              MOVE.B      #'C',(A4)+
0000199C  18FC 0020                955              MOVE.B      #' ',(A4)+
000019A0  18FC 0020                956              MOVE.B      #' ',(A4)+
000019A4  4EB9 00001E34            957              JSR         ABW         *Add absolute word in next word address.
000019AA  4E75                     958              RTS
000019AC                           959              
000019AC  18FC 0043                960  BCC_CS      MOVE.B      #'C',(A4)+
000019B0  18FC 0053                961              MOVE.B      #'S',(A4)+
000019B4  18FC 0020                962              MOVE.B      #' ',(A4)+
000019B8  18FC 0020                963              MOVE.B      #' ',(A4)+
000019BC  4EB9 00001E34            964              JSR         ABW         *Add absolute word in next word address.
000019C2  4E75                     965              RTS
000019C4                           966              
000019C4  18FC 004E                967  BCC_NE      MOVE.B      #'N',(A4)+
000019C8  18FC 0045                968              MOVE.B      #'E',(A4)+
000019CC  18FC 0020                969              MOVE.B      #' ',(A4)+
000019D0  18FC 0020                970              MOVE.B      #' ',(A4)+
000019D4  4EB9 00001E34            971              JSR         ABW         *Add absolute word in next word address.
000019DA  4E75                     972              RTS
000019DC                           973              
000019DC  18FC 0045                974  BCC_EQ      MOVE.B      #'E',(A4)+
000019E0  18FC 0051                975              MOVE.B      #'Q',(A4)+
000019E4  18FC 0020                976              MOVE.B      #' ',(A4)+
000019E8  18FC 0020                977              MOVE.B      #' ',(A4)+
000019EC  4EB9 00001E34            978              JSR         ABW         *Add absolute word in next word address.
000019F2  4E75                     979              RTS
000019F4                           980              
000019F4  18FC 0056                981  BCC_VC      MOVE.B      #'V',(A4)+
000019F8  18FC 0043                982              MOVE.B      #'C',(A4)+
000019FC  18FC 0020                983              MOVE.B      #' ',(A4)+
00001A00  18FC 0020                984              MOVE.B      #' ',(A4)+
00001A04  4EB9 00001E34            985              JSR         ABW         *Add absolute word in next word address.
00001A0A  4E75                     986              RTS
00001A0C                           987  
00001A0C  18FC 0056                988  BCC_VS      MOVE.B      #'V',(A4)+
00001A10  18FC 0053                989              MOVE.B      #'S',(A4)+
00001A14  18FC 0020                990              MOVE.B      #' ',(A4)+
00001A18  18FC 0020                991              MOVE.B      #' ',(A4)+
00001A1C  4EB9 00001E34            992              JSR         ABW         *Add absolute word in next word address.
00001A22  4E75                     993              RTS
00001A24                           994              
00001A24  18FC 0050                995  BCC_PL      MOVE.B      #'P',(A4)+
00001A28  18FC 004C                996              MOVE.B      #'L',(A4)+
00001A2C  18FC 0020                997              MOVE.B      #' ',(A4)+
00001A30  18FC 0020                998              MOVE.B      #' ',(A4)+
00001A34  4EB9 00001E34            999              JSR         ABW         *Add absolute word in next word address.
00001A3A  4E75                    1000              RTS
00001A3C                          1001              
00001A3C  18FC 004D               1002  BCC_MI      MOVE.B      #'M',(A4)+
00001A40  18FC 0049               1003              MOVE.B      #'I',(A4)+
00001A44  18FC 0020               1004              MOVE.B      #' ',(A4)+
00001A48  18FC 0020               1005              MOVE.B      #' ',(A4)+
00001A4C  4EB9 00001E34           1006              JSR         ABW         *Add absolute word in next word address.
00001A52  4E75                    1007              RTS
00001A54                          1008              
00001A54  18FC 0047               1009  BCC_GE      MOVE.B      #'G',(A4)+
00001A58  18FC 0045               1010              MOVE.B      #'E',(A4)+
00001A5C  18FC 0020               1011              MOVE.B      #' ',(A4)+
00001A60  18FC 0020               1012              MOVE.B      #' ',(A4)+
00001A64  4EB9 00001E34           1013              JSR         ABW         *Add absolute word in next word address.
00001A6A  4E75                    1014              RTS
00001A6C                          1015              
00001A6C  18FC 004C               1016  BCC_LT      MOVE.B      #'L',(A4)+
00001A70  18FC 0054               1017              MOVE.B      #'T',(A4)+
00001A74  18FC 0020               1018              MOVE.B      #' ',(A4)+
00001A78  18FC 0020               1019              MOVE.B      #' ',(A4)+
00001A7C  4EB9 00001E34           1020              JSR         ABW         *Add absolute word in next word address.
00001A82  4E75                    1021              RTS
00001A84                          1022              
00001A84  18FC 0047               1023  BCC_GT      MOVE.B      #'G',(A4)+
00001A88  18FC 0054               1024              MOVE.B      #'T',(A4)+
00001A8C  18FC 0020               1025              MOVE.B      #' ',(A4)+
00001A90  18FC 0020               1026              MOVE.B      #' ',(A4)+
00001A94  4EB9 00001E34           1027              JSR         ABW         *Add absolute word in next word address.
00001A9A  4E75                    1028              RTS
00001A9C                          1029              
00001A9C  18FC 004C               1030  BCC_LE      MOVE.B      #'L',(A4)+
00001AA0  18FC 0045               1031              MOVE.B      #'E',(A4)+
00001AA4  18FC 0020               1032              MOVE.B      #' ',(A4)+
00001AA8  18FC 0020               1033              MOVE.B      #' ',(A4)+
00001AAC  4EB9 00001E34           1034              JSR         ABW         *Add absolute word in next word address.
00001AB2  4E75                    1035              RTS
00001AB4                          1036  
00001AB4  B83C 0000               1037  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn/an
00001AB8  6700 0012               1038              BEQ         B_SIZE
00001ABC  B83C 0001               1039              CMP.B       #1,D4       *Is it a W, <ea>,dn/an
00001AC0  6700 0018               1040              BEQ         W_SIZE
00001AC4  B83C 0002               1041              CMP.B       #2,D4       *Is it a L, <ea>,dn/an
00001AC8  6700 001E               1042              BEQ         L_SIZE 
00001ACC                          1043              
00001ACC  18FC 0042               1044  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
00001AD0  18FC 0020               1045              MOVE.B      #' ',(A4)+
00001AD4  18FC 0020               1046              MOVE.B      #' ',(A4)+
00001AD8  4E75                    1047              RTS
00001ADA                          1048  
00001ADA  18FC 0057               1049  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
00001ADE  18FC 0020               1050              MOVE.B      #' ',(A4)+
00001AE2  18FC 0020               1051              MOVE.B      #' ',(A4)+
00001AE6  4E75                    1052              RTS
00001AE8                          1053  
00001AE8  18FC 004C               1054  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
00001AEC  18FC 0020               1055              MOVE.B      #' ',(A4)+
00001AF0  18FC 0020               1056              MOVE.B      #' ',(A4)+
00001AF4  4E75                    1057              RTS
00001AF6                          1058  
00001AF6  4284                    1059  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001AF8  3807                    1060              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001AFA  EF4C                    1061              LSL.W       #7,D4       *Clear more significant bits
00001AFC  4283                    1062              CLR.L       D3          *Make sure D3 is clear for shifting
00001AFE  163C 000D               1063              MOVE.B      #13,D3      *Shifting 13 times
00001B02  E66C                    1064              LSR.W       D3,D4       *Move size bits to LSB position
00001B04  4E75                    1065              RTS
00001B06                          1066  
00001B06  4284                    1067  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B08  3807                    1068              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B0A  E14C                    1069              LSL.W       #8,D4       *Clear more significant bits
00001B0C  4283                    1070              CLR.L       D3          *Make sure D3 is clear for shifting
00001B0E  163C 000E               1071              MOVE.B      #14,D3      *Shifting 14 times
00001B12  E66C                    1072              LSR.W       D3,D4       *Move size bits to LSB position
00001B14  4E75                    1073              RTS
00001B16                          1074  
00001B16  4284                    1075  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B18  3807                    1076              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B1A  4283                    1077              CLR.L       D3          *Make sure D3 is clear for shifting
00001B1C  163C 0009               1078              MOVE.B      #9,D3       *Shift 9 times to the left
00001B20  E76C                    1079              LSL.W       D3,D4       *Clear more significant bits
00001B22  4283                    1080              CLR.L       D3          *Make sure D3 is clear for shifting
00001B24  163C 000F               1081              MOVE.B      #15,D3      *Shifting 15 times
00001B28  E66C                    1082              LSR.W       D3,D4       *Move size bits to LSB position
00001B2A  4E75                    1083              RTS
00001B2C                          1084  
00001B2C  B83C 0000               1085  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00001B30  6700 002E               1086              BEQ         B_EA
00001B34  B83C 0001               1087              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001B38  6700 003A               1088              BEQ         W_EA
00001B3C  B83C 0002               1089              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001B40  6700 0046               1090              BEQ         L_EA
00001B44                          1091  
00001B44  B83C 0004               1092              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001B48  6700 0052               1093              BEQ         B_DN
00001B4C  B83C 0005               1094              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001B50  6700 005E               1095              BEQ         W_DN
00001B54  B83C 0006               1096              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001B58  6700 006A               1097              BEQ         L_DN        
00001B5C  6000 F58E               1098              BRA         INVALID     *Got here, must be invalid data.
00001B60                          1099              
00001B60  18FC 0042               1100  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
00001B64  18FC 0020               1101              MOVE.B      #' ',(A4)+
00001B68  18FC 0020               1102              MOVE.B      #' ',(A4)+
00001B6C  4EB9 00001BD8           1103              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001B72  4E75                    1104              RTS
00001B74                          1105  
00001B74  18FC 0057               1106  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
00001B78  18FC 0020               1107              MOVE.B      #' ',(A4)+
00001B7C  18FC 0020               1108              MOVE.B      #' ',(A4)+
00001B80  4EB9 00001BD8           1109              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001B86  4E75                    1110              RTS
00001B88                          1111  
00001B88  18FC 004C               1112  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00001B8C  18FC 0020               1113              MOVE.B      #' ',(A4)+
00001B90  18FC 0020               1114              MOVE.B      #' ',(A4)+
00001B94  4EB9 00001BD8           1115              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001B9A  4E75                    1116              RTS
00001B9C                          1117  
00001B9C  18FC 0042               1118  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001BA0  18FC 0020               1119              MOVE.B      #' ',(A4)+
00001BA4  18FC 0020               1120              MOVE.B      #' ',(A4)+
00001BA8  4EB9 00001C04           1121              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001BAE  4E75                    1122              RTS
00001BB0                          1123  
00001BB0  18FC 0057               1124  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
00001BB4  18FC 0020               1125              MOVE.B      #' ',(A4)+
00001BB8  18FC 0020               1126              MOVE.B      #' ',(A4)+
00001BBC  4EB9 00001C04           1127              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001BC2  4E75                    1128              RTS
00001BC4                          1129  
00001BC4  18FC 004C               1130  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001BC8  18FC 0020               1131              MOVE.B      #' ',(A4)+
00001BCC  18FC 0020               1132              MOVE.B      #' ',(A4)+
00001BD0  4EB9 00001C04           1133              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001BD6  4E75                    1134              RTS            
00001BD8                          1135              
00001BD8                          1136              
00001BD8                          1137              
00001BD8                          1138              
00001BD8                          1139              
00001BD8                          1140              
00001BD8                          1141              
00001BD8                          1142  
00001BD8                          1143  
00001BD8                          1144  
00001BD8                          1145  
00001BD8                          1146  
00001BD8                          1147  
00001BD8                          1148  -------------------- end include --------------------
00001BD8                          1149              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001BD8                          1150  
00001BD8                          1151  
00001BD8                          1152  
00001BD8  4EB9 00001C8E           1153  EASRC_DDES  JSR         GEN_EA_CODE *Deal with EA code First
00001BDE  18FC 002C               1154              MOVE.B      #',',(A4)+
00001BE2  18FC 0044               1155              MOVE.B      #'D',(A4)+
00001BE6  4EB9 00001CF6           1156              JSR         REG_CODE    *Decode Dn and add number to string
00001BEC  4E75                    1157              RTS
00001BEE                          1158  
00001BEE  4EB9 00001C8E           1159  EASRC_ADES  JSR         GEN_EA_CODE *Deal with EA code first
00001BF4  18FC 002C               1160              MOVE.B      #',',(A4)+
00001BF8  18FC 0041               1161              MOVE.B      #'A',(A4)+
00001BFC  4EB9 00001CF6           1162              JSR         REG_CODE    *Decode Dn and add number to string
00001C02  4E75                    1163              RTS        
00001C04                          1164  
00001C04  18FC 0044               1165  DN_SRC      MOVE.B      #'D',(A4)+
00001C08  4EB9 00001CF6           1166              JSR         REG_CODE    *Decode Dn and add number to string
00001C0E  18FC 002C               1167              MOVE.B      #',',(A4)+
00001C12  4EB9 00001C8E           1168              JSR         GEN_EA_CODE *Deal with EA code Second
00001C18  4E75                    1169              RTS
00001C1A                          1170  
00001C1A  4EB9 00001E54           1171  IDATASRC_EA JSR     IDATA       *Add immediate data
00001C20  18FC 002C               1172              MOVE.B  #',',(A4)+  
00001C24  4EB9 00001C8E           1173              JSR     GEN_EA_CODE *Add ea code
00001C2A  4E75                    1174              RTS
00001C2C                          1175  
00001C2C                          1176  
00001C2C                          1177  MM_OP_ORD 
00001C2C  4E75                    1178              RTS
00001C2E                          1179  
00001C2E                          1180  MM_EA_SRC   *Deal with EA code first
00001C2E                          1181              *Deal with list second
00001C2E  4E75                    1182              RTS
00001C30                          1183  
00001C30                          1184  MM_LS_SRC   *Deal with list first
00001C30                          1185              *Deal with EA code second
00001C30  4E75                    1186              RTS
00001C32                          1187  
00001C32  4281                    1188  MOVEQ_EA    CLR.L       D1          *Make sure D1 is clear
00001C34  3207                    1189              MOVE.W      D7,D1       *copy original opcode
00001C36  18FC 0020               1190              MOVE.B      #' ',(A4)+
00001C3A  18FC 0020               1191              MOVE.B      #' ',(A4)+
00001C3E  18FC 0023               1192              MOVE.B      #'#',(A4)+
00001C42  18FC 0024               1193              MOVE.B      #'$',(A4)+
00001C46  4EB9 00001F30           1194              JSR         B_H2A       *Add data in 8 least sig bits (byte)
00001C4C  18FC 002C               1195              MOVE.B      #',',(A4)+
00001C50  18FC 0044               1196              MOVE.B      #'D',(A4)+
00001C54                          1197              
00001C54  4281                    1198              CLR.L       D1
00001C56  123C 000D               1199              MOVE.B      #13,D1
00001C5A  E94B                    1200              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001C5C  E26B                    1201              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001C5E                          1202              
00001C5E  4EB9 00001CF6           1203              JSR         REG_CODE    *Decode Dn and add number to string            
00001C64                          1204  
00001C64  4E75                    1205              RTS
00001C66                          1206              
00001C66  4281                    1207  ADDQ_EA     CLR.L       D1          *Make sure D1 is clear
00001C68  3207                    1208              MOVE.W      D7,D1       *Move untoched opcode into D1 for Manipulation
00001C6A                          1209              
00001C6A  E949                    1210              LSL.W       #4,D1       *Clear more sig bits
00001C6C  4282                    1211              CLR.L       D2          * for shifting
00001C6E  143C 000D               1212              MOVE.B      #13,D2      *To move data bits into lsb
00001C72  E469                    1213              LSR.W       D2,D1       *Data now in lsb
00001C74                          1214              
00001C74  18FC 0023               1215              MOVE.B      #'#',(A4)+
00001C78  18FC 0024               1216              MOVE.B      #'$',(A4)+
00001C7C  4EB9 00001EBC           1217              JSR         ADDQ_ID     *Jump to ADDQ_ID (immeidate data selector)
00001C82  18FC 002C               1218              MOVE.B      #',',(A4)+  *Add seperator
00001C86  4EB9 00001C8E           1219              JSR         GEN_EA_CODE *Add the ea code
00001C8C                          1220              
00001C8C  4E75                    1221              RTS
00001C8E                          1222  
00001C8E                          1223  
00001C8E                          1224  
00001C8E  4283                    1225  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001C90  4286                    1226              CLR.L       D6          *Make sure D6 is clear
00001C92  4281                    1227              CLR.L       D1          *Make sure D1 is clear for shifting
00001C94                          1228              
00001C94  3607                    1229              MOVE.W      D7,D3       *Move untouched opcode into D3
00001C96  3C07                    1230              MOVE.W      D7,D6       *Move untouched opcode into D6
00001C98                          1231              
00001C98  123C 000A               1232              MOVE.B      #10,D1      *Shifting to isolate MODE
00001C9C  E36E                    1233              LSL.W       D1,D6       
00001C9E  123C 000D               1234              MOVE.B      #13,D1
00001CA2  E26E                    1235              LSR.W       D1,D6       *Move MODE bits to LSB position
00001CA4                          1236              
00001CA4  E36B                    1237              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001CA6  E26B                    1238              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001CA8                          1239              
00001CA8  4EB9 00001D0C           1240              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001CAE  4E75                    1241              RTS
00001CB0                          1242              
00001CB0  4283                    1243  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001CB2  4286                    1244              CLR.L       D6          *Make sure D6 is clear
00001CB4  4281                    1245              CLR.L       D1          *Make sure D1 is clear for shifting
00001CB6                          1246              
00001CB6  3607                    1247              MOVE.W      D7,D3       *Move untouched opcode into D3
00001CB8  3C07                    1248              MOVE.W      D7,D6       *Move untouched opcode into D6
00001CBA                          1249              
00001CBA  123C 000A               1250              MOVE.B      #10,D1      *Shifting to isolate MODE
00001CBE  E36E                    1251              LSL.W       D1,D6       
00001CC0  123C 000D               1252              MOVE.B      #13,D1
00001CC4  E26E                    1253              LSR.W       D1,D6       *Move MODE bits to LSB position
00001CC6                          1254              
00001CC6  E36B                    1255              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001CC8  E26B                    1256              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001CCA                          1257              
00001CCA  4EB9 00001D0C           1258              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001CD0                          1259              
00001CD0  18FC 002C               1260              MOVE.B      #',',(A4)+  *SEPERATOR
00001CD4                          1261              
00001CD4  4283                    1262              CLR.L       D3          *Make sure D3 is clear
00001CD6  4286                    1263              CLR.L       D6          *Make sure D6 is clear
00001CD8  4281                    1264              CLR.L       D1          *Make sure D1 is clear for shifting
00001CDA                          1265              
00001CDA  3607                    1266              MOVE.W      D7,D3       *Move untouched opcode into D3
00001CDC  3C07                    1267              MOVE.W      D7,D6       *Move untouched opcode into D6
00001CDE                          1268              
00001CDE  123C 0007               1269              MOVE.B      #7,D1      *Shifting to isolate MODE
00001CE2  E36E                    1270              LSL.W       D1,D6       
00001CE4  123C 000D               1271              MOVE.B      #13,D1
00001CE8  E26E                    1272              LSR.W       D1,D6       *Move MODE bits to LSB position
00001CEA                          1273              
00001CEA  E94B                    1274              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001CEC  E26B                    1275              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001CEE                          1276              
00001CEE  4EB9 00001D0C           1277              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001CF4                          1278              
00001CF4  4E75                    1279              RTS
00001CF6                          1280              
00001CF6                          1281              
00001CF6  4283                    1282  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
00001CF8  3607                    1283              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
00001CFA  E94B                    1284              LSL.W       #4,D3       *Isolate bits and move to LSB position
00001CFC  4282                    1285              CLR.L       D2
00001CFE  143C 000D               1286              MOVE.B      #13,D2
00001D02  E46B                    1287              LSR.W       D2,D3
00001D04  4EB9 00001DA4           1288              JSR         REG_TBL     *Jump to register table.
00001D0A  4E75                    1289              RTS
00001D0C                          1290              
00001D0C                          1291  
00001D0C                          1292  
00001D0C                          1293  
00001D0C  BC3C 0000               1294  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
00001D10  6700 002E               1295              BEQ         DRD
00001D14  BC3C 0001               1296              CMP.B       #1,D6
00001D18  6700 0032               1297              BEQ         ARD
00001D1C  BC3C 0002               1298              CMP.B       #2,D6
00001D20  6700 0036               1299              BEQ         ARI
00001D24  BC3C 0003               1300              CMP.B       #3,D6
00001D28  6700 0042               1301              BEQ         ARI_INC
00001D2C  BC3C 0004               1302              CMP.B       #4,D6
00001D30  6700 0052               1303              BEQ         ARI_DEC
00001D34  BC3C 0007               1304              CMP.B       #7,D6
00001D38  6700 0062               1305              BEQ         ABS_ADDR
00001D3C  4EF8 10EC               1306              JMP         INVALID     *Got here? Must be bad data.
00001D40                          1307  
00001D40  18FC 0044               1308  DRD         MOVE.B      #'D',(A4)+
00001D44  4EB9 00001DA4           1309              JSR         REG_TBL     *Reg num should be in D3
00001D4A  4E75                    1310              RTS
00001D4C                          1311  
00001D4C  18FC 0041               1312  ARD         MOVE.B      #'A',(A4)+
00001D50  4EB9 00001DA4           1313              JSR         REG_TBL     *Reg num should be in D3
00001D56  4E75                    1314              RTS
00001D58                          1315  
00001D58  18FC 0028               1316  ARI         MOVE.B      #'(',(A4)+
00001D5C  18FC 0041               1317              MOVE.B      #'A',(A4)+
00001D60  4EB9 00001DA4           1318              JSR         REG_TBL     *Reg num should be in D3
00001D66  18FC 0029               1319              MOVE.B      #')',(A4)+
00001D6A  4E75                    1320              RTS
00001D6C                          1321  
00001D6C  18FC 0028               1322  ARI_INC     MOVE.B      #'(',(A4)+
00001D70  18FC 0041               1323              MOVE.B      #'A',(A4)+
00001D74  4EB9 00001DA4           1324              JSR         REG_TBL     *Reg num should be in D3
00001D7A  18FC 0029               1325              MOVE.B      #')',(A4)+
00001D7E  18FC 002B               1326              MOVE.B      #'+',(A4)+
00001D82  4E75                    1327              RTS
00001D84                          1328  
00001D84  18FC 002D               1329  ARI_DEC     MOVE.B      #'-',(A4)+
00001D88  18FC 0028               1330              MOVE.B      #'(',(A4)+
00001D8C  18FC 0041               1331              MOVE.B      #'A',(A4)+
00001D90  4EB9 00001DA4           1332              JSR         REG_TBL     *Reg num should be in D3
00001D96  18FC 0029               1333              MOVE.B      #')',(A4)+
00001D9A  4E75                    1334              RTS
00001D9C                          1335  
00001D9C  4EB9 00001E18           1336  ABS_ADDR    JSR         ABS_TBL
00001DA2  4E75                    1337              RTS
00001DA4                          1338              
00001DA4  B63C 0000               1339  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001DA8  6700 003E               1340              BEQ         NUM_0
00001DAC  B63C 0001               1341              CMP.B       #1,D3
00001DB0  6700 003C               1342              BEQ         NUM_1
00001DB4  B63C 0002               1343              CMP.B       #2,D3
00001DB8  6700 003A               1344              BEQ         NUM_2
00001DBC  B63C 0003               1345              CMP.B       #3,D3
00001DC0  6700 0038               1346              BEQ         NUM_3
00001DC4  B63C 0004               1347              CMP.B       #4,D3
00001DC8  6700 0036               1348              BEQ         NUM_4
00001DCC  B63C 0005               1349              CMP.B       #5,D3
00001DD0  6700 0034               1350              BEQ         NUM_5
00001DD4  B63C 0006               1351              CMP.B       #6,D3
00001DD8  6700 0032               1352              BEQ         NUM_6
00001DDC  B63C 0007               1353              CMP.B       #7,D3
00001DE0  6700 0030               1354              BEQ         NUM_7
00001DE4  4EF8 10EC               1355              JMP         INVALID     *Got here? Must be bad data.
00001DE8                          1356              
00001DE8  18FC 0030               1357  NUM_0       MOVE.B      #'0',(A4)+
00001DEC  4E75                    1358              RTS              
00001DEE  18FC 0031               1359  NUM_1       MOVE.B      #'1',(A4)+
00001DF2  4E75                    1360              RTS
00001DF4  18FC 0032               1361  NUM_2       MOVE.B      #'2',(A4)+
00001DF8  4E75                    1362              RTS
00001DFA  18FC 0033               1363  NUM_3       MOVE.B      #'3',(A4)+
00001DFE  4E75                    1364              RTS
00001E00  18FC 0034               1365  NUM_4       MOVE.B      #'4',(A4)+
00001E04  4E75                    1366              RTS
00001E06  18FC 0035               1367  NUM_5       MOVE.B      #'5',(A4)+
00001E0A  4E75                    1368              RTS
00001E0C  18FC 0036               1369  NUM_6       MOVE.B      #'6',(A4)+
00001E10  4E75                    1370              RTS
00001E12  18FC 0037               1371  NUM_7       MOVE.B      #'7',(A4)+
00001E16  4E75                    1372              RTS
00001E18                          1373  
00001E18  B63C 0000               1374  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001E1C  6700 0016               1375              BEQ         ABW
00001E20  B63C 0001               1376              CMP.B       #1,D3
00001E24  6700 001E               1377              BEQ         ABL
00001E28  B63C 0004               1378              CMP.B       #4,D3
00001E2C  6700 0026               1379              BEQ         IDATA
00001E30  4EF8 10EC               1380              JMP         INVALID     *Got here? Must be bad data.
00001E34                          1381              
00001E34  18FC 0024               1382  ABW         MOVE.B      #'$',(A4)+
00001E38  4281                    1383              CLR.L       D1          *Make sure D1 is clear
00001E3A  321D                    1384              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001E3C  4EB9 00001F72           1385              JSR         W_H2A       *convert absolute value to ascii and add to good string
00001E42  4E75                    1386              RTS
00001E44                          1387  
00001E44  18FC 0024               1388  ABL         MOVE.B      #'$',(A4)+
00001E48  4281                    1389              CLR.L       D1          *Make sure D1 is clear
00001E4A  221D                    1390              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
00001E4C  4EB9 00001FB4           1391              JSR         L_H2A
00001E52  4E75                    1392              RTS
00001E54                          1393              
00001E54  18FC 0023               1394  IDATA       MOVE.B      #'#',(A4)+
00001E58  18FC 0024               1395              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
00001E5C  4EB9 00001E64           1396              JSR         IMD_TBL
00001E62  4E75                    1397              RTS
00001E64                          1398              
00001E64  B83C 0000               1399  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
00001E68  6700 002E               1400              BEQ         B_IMD       
00001E6C  B83C 0004               1401              CMP.B       #4,D4
00001E70  6700 0026               1402              BEQ         B_IMD
00001E74                          1403  
00001E74  B83C 0001               1404              CMP.B       #1,D4       *Is it a word size code?
00001E78  6700 002A               1405              BEQ         W_IMD
00001E7C  B83C 0005               1406              CMP.B       #5,D4
00001E80  6700 0022               1407              BEQ         W_IMD
00001E84                          1408              
00001E84  B83C 0002               1409              CMP.B       #2,D4       *Is it a long word size code?
00001E88  6700 0026               1410              BEQ         L_IMD
00001E8C  B83C 0006               1411              CMP.B       #6,D4
00001E90  6700 001E               1412              BEQ         L_IMD
00001E94                          1413              
00001E94  6000 F256               1414              BRA         INVALID     *Got here? Must be bad data.
00001E98                          1415              
00001E98  4281                    1416  B_IMD       CLR.L       D1
00001E9A  321D                    1417              MOVE.W      (A5)+,D1    *Make sure D1 is clear
00001E9C  4EB9 00001F30           1418              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
00001EA2  4E75                    1419              RTS
00001EA4                          1420  
00001EA4  4281                    1421  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001EA6  321D                    1422              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001EA8  4EB9 00001F72           1423              JSR         W_H2A
00001EAE  4E75                    1424              RTS
00001EB0                          1425  
00001EB0  4281                    1426  L_IMD       CLR.L       D1          *Make sure D1 is clear
00001EB2  221D                    1427              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
00001EB4  4EB9 00001FB4           1428              JSR         L_H2A
00001EBA  4E75                    1429              RTS
00001EBC                          1430  
00001EBC  B23C 0000               1431  ADDQ_ID     CMP.B       #0,D1       *Select correct number to add to output strings
00001EC0  6700 003E               1432              BEQ         AQ_0
00001EC4  B23C 0001               1433              CMP.B       #1,D1
00001EC8  6700 003C               1434              BEQ         AQ_1
00001ECC  B23C 0002               1435              CMP.B       #2,D1
00001ED0  6700 003A               1436              BEQ         AQ_2
00001ED4  B23C 0003               1437              CMP.B       #3,D1
00001ED8  6700 0038               1438              BEQ         AQ_3
00001EDC  B23C 0004               1439              CMP.B       #4,D1
00001EE0  6700 0036               1440              BEQ         AQ_4
00001EE4  B23C 0005               1441              CMP.B       #5,D1
00001EE8  6700 0034               1442              BEQ         AQ_5
00001EEC  B23C 0006               1443              CMP.B       #6,D1
00001EF0  6700 0032               1444              BEQ         AQ_6
00001EF4  B23C 0007               1445              CMP.B       #7,D1
00001EF8  6700 0030               1446              BEQ         AQ_7
00001EFC  4EF8 10EC               1447              JMP         INVALID     *Got here? Something is wrong.
00001F00                          1448              
00001F00  18FC 0038               1449  AQ_0        MOVE.B      #'8',(A4)+
00001F04  4E75                    1450              RTS              
00001F06  18FC 0031               1451  AQ_1        MOVE.B      #'1',(A4)+
00001F0A  4E75                    1452              RTS
00001F0C  18FC 0032               1453  AQ_2        MOVE.B      #'2',(A4)+
00001F10  4E75                    1454              RTS
00001F12  18FC 0033               1455  AQ_3        MOVE.B      #'3',(A4)+
00001F16  4E75                    1456              RTS
00001F18  18FC 0034               1457  AQ_4        MOVE.B      #'4',(A4)+
00001F1C  4E75                    1458              RTS
00001F1E  18FC 0035               1459  AQ_5        MOVE.B      #'5',(A4)+
00001F22  4E75                    1460              RTS
00001F24  18FC 0036               1461  AQ_6        MOVE.B      #'6',(A4)+
00001F28  4E75                    1462              RTS
00001F2A  18FC 0037               1463  AQ_7        MOVE.B      #'7',(A4)+
00001F2E  4E75                    1464              RTS          
00001F30                          1465  
00001F30                          1466              
00001F30                          1467  
00001F30                          1468  
00001F30                          1469  INV_DATA *need to implement currently invalid data is treated as an invalid opcode.
00001F30                          1470  
00001F30                          1471  
00001F30  4280                    1472  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001F32  4282                    1473              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001F34  4283                    1474              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001F36  103C 0002               1475              MOVE.B      #$2,D0      *Counter
00001F3A  6000 0002               1476              BRA         B_ISO_DIG   *Begin isolating chars
00001F3E                          1477              
00001F3E  E919                    1478  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
00001F40                          1479              
00001F40  1401                    1480              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001F42                          1481              
00001F42  163C 0004               1482              MOVE.B      #4,D3      *Shift left 28 times
00001F46  E72A                    1483              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00001F48  E91A                    1484              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00001F4A                          1485              
00001F4A  0C02 0009               1486              CMPI.B      #$9,D2      *Is it a number?
00001F4E  6F00 0006               1487              BLE         B_NUM       *If it is, process number
00001F52  6000 000A               1488              BRA         B_LET       *If not, process letter
00001F56                          1489              
00001F56  0602 0030               1490  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001F5A  6000 000A               1491              BRA         B_ADD_CHAR  *add to strings and continue
00001F5E                          1492              
00001F5E  0602 0037               1493  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00001F62  6000 0002               1494              BRA         B_ADD_CHAR  *add to strings and continue
00001F66                          1495  
00001F66  18C2                    1496  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001F68  5300                    1497              SUBI.B      #$1,D0      *decrement counter
00001F6A  0C00 0000               1498              CMPI.B      #$0,D0      *Check if we're done            
00001F6E  6ECE                    1499              BGT         B_ISO_DIG   *If not, continue tranlation   
00001F70                          1500              
00001F70  4E75                    1501              RTS
00001F72                          1502  
00001F72  4280                    1503  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001F74  4282                    1504              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001F76  4283                    1505              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001F78  103C 0004               1506              MOVE.B      #$4,D0      *Counter
00001F7C  6000 0002               1507              BRA         W_ISO_DIG   *Begin isolating chars
00001F80                          1508              
00001F80  E959                    1509  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001F82                          1510              
00001F82  1401                    1511              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001F84                          1512              
00001F84  163C 000C               1513              MOVE.B      #12,D3      *Shift left 28 times
00001F88  E76A                    1514              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
00001F8A  E95A                    1515              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
00001F8C                          1516              
00001F8C  0C02 0009               1517              CMPI.B      #$9,D2      *Is it a number?
00001F90  6F00 0006               1518              BLE         W_NUM       *If it is, process number
00001F94  6000 000A               1519              BRA         W_LET       *If not, process letter
00001F98                          1520              
00001F98  0602 0030               1521  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001F9C  6000 000A               1522              BRA         W_ADD_CHAR  *add to strings and continue
00001FA0                          1523              
00001FA0  0602 0037               1524  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00001FA4  6000 0002               1525              BRA         W_ADD_CHAR  *add to strings and continue
00001FA8                          1526  
00001FA8  18C2                    1527  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001FAA  5300                    1528              SUBI.B      #$1,D0      *decrement counter
00001FAC  0C00 0000               1529              CMPI.B      #$0,D0      *Check if we're done            
00001FB0  6ECE                    1530              BGT         W_ISO_DIG   *If not, continue tranlation   
00001FB2                          1531              
00001FB2  4E75                    1532              RTS
00001FB4  4280                    1533  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001FB6  4282                    1534              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001FB8  4283                    1535              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001FBA  103C 0008               1536              MOVE.B      #$8,D0      *Counter
00001FBE  6000 0002               1537              BRA         L_ISO_DIG   *Begin isolating chars
00001FC2                          1538              
00001FC2  E999                    1539  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
00001FC4                          1540              
00001FC4  1401                    1541              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001FC6                          1542              
00001FC6  163C 001C               1543              MOVE.B      #28,D3      *Shift left 28 times
00001FCA  E7AA                    1544              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001FCC  E99A                    1545              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001FCE                          1546              
00001FCE  0C02 0009               1547              CMPI.B      #$9,D2      *Is it a number?
00001FD2  6F00 0006               1548              BLE         L_NUM       *If it is, process number
00001FD6  6000 000A               1549              BRA         L_LET       *If not, process letter
00001FDA                          1550              
00001FDA  0602 0030               1551  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001FDE  6000 000A               1552              BRA         L_ADD_CHAR  *add to strings and continue
00001FE2                          1553              
00001FE2  0602 0037               1554  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00001FE6  6000 0002               1555              BRA         L_ADD_CHAR  *add to strings and continue
00001FEA                          1556  
00001FEA  18C2                    1557  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001FEC  5300                    1558              SUBI.B      #$1,D0      *decrement counter
00001FEE  0C00 0000               1559              CMPI.B      #$0,D0      *Check if we're done            
00001FF2  6ECE                    1560              BGT         L_ISO_DIG   *If not, continue tranlation   
00001FF4                          1561              
00001FF4  4E75                    1562              RTS
00001FF6                          1563  
00001FF6                          1564  
00001FF6                          1565  
00001FF6                          1566  
00001FF6                          1567  
00001FF6                          1568  
00001FF6                          1569  
00001FF6                          1570  -------------------- end include --------------------
00001FF6                          1571  
00001FF6  =0000000D               1572  CR          EQU         $0D
00001FF6  =0000000A               1573  LF          EQU         $0A
00001FF6                          1574  
00001FF6= 2D 2D 2D 2D 2D 2D ...   1575  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
00002020= 48 65 6E 72 79 20 ...   1576              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00002049= 43 53 53 20 34 32 ...   1577              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
00002072= 2D 2D 2D 2D 2D 2D ...   1578              DC.B        '----------------------------------------',CR,LF,0
0000209D                          1579  
0000209D= 59 6F 75 20 4D 55 ...   1580  IN_WARN     DC.B        'You MUST follow the following input rules:',CR,LF
000020C9= 31 2E 20 59 6F 75 ...   1581              DC.B        '1. Your starting address must be greater than or equal to $3000',CR,LF
0000210A= 20 20 20 28 74 68 ...   1582              DC.B        '   (this means your data file must be orged at $3000 or greater)',CR,LF
0000214C= 32 2E 20 59 6F 75 ...   1583              DC.B        '2. Your ending address must be greater than your starting address',CR,LF
0000218F= 33 2E 20 59 6F 75 ...   1584              DC.B        '3. You must enter something for both starting and ending (no NULL inputs)',CR,LF
000021DA= 34 2E 20 42 6F 74 ...   1585              DC.B        '4. Both your starting and ending address must be in the range of:',CR,LF
0000221D= 20 20 20 5B 24 33 ...   1586              DC.B        '   [$3000,$FFFFFFFF) (interval notation)',CR,LF
00002247= 35 2E 20 59 6F 75 ...   1587              DC.B        '5. Your inputs for both addresses may NOT be ODD values.',CR,LF
00002281= 36 2E 20 59 6F 75 ...   1588              DC.B        '6. Your inputs for both must ONLY contain standard hexidecimal characters:',CR,LF
000022CD= 20 20 20 30 20 31 ...   1589              DC.B        '   0 1 2 3 4 5 6 7 8 9 A B C D E F (Do NOT include spaces or $)',CR,LF
0000230E= 46 61 69 6C 75 72 ...   1590              DC.B        'Failure to follow these instructions WILL result in crash or unexpected behavior.',CR,LF,CR,LF,0
00002364                          1591   
00002364                          1592              
00002364= 45 6E 74 65 72 20 ...   1593  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
00002387= 45 6E 74 65 72 20 ...   1594  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000023A8                          1595  
000023A8= 0D 0A 50 72 65 73 ...   1596  NXT_PG      DC.B        CR,LF,'Press ENTER key to contiune reading',CR,CR,LF,0
000023D1                          1597  
000023D1= 0D 0A 50 72 65 73 ...   1598  END_PGR     DC.B        CR,LF,'Prese SPACE to decode another memory image.',CR,LF
00002400= 50 72 65 73 73 20 ...   1599              DC.B        'Press ESC key to QUIT.',CR,LF,0
00002419                          1600  
00002419                          1601  STA_ADDR    DS.B        40
00002441                          1602  END_ADDR    DS.B        40
00002469                          1603  
00002469                          1604  
00002469                          1605  
00002469                          1606  
0000246A= 00000001                1607  BAD_STR     DC.L        1
0000246E                          1608  
0000246E= 00000050                1609  SPACER11    DC.L        80
00002472= 00000050                1610  SPACER22    DC.L        80
00002476= 00000050                1611  SPACER33    DC.L        80
0000247A= 00000050                1612  SPACER44    DC.L        80
0000247E= 00000050                1613  SPACER55    DC.L        80
00002482= 00000050                1614  SPACER66    DC.L        80
00002486= 00000050                1615  SPACER77    DC.L        80
0000248A= 00000050                1616  SPACER88    DC.L        80
0000248E= 00000050                1617  SPACER99    DC.L        80
00002492= 00000050                1618  SPACERAA    DC.L        80
00002496= 00000050                1619  SPACERBB    DC.L        80
0000249A= 00000050                1620  SPACERCC    DC.L        80
0000249E= 00000050                1621  SPACERDD    DC.L        80
000024A2= 00000050                1622  SPACEREE    DC.L        80
000024A6= 00000050                1623  SPACERFF    DC.L        80
000024AA                          1624  
000024AA= 00000001                1625  GOOD_STR    DC.L        1
000024AE                          1626  
000024AE= 00000050                1627  SPACER1     DC.L        80
000024B2= 00000050                1628  SPACER2     DC.L        80
000024B6= 00000050                1629  SPACER3     DC.L        80
000024BA= 00000050                1630  SPACER4     DC.L        80
000024BE= 00000050                1631  SPACER5     DC.L        80
000024C2= 00000050                1632  SPACER6     DC.L        80
000024C6= 00000050                1633  SPACER7     DC.L        80
000024CA= 00000050                1634  SPACER8     DC.L        80
000024CE= 00000050                1635  SPACER9     DC.L        80
000024D2= 00000050                1636  SPACERA     DC.L        80
000024D6= 00000050                1637  SPACERB     DC.L        80
000024DA= 00000050                1638  SPACERC     DC.L        80
000024DE= 00000050                1639  SPACERD     DC.L        80
000024E2= 00000050                1640  SPACERE     DC.L        80
000024E6= 00000050                1641  SPACERF     DC.L        80
000024EA                          1642  
000024EA                          1643              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 1E44
ABS_ADDR            1D9C
ABS_TBL             1E18
ABW                 1E34
ADDQ_EA             1C66
ADDQ_ID             1EBC
ADD_CHAR_B          1214
ADD_CHAR_BO         125A
ADD_CHAR_G          11CC
ADD_SIZE            1AB4
AH_DONE             109E
AQ_0                1F00
AQ_1                1F06
AQ_2                1F0C
AQ_3                1F12
AQ_4                1F18
AQ_5                1F1E
AQ_6                1F24
AQ_7                1F2A
ARD                 1D4C
ARI                 1D58
ARI_DEC             1D84
ARI_INC             1D6C
ASCII_HEX           1086
BAD_STR             246A
BCC_CC              1994
BCC_CODE            18DA
BCC_CS              19AC
BCC_EQ              19DC
BCC_GE              1A54
BCC_GT              1A84
BCC_HI              1964
BCC_LE              1A9C
BCC_LS              197C
BCC_LT              1A6C
BCC_MI              1A3C
BCC_NE              19C4
BCC_PL              1A24
BCC_TABLE           18F0
BCC_VC              19F4
BCC_VS              1A0C
B_ADD_CHAR          1F66
B_DN                1B9C
B_EA                1B60
B_H2A               1F30
B_IMD               1E98
B_ISO_DIG           1F3E
B_LET               1F5E
B_NUM               1F56
B_SIZE              1ACC
CLEAN_GS            1126
CONTINUE            10F6
CR                  D
DECODE_LOOP         10C2
DN_SRC              1C04
DONE                1306
DRD                 1D40
D_CLEAN             113A
EASRC_ADES          1BEE
EASRC_DDES          1BD8
EA_TBL              1D0C
END_ADDR            2441
END_MSG             2387
END_OPT             12E2
END_PGR             23D1
FORMAT              10B4
GEN_EA_CODE         1C8E
GET_INPUT           1020
GET_SIZE_1          1B16
GET_SIZE_2          1B06
GET_SIZE_3          1AF6
GOOD_STR            24AA
GS_LOOP             112C
H2A_B_ADDR          11D8
H2A_B_OP            1220
H2A_G_ADDR          1190
IDATA               1E54
IDATASRC_EA         1C1A
IMD_TBL             1E64
INIT_BAD            115E
INIT_GOOD           114A
INIT_STRS           113C
INTRO               1012
INVALID             10EC
INV_DATA            1F30
IN_WARN             209D
ISODIG_BO           1232
ISO_DIG_B           11EC
ISO_DIG_G           11A4
JMP_0               1318
JMP_0X              1458
JMP_1               1328
JMP_2               1338
JMP_2X              1482
JMP_3               1348
JMP_3X              14A6
JMP_4               1358
JMP_47X             15DC
JMP_4X              14CA
JMP_5               1368
JMP_6               1378
JMP_6X              1508
JMP_7               1388
JMP_8               1398
JMP_8X              152C
JMP_9               13A8
JMP_A               13B8
JMP_B               13C6
JMP_C               13D4
JMP_CX              1550
JMP_D               13E4
JMP_DX              1574
JMP_E               13F4
JMP_EX              15D8
JMP_TBL             130C
J_47X               14F0
J_ADDI              147A
J_AND               156C
J_BCC               1524
J_BRA               151C
J_CLR1              1438
J_CLR2              1428
J_CLR3              1418
J_CLR4              1408
J_CLR_DM            1448
J_DIVU              1540
J_LEA               14F8
J_MOVEAL            1496
J_MOVEAW            14BA
J_MOVEL             149E
J_MOVEM             1500
J_MOVEW             14C2
J_MULS              1564
J_OR                1548
J_SUBI              1472
LET                 10AA
LET_B               120C
LET_BO              1252
LET_G               11C4
LF                  A
L_ADD_CHAR          1FEA
L_DN                1BC4
L_EA                1B88
L_H2A               1FB4
L_IMD               1EB0
L_ISO_DIG           1FC2
L_LET               1FE2
L_NUM               1FDA
L_SIZE              1AE8
MM_EA_SRC           1C2E
MM_LS_SRC           1C30
MM_OP_ORD           1C2C
MOVEQ_EA            1C32
MOV_EA_CODE         1CB0
NEXT_PAGE           1108
NL_INTRO            1FF6
NUM                 10A0
NUM_0               1DE8
NUM_1               1DEE
NUM_2               1DF4
NUM_3               1DFA
NUM_4               1E00
NUM_5               1E06
NUM_6               1E0C
NUM_7               1E12
NUM_B               1204
NUM_BO              124A
NUM_G               11BC
NXT_PG              23A8
OPC_ADD             1884
OPC_ADDA            1862
OPC_ADDI            163C
OPC_ADDQ            1688
OPC_AND             1844
OPC_BCC             17D2
OPC_BRA             17B6
OPC_DIVU            17DE
OPC_JSR             18A2
OPC_LEA             16EA
OPC_MOVEAL          170E
OPC_MOVEAW          1762
OPC_MOVEB           1664
OPC_MOVEL           173A
OPC_MOVEM           170C
OPC_MOVEQ           16B0
OPC_MOVEW           178E
OPC_MULS            181E
OPC_NOP             18BE
OPC_OR              1804
OPC_RTS             18CC
OPC_SUB             16CC
OPC_SUBI            1614
OP_ADD              15D0
OP_ADDA             15C8
OR_ADD_SIZE         1B2C
O_JSR               160C
O_NOP               15FC
O_RTS               1604
PRG_RESET           1292
PRINT_B             127C
PRINT_G             1266
PRINT_GOOD          10E2
PROC_END            107A
PROC_STA            106E
REG_CODE            1CF6
REG_TBL             1DA4
SPACER1             24AE
SPACER11            246E
SPACER2             24B2
SPACER22            2472
SPACER3             24B6
SPACER33            2476
SPACER4             24BA
SPACER44            247A
SPACER5             24BE
SPACER55            247E
SPACER6             24C2
SPACER66            2482
SPACER7             24C6
SPACER77            2486
SPACER8             24CA
SPACER88            248A
SPACER9             24CE
SPACER99            248E
SPACERA             24D2
SPACERAA            2492
SPACERB             24D6
SPACERBB            2496
SPACERC             24DA
SPACERCC            249A
SPACERD             24DE
SPACERDD            249E
SPACERE             24E2
SPACEREE            24A2
SPACERF             24E6
SPACERFF            24A6
START               1000
STA_ADDR            2419
STA_MSG             2364
W_ADD_CHAR          1FA8
W_DN                1BB0
W_EA                1B74
W_H2A               1F72
W_IMD               1EA4
W_ISO_DIG           1F80
W_LET               1FA0
W_NUM               1F98
W_SIZE              1ADA
