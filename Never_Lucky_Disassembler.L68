00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/16/2017 6:05:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  *-----------------------------------------------------------
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010B6             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 00001406             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 000014AD             28  GET_INPUT   LEA         STA_MSG,A1  *Load STA_MSG into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display start address msg
0000102A  4E4F                      30              TRAP        #15         
0000102C                            31              
0000102C  43F9 00001517             32              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
00001032  103C 0002                 33              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  4EB9 00001062             36              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000103E  4281                      37              CLR.L       D1          *Clear input length from D1
00001040                            38              
00001040  43F9 000014D0             39              LEA         END_MSG,A1  *Load END_MSG into A1
00001046  103C 000E                 40              MOVE.B      #14,D0      *Trap task 14, display end address msg
0000104A  4E4F                      41              TRAP        #15
0000104C                            42              
0000104C  43F9 0000153F             43              LEA         END_ADDR,A1 *Store input in END_ADDR variable
00001052  103C 0002                 44              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001056  4E4F                      45              TRAP        #15         
00001058                            46              
00001058  4EB9 0000106E             47              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000105E  4281                      48              CLR.L       D1          *Clear input length from D1
00001060                            49              
00001060  4E75                      50              RTS
00001062                            51              
00001062                            52  *--------------------PROC_STA-------------------------------
00001062                            53  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
00001062  4EB9 0000107A             54              JSR         ASCII_HEX   *Convert input into Hex
00001068                            55              
00001068                            56              *assuming all error checking is done before the next instruction (not yet implemented)
00001068                            57              
00001068  2A43                      58              MOVEA.L     D3,A5       *Move hex to STA_ADDR
0000106A  4283                      59              CLR.L       D3          *Clear D3
0000106C  4E75                      60              RTS                     
0000106E                            61  
0000106E                            62  *--------------------PROC_END-------------------------------
0000106E                            63  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000106E                            64              *      does not fall before start
0000106E  4EB9 0000107A             65              JSR         ASCII_HEX   *Convert input into Hex
00001074                            66              
00001074                            67              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            68              
00001074  2C43                      69              MOVE.L      D3,A6       *Move hex to END_ADDR
00001076  4283                      70              CLR.L       D3          *Clear D3
00001078  4E75                      71              RTS
0000107A                            72  
0000107A                            73  *-------------------ASCII_HEX-------------------------------
0000107A  0C01 0000                 74  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000107E  6700 0012                 75              BEQ         AH_DONE     *End subroutine if all converted
00001082  1419                      76              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001084  183C 0039                 77              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001088  B404                      78              CMP.B       D4,D2       *Check if ascii code is for a number or letter
0000108A  6F00 0008                 79              BLE         NUM         *Codes less than $39 imply a number, so branch
0000108E  6000 000E                 80              BRA         LET         *If not a number, must be a letter.            
00001092  4E75                      81  AH_DONE     RTS
00001094                            82  
00001094  183C 0030                 83  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
00001098  9404                      84              SUB.B       D4,D2       *convert to hexadecimal number
0000109A  6000 000C                 85              BRA         FORMAT      *branch to subroutine to store converted hex number
0000109E                            86              
0000109E  183C 0037                 87  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010A2  9404                      88              SUB.B       D4,D2       *convert to hexadecimal letter
000010A4  6000 0002                 89              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010A8                            90  
000010A8  5301                      91  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010AA  D602                      92              ADD.B       D2,D3       *Store converted number in D3
000010AC  0C01 0000                 93              CMPI.B      #$0,D1      *Check if we're all done converting
000010B0  67C8                      94              BEQ         ASCII_HEX   *If not continue conversion
000010B2  E983                      95              ASL.L       #4,D3       *Shift bits to the left to correct position
000010B4  60C4                      96              BRA         ASCII_HEX   *Branch back to label
000010B6                            97              
000010B6                            98  *-------------------DECODE_LOOP-----------------------------
000010B6  3E1D                      99  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010B8  47F9 000015A8            100              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010BE  49F9 00001568            101              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010C4                           102              
000010C4  4EB9 0000112A            103              JSR         INIT_STRS   *Initialize Bad and Good Str
000010CA                           104              
000010CA  4EB9 0000126E            105              JSR         JMP_TBL    *Start opcode identification waterfall
000010D0                           106              
000010D0  0C06 00FF                107              CMPI.B      #$FF,D6     *Look for good sentry value in D6 ($AA = good, $FF = bad)
000010D4  6700 0010                108              BEQ         PRINT_BAD   *Print good string if good opcode
000010D8  6000 0002                109              BRA         PRINT_GOOD  *Print bad string if bad opcode
000010DC  4EB9 00001236            110  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010E2  6000 000C                111              BRA         CONTINUE    *Continue the loop
000010E6  4EB9 0000124C            112  PRINT_BAD   JSR         PRINT_B     *Jump to Pring bad string
000010EC  6000 0002                113              BRA         CONTINUE    *Continue the loop            
000010F0                           114              
000010F0  BCCD                     115  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010F2  6700 016E                116              BEQ         END_OPT     *if we're done, move to end options (ask user what to do)
000010F6                           117              
000010F6  4286                     118              CLR.L       D6          *Clear the bad/good flag register
000010F8                           119              
000010F8  5205                     120              ADDQ.B      #1,D5       *Increment line counter
000010FA  BA3C 0018                121              CMP.B       #24,D5      *See if page is full
000010FE  6700 0004                122              BEQ         NEXT_PAGE   *Jump to next page prompt
00001102                           123              
00001102                           124              *Maybe a BGT check here also? would that ever be possible?
00001102                           125              *Need to implement line/page display (one page at a time via enter)
00001102                           126              
00001102  60B2                     127              BRA         DECODE_LOOP * Continue loop
00001104                           128  
00001104                           129  *-------------------NEXT_PAGE-----------------------------
00001104  43F9 000014F1            130  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
0000110A  4280                     131              CLR.L       D0          *Make sure D0 is empty
0000110C  103C 000E                132              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001110  4E4F                     133              TRAP        #15            
00001112                           134              
00001112  103C 000C                135              MOVE.B      #12,D0      *Keyboard echo trap task
00001116  4281                     136              CLR.L       D1          *Start keyboard echo trap
00001118  4E4F                     137              TRAP        #15         
0000111A                           138              
0000111A  103C 0005                139              MOVE.B      #5,D0       *Single char trap task
0000111E  4E4F                     140              TRAP        #15         
00001120                           141              
00001120  B23C 000D                142              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001124  66DE                     143              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
00001126                           144              
00001126  4285                     145              CLR.L       D5          *Reset page counter
00001128                           146              
00001128  608C                     147              BRA         DECODE_LOOP *Continue the loop         
0000112A                           148              
0000112A                           149  *-------------------INIT_STRS-----------------------------
0000112A  4EB9 00001138            150  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001130  4EB9 00001170            151              JSR         INIT_BAD    *Initialize the bad string
00001136  4E75                     152              RTS
00001138                           153  *-------------------INIT_GOOD-----------------------------
00001138  18FC 004C                154  INIT_GOOD   MOVE.B      #'L',(A4)+  *Add to good string  
0000113C  18FC 0065                155              MOVE.B      #'e',(A4)+ 
00001140  18FC 0067                156              MOVE.B      #'g',(A4)+ 
00001144  18FC 0061                157              MOVE.B      #'a',(A4)+ 
00001148  18FC 006C                158              MOVE.B      #'l',(A4)+
0000114C  18FC 0020                159              MOVE.B      #' ',(A4)+
00001150  18FC 0020                160              MOVE.B      #' ',(A4)+ 
00001154  18FC 003A                161              MOVE.B      #':',(A4)+
00001158  18FC 0020                162              MOVE.B      #' ',(A4)+ 
0000115C  18FC 0024                163              MOVE.B      #'$',(A4)+ 
00001160                           164              
00001160  4EB9 000011EE            165              JSR         HEX_ASCII_G *Now convert opcode to ASCII
00001166                           166              
00001166  18FC 0020                167              MOVE.B      #' ',(A4)+  *Add spaces after memory location added
0000116A  18FC 0020                168              MOVE.B      #' ',(A4)+
0000116E                           169              
0000116E                           170              *Add 'Legal: ', then add opcode (must go from hex to ascii)
0000116E                           171              
0000116E                           172              
0000116E  4E75                     173              RTS
00001170                           174  
00001170                           175  *-------------------INIT_BAD------------------------------            
00001170  16FC 0049                176  INIT_BAD    MOVE.B      #'I',(A3)+  *Add to bad string
00001174  16FC 006C                177              MOVE.B      #'l',(A3)+ 
00001178  16FC 006C                178              MOVE.B      #'l',(A3)+    
0000117C  16FC 0065                179              MOVE.B      #'e',(A3)+ 
00001180  16FC 0067                180              MOVE.B      #'g',(A3)+ 
00001184  16FC 0061                181              MOVE.B      #'a',(A3)+ 
00001188  16FC 006C                182              MOVE.B      #'l',(A3)+ 
0000118C  16FC 003A                183              MOVE.B      #':',(A3)+
00001190  16FC 0020                184              MOVE.B      #' ',(A3)+ 
00001194  16FC 0024                185              MOVE.B      #'$',(A3)+  
00001198                           186              
00001198  4EB9 000011A8            187              JSR         HEX_ASCII_B *Now convert opcode to ASCII
0000119E                           188              
0000119E  18FC 0020                189              MOVE.B      #' ',(A4)+  *Add spaces after bad code added
000011A2  18FC 0020                190              MOVE.B      #' ',(A4)+
000011A6                           191              
000011A6                           192              *Add 'Illegal: ', then add opcode (must go from from hex to ascii)
000011A6                           193              
000011A6  4E75                     194              RTS
000011A8                           195              
000011A8                           196  *-------------------HEX_ASCII_B-------------------------------
000011A8  4280                     197  HEX_ASCII_B CLR.L       D0          *Make sure D0 is empty (Counter)
000011AA  4281                     198              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011AC  4282                     199              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011AE  4283                     200              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011B0  3207                     201              MOVE.W      D7,D1       *Copy opcode into D0 for working with
000011B2  103C 0004                202              MOVE.B      #$4,D0      *Counter
000011B6  6000 0002                203              BRA         ISO_DIG_B   *Begin isolating chars
000011BA                           204              
000011BA  E959                     205  ISO_DIG_B   ROL.W       #4,D1       *Move first significant hex char to least sig position
000011BC                           206              
000011BC  2401                     207              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011BE                           208              
000011BE  163C 001C                209              MOVE.B      #28,D3      *Shift left 28 times
000011C2  E7AA                     210              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011C4  E99A                     211              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011C6                           212              
000011C6  0C02 0009                213              CMPI.B      #$9,D2      *Is it a number?
000011CA  6F00 0006                214              BLE         NUM_B       *If it is, process number
000011CE  6000 000A                215              BRA         LET_B       *If not, process letter
000011D2                           216  
000011D2  0602 0030                217  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
000011D6  6000 000A                218              BRA         ADD_CHAR_B  *add to strings and continue
000011DA                           219              
000011DA  0602 0037                220  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
000011DE  6000 0002                221              BRA         ADD_CHAR_B  *add to strings and continue
000011E2                           222              
000011E2  16C2                     223  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to bad data string
000011E4  5300                     224              SUBI.B      #$1,D0      *decrement counter
000011E6  0C00 0000                225              CMPI.B      #$0,D0      *Check if we're done            
000011EA  6ECE                     226              BGT         ISO_DIG_B   *If not, continue tranlation   
000011EC                           227              
000011EC  4E75                     228              RTS
000011EE                           229              
000011EE                           230  *-------------------HEX_ASCII_G-------------------------------            
000011EE  4280                     231  HEX_ASCII_G CLR.L       D0          *Make sure D0 is empty (Counter)
000011F0  4281                     232              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011F2  4282                     233              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011F4  4283                     234              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011F6  220D                     235              MOVE.L      A5,D1       *Copy address into D7
000011F8  5501                     236              SUBI.B      #2,D1       *Move addres back one byte (for post increment)
000011FA  103C 0008                237              MOVE.B      #$8,D0      *Counter
000011FE  6000 0002                238              BRA         ISO_DIG_G   *Begin isolating chars
00001202                           239              
00001202  E999                     240  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
00001204                           241              
00001204  2401                     242              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
00001206                           243              
00001206  163C 001C                244              MOVE.B      #28,D3      *Shift left 28 times
0000120A  E7AA                     245              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
0000120C  E99A                     246              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
0000120E                           247              
0000120E  0C02 0009                248              CMPI.B      #$9,D2      *Is it a number?
00001212  6F00 0006                249              BLE         NUM_G       *If it is, process number
00001216  6000 000A                250              BRA         LET_G       *If not, process letter
0000121A                           251              
0000121A  0602 0030                252  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
0000121E  6000 000A                253              BRA         ADD_CHAR_G  *add to strings and continue
00001222                           254              
00001222  0602 0037                255  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
00001226  6000 0002                256              BRA         ADD_CHAR_G  *add to strings and continue
0000122A                           257  
0000122A  18C2                     258  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
0000122C  5300                     259              SUBI.B      #$1,D0      *decrement counter
0000122E  0C00 0000                260              CMPI.B      #$0,D0      *Check if we're done            
00001232  6ECE                     261              BGT         ISO_DIG_G    *If not, continue tranlation   
00001234                           262              
00001234  4E75                     263              RTS
00001236                           264              
00001236                           265  *-------------------PRINT_G---------------------------------
00001236  18FC 0020                266  PRINT_G     MOVE.B      #' ',(A4)+
0000123A  16FC 0000                267              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
0000123E  43F9 00001568            268              LEA         GOOD_STR,A1 *Load good data for printing
00001244  103C 000D                269              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001248  4E4F                     270              TRAP        #15         *Display string
0000124A                           271            
0000124A  4E75                     272              RTS 
0000124C                           273  
0000124C                           274  *-------------------PRINT_B---------------------------------
0000124C  18FC 0020                275  PRINT_B     MOVE.B      #' ',(A4)+
00001250  18FC 0000                276              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001254  43F9 000015A8            277              LEA         BAD_STR,A1 *Load good data for printing
0000125A  103C 000D                278              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000125E  4E4F                     279              TRAP        #15         *Display string
00001260                           280              
00001260  4E75                     281              RTS 
00001262                           282  
00001262                           283  *-------------------END_OPT---------------------------------
00001262  4EF9 00001268            284  END_OPT     JMP         DONE        *Jump to done for now untill end options logic is implemented
00001268                           285              
00001268                           286  *-----------------------DONE--------------------------------
00001268  103C 0009                287  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
0000126C  4E4F                     288              TRAP        #15         *Halt program, Trap#15 task 9
0000126E                           289              
0000126E                           290  *---------------Variables and Constants---------------------
0000126E                           291              INCLUDE     'Never_Lucky_Jump_Tables.x68' *Include jump tables file
0000126E                           292  
0000126E  4282                     293  JMP_TBL     CLR.L       D2
00001270  3407                     294              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001272  4281                     295              CLR.L       D1
00001274  123C 000C                296              MOVE.B      #12,D1      *Moves 12 into D1
00001278  E26A                     297              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000127A                           298                          
0000127A  B43C 0000                299  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
0000127E  6600 000A                300              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001282  4EB9 0000139A            301              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
00001288  4E75                     302              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000128A                           303              
0000128A  B43C 0001                304  JMP_1       CMP.B       #$1,D2
0000128E  6600 000A                305              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
Line 306 ERROR: Undefined symbol
00001292  4EB9 004DBB8E            306              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
00001298  4E75                     307              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000129A                           308             
0000129A  B43C 0002                309  JMP_2       CMP.B       #$2,D2
0000129E  6600 000A                310              BNE         JMP_3 
000012A2  4EB9 000013C6            311              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
000012A8  4E75                     312              RTS
000012AA                           313              
000012AA  B43C 0003                314  JMP_3       CMP.B       #$3,D2
000012AE  6600 000A                315              BNE         JMP_4
000012B2  4EB9 000013D2            316              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
000012B8  4E75                     317              RTS
000012BA                           318           
000012BA  B43C 0004                319  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
000012BE  6600 000A                320              BNE         JMP_5
000012C2  4EB9 000013D2            321              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
000012C8  4E75                     322              RTS
000012CA                           323              
000012CA  B43C 0005                324  JMP_5       CMP.B       #$5,D2
000012CE  6600 000A                325              BNE         JMP_6
Line 326 ERROR: Undefined symbol
000012D2  4EB9 004DBB8E            326              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
000012D8  4E75                     327              RTS
000012DA                           328              
000012DA  B43C 0006                329  JMP_6       CMP.B       #$6,D2
000012DE  6600 000A                330              BNE         JMP_7
000012E2  4EB9 000013D2            331              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
000012E8  4E75                     332              RTS
000012EA                           333              
000012EA  B43C 0007                334  JMP_7       CMP.B       #$7,D2
000012EE  6600 000A                335              BNE         JMP_8
Line 336 ERROR: Undefined symbol
000012F2  4EB9 004DBB8E            336              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
000012F8  4E75                     337              RTS
000012FA                           338              
000012FA  B43C 0008                339  JMP_8       CMP.B       #$8,D2
000012FE  6600 000A                340              BNE         JMP_9
00001302  4EB9 000013D2            341              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
00001308  4E75                     342              RTS
0000130A                           343              
0000130A  B43C 0009                344  JMP_9       CMP.B       #$9,D2
0000130E  6600 000A                345              BNE         JMP_A
Line 346 ERROR: Undefined symbol
00001312  4EB9 004DBB8E            346              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
00001318  4E75                     347              RTS
0000131A                           348              
0000131A  B43C 000A                349  JMP_A       CMP.B       #$A,D2
0000131E  6600 000A                350              BNE         JMP_B
00001322  4EB9 000013D2            351              JSR         INVALID     *0xA is an invalid first hex digit. Jump to INVALID
00001328  4E75                     352              RTS
0000132A                           353              
0000132A  B43C 000B                354  JMP_B       CMP.B       #$B,D2
0000132E  6600 000A                355              BNE         JMP_C
00001332  4EB9 000013D2            356              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
00001338  4E75                     357              RTS
0000133A                           358              
0000133A  B43C 000C                359  JMP_C       CMP.B       #$C,D2
0000133E  6600 000A                360              BNE         JMP_D
00001342  4EB9 000013D2            361              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
00001348  4E75                     362              RTS
0000134A                           363              
0000134A  B43C 000D                364  JMP_D       CMP.B       #$D,D2
0000134E  6600 000A                365              BNE         JMP_E   
00001352  4EB9 000013D2            366              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
00001358  4E75                     367              RTS
0000135A                           368              
0000135A  B43C 000F                369  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
0000135E  6700 0072                370              BEQ         INVALID     *If first hex value is F, jump to INVALID
00001362  4EB9 000013D2            371              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001368  4E75                     372              RTS
0000136A                           373   
0000136A                           374  
0000136A  4282                     375  J_CLR4      CLR.L       D2                                
0000136C  3407                     376              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000136E  4281                     377              CLR.L       D1
00001370  E94A                     378              LSL.W       #4,D2       *Clear the most sig hex digit
00001372  123C 000C                379              MOVE.B      #12,D1      *Moves 12 into D1
00001376  E26A                     380              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001378  4E75                     381              RTS                     *Return back to JMP_Xn    
0000137A                           382              
0000137A  4282                     383  J_CLR3      CLR.L       D2          
0000137C  3407                     384              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000137E  4281                     385              CLR.L       D1
00001380  E94A                     386              LSL.W       #4,D2       *Clear the most sig hex digit
00001382  123C 000D                387              MOVE.B      #13,D1      *Moves 13 into D1
00001386  E26A                     388              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001388  4E75                     389              RTS                     *Return back to JMP_Xn  
0000138A                           390  
0000138A  4282                     391  J_CLR_DM    CLR.L       D2          
0000138C  3407                     392              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000138E  4281                     393              CLR.L       D1
00001390  EF4A                     394              LSL.W       #7,D2       *Clear the most sig 7 bits
00001392  123C 0011                395              MOVE.B      #17,D1      *Moves 17 into D1
00001396  E26A                     396              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001398  4E75                     397              RTS                     *Return back to JMP_Xn     
0000139A                           398           
0000139A  4EB8 136A                399  JMP_0X      JSR         J_CLR4      *Prepare data registers for data manipulation on the second input hex digit
0000139E  B43C 0004                400              CMP.B       #$4,D2      *Is the next hex digit 4?
000013A2  6700 0012                401              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
000013A6  B43C 0005                402              CMP.B       #$5,D2      *Is the next hex digit 5?
Line 403 ERROR: Undefined symbol
000013AA  6700 A7E2                403              BEQ         J_OADDI     *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
000013AE  4EB9 000013D2            404              JSR         INVALID     *If neither, OPCODE is invalid
000013B4  4E75                     405              RTS
000013B6                           406  
Line 407 ERROR: Undefined symbol
000013B6  4EB9 004DBB8E            407  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
000013BC  4E75                     408              RTS
000013BE                           409              
Line 410 ERROR: Undefined symbol
000013BE  4EB9 004DBB8E            410  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
000013C4  4E75                     411              RTS              
000013C6                           412  
000013C6  4EB8 138A                413  JMP_2X      JSR         J_CLR_DM    *Prepare data registers for data manipulation on the DEST MODE digits
000013CA  B43C 0001                414              CMP.B       #$1,D2      *is the DEST MODE 1?
000013CE  6700 0002                415              BEQ         J_MOVEAL    *Instruction is determiend to be MOVEA.L                                     ================= < stopped at this point
000013D2                           416               
000013D2                           417  
000013D2                           418  J_MOVEL
000013D2                           419  
000013D2                           420  J_MOVEAL
000013D2                           421  
000013D2                           422  JMP_3X
000013D2                           423  
000013D2                           424  JMP_4X
000013D2                           425  
000013D2                           426  JMP_6X
000013D2                           427  
000013D2                           428  JMP_8X
000013D2                           429  
000013D2                           430  JMP_CX
000013D2                           431  
000013D2                           432  JMP_DX
000013D2                           433  
000013D2                           434  JMP_EX
000013D2                           435  
000013D2                           436  
000013D2  1C38 00FF                437  INVALID     MOVE.B      $FF,D6      *Invalid input flag
000013D6  4E75                     438              RTS
000013D8                           439  
000013D8  4E75                     440  OPC4E7_0     RTS
000013DA                           441  
000013DA  1C3C 00AA                442  OPC4E7_1    MOVE.B      #$AA,D6     *Set good data flag. IF THIS WAS A PARAMERTARIZED INSTRUCTION, NEEDS TO HAPPEN AFTER <EA>/Dn/An...
000013DE                           443  
000013DE  18FC 004E                444              MOVE.B      #'N',(A4)+
000013E2  18FC 004F                445              MOVE.B      #'O',(A4)+
000013E6  18FC 0050                446              MOVE.B      #'P',(A4)+
000013EA                           447              
000013EA                           448              *IF this was a  paramertarize instruction, we'd jump to <EA> decode here
000013EA  4E75                     449              RTS
000013EC                           450  
000013EC  4E75                     451  OPC4E7_2     RTS
000013EE  4E75                     452  OPC4E7_3     RTS
000013F0  4E75                     453  OPC4E7_4     RTS
000013F2  4E75                     454  OPC4E7_5     RTS
000013F4  4E75                     455  OPC4E7_6     RTS
000013F6  4E75                     456  OPC4E7_7     RTS
000013F8  4E75                     457  OPC4E7_8     RTS
000013FA  4E75                     458  OPC4E7_9     RTS
000013FC  4E75                     459  OPC4E7_A     RTS
000013FE  4E75                     460  OPC4E7_B     RTS
00001400  4E75                     461  OPC4E7_C     RTS
00001402  4E75                     462  OPC4E7_D     RTS
00001404  4E75                     463  OPC4E7_E     RTS
00001406                           464  
00001406                           465  
00001406                           466  -------------------- end include --------------------
00001406                           467  
00001406  =0000000D                468  CR          EQU         $0D
00001406  =0000000A                469  LF          EQU         $0A
00001406                           470  
00001406= 2D 2D 2D 2D 2D 2D ...    471  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
00001430= 48 65 6E 72 79 20 ...    472              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00001459= 43 53 53 20 34 32 ...    473              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
00001482= 2D 2D 2D 2D 2D 2D ...    474              DC.B        '----------------------------------------',CR,LF,0
000014AD                           475              
000014AD= 45 6E 74 65 72 20 ...    476  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
000014D0= 45 6E 74 65 72 20 ...    477  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000014F1= 50 72 65 73 73 20 ...    478  NXT_PG      DC.B        'Press enter key to contiune reading',CR,LF,0
00001517                           479  
00001517                           480  STA_ADDR    DS.B        40
0000153F                           481  END_ADDR    DS.B        40
00001567                           482  
00001568= 00000001                 483  GOOD_STR    DC.L        1
0000156C                           484  
0000156C= 00000050                 485  SPACER1     DC.L        80
00001570= 00000050                 486  SPACER2     DC.L        80
00001574= 00000050                 487  SPACER3     DC.L        80
00001578= 00000050                 488  SPACER4     DC.L        80
0000157C= 00000050                 489  SPACER5     DC.L        80
00001580= 00000050                 490  SPACER6     DC.L        80
00001584= 00000050                 491  SPACER7     DC.L        80
00001588= 00000050                 492  SPACER8     DC.L        80
0000158C= 00000050                 493  SPACER9     DC.L        80
00001590= 00000050                 494  SPACERA     DC.L        80
00001594= 00000050                 495  SPACERB     DC.L        80
00001598= 00000050                 496  SPACERC     DC.L        80
0000159C= 00000050                 497  SPACERD     DC.L        80
000015A0= 00000050                 498  SPACERE     DC.L        80
000015A4= 00000050                 499  SPACERF     DC.L        80
000015A8                           500  
000015A8= 00000001                 501  BAD_STR     DC.L        1
000015AC                           502  
000015AC= 00000050                 503  SPACER11    DC.L        80
000015B0= 00000050                 504  SPACER22    DC.L        80
000015B4= 00000050                 505  SPACER33    DC.L        80
000015B8= 00000050                 506  SPACER44    DC.L        80
000015BC= 00000050                 507  SPACER55    DC.L        80
000015C0= 00000050                 508  SPACER66    DC.L        80
000015C4= 00000050                 509  SPACER77    DC.L        80
000015C8= 00000050                 510  SPACER88    DC.L        80
000015CC= 00000050                 511  SPACER99    DC.L        80
000015D0= 00000050                 512  SPACERAA    DC.L        80
000015D4= 00000050                 513  SPACERBB    DC.L        80
000015D8= 00000050                 514  SPACERCC    DC.L        80
000015DC= 00000050                 515  SPACERDD    DC.L        80
000015E0= 00000050                 516  SPACEREE    DC.L        80
000015E4= 00000050                 517  SPACERFF    DC.L        80
000015E8                           518  
000015E8                           519              END         START       *LAST LINE

7 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_CHAR_B          11E2
ADD_CHAR_G          122A
AH_DONE             1092
ASCII_HEX           107A
BAD_STR             15A8
CONTINUE            10F0
CR                  D
DECODE_LOOP         10B6
DONE                1268
END_ADDR            153F
END_MSG             14D0
END_OPT             1262
FORMAT              10A8
GET_INPUT           1020
GOOD_STR            1568
HEX_ASCII_B         11A8
HEX_ASCII_G         11EE
INIT_BAD            1170
INIT_GOOD           1138
INIT_STRS           112A
INTRO               1012
INVALID             13D2
ISO_DIG_B           11BA
ISO_DIG_G           1202
JMP_0               127A
JMP_0X              139A
JMP_1               128A
JMP_2               129A
JMP_2X              13C6
JMP_3               12AA
JMP_3X              13D2
JMP_4               12BA
JMP_4X              13D2
JMP_5               12CA
JMP_6               12DA
JMP_6X              13D2
JMP_7               12EA
JMP_8               12FA
JMP_8X              13D2
JMP_9               130A
JMP_A               131A
JMP_B               132A
JMP_C               133A
JMP_CX              13D2
JMP_D               134A
JMP_DX              13D2
JMP_E               135A
JMP_EX              13D2
JMP_TBL             126E
J_ADDI              13BE
J_CLR3              137A
J_CLR4              136A
J_CLR_DM            138A
J_MOVEAL            13D2
J_MOVEL             13D2
J_SUBI              13B6
LET                 109E
LET_B               11DA
LET_G               1222
LF                  A
NEXT_PAGE           1104
NL_INTRO            1406
NUM                 1094
NUM_B               11D2
NUM_G               121A
NXT_PG              14F1
OPC4E7_0            13D8
OPC4E7_1            13DA
OPC4E7_2            13EC
OPC4E7_3            13EE
OPC4E7_4            13F0
OPC4E7_5            13F2
OPC4E7_6            13F4
OPC4E7_7            13F6
OPC4E7_8            13F8
OPC4E7_9            13FA
OPC4E7_A            13FC
OPC4E7_B            13FE
OPC4E7_C            1400
OPC4E7_D            1402
OPC4E7_E            1404
PRINT_B             124C
PRINT_BAD           10E6
PRINT_G             1236
PRINT_GOOD          10DC
PROC_END            106E
PROC_STA            1062
SPACER1             156C
SPACER11            15AC
SPACER2             1570
SPACER22            15B0
SPACER3             1574
SPACER33            15B4
SPACER4             1578
SPACER44            15B8
SPACER5             157C
SPACER55            15BC
SPACER6             1580
SPACER66            15C0
SPACER7             1584
SPACER77            15C4
SPACER8             1588
SPACER88            15C8
SPACER9             158C
SPACER99            15CC
SPACERA             1590
SPACERAA            15D0
SPACERB             1594
SPACERBB            15D4
SPACERC             1598
SPACERCC            15D8
SPACERD             159C
SPACERDD            15DC
SPACERE             15A0
SPACEREE            15E0
SPACERF             15A4
SPACERFF            15E4
START               1000
STA_ADDR            1517
STA_MSG             14AD
