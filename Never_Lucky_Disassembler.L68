00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/23/2017 4:55:04 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010B6             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 000018F4             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 0000199B             28  GET_INPUT   LEA         STA_MSG,A1  *Load STA_MSG into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display start address msg
0000102A  4E4F                      30              TRAP        #15         
0000102C                            31              
0000102C  43F9 00001A05             32              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
00001032  103C 0002                 33              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  4EB9 00001062             36              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000103E  4281                      37              CLR.L       D1          *Clear input length from D1
00001040                            38              
00001040  43F9 000019BE             39              LEA         END_MSG,A1  *Load END_MSG into A1
00001046  103C 000E                 40              MOVE.B      #14,D0      *Trap task 14, display end address msg
0000104A  4E4F                      41              TRAP        #15
0000104C                            42              
0000104C  43F9 00001A2D             43              LEA         END_ADDR,A1 *Store input in END_ADDR variable
00001052  103C 0002                 44              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001056  4E4F                      45              TRAP        #15         
00001058                            46              
00001058  4EB9 0000106E             47              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000105E  4281                      48              CLR.L       D1          *Clear input length from D1
00001060                            49              
00001060  4E75                      50              RTS
00001062                            51              
00001062                            52  *--------------------PROC_STA-------------------------------
00001062                            53  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
00001062  4EB9 0000107A             54              JSR         ASCII_HEX   *Convert input into Hex
00001068                            55              
00001068                            56              *assuming all error checking is done before the next instruction (not yet implemented)
00001068                            57              
00001068  2A43                      58              MOVEA.L     D3,A5       *Move hex to STA_ADDR
0000106A  4283                      59              CLR.L       D3          *Clear D3
0000106C  4E75                      60              RTS                     
0000106E                            61  
0000106E                            62  *--------------------PROC_END-------------------------------
0000106E                            63  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000106E                            64              *      does not fall before start
0000106E  4EB9 0000107A             65              JSR         ASCII_HEX   *Convert input into Hex
00001074                            66              
00001074                            67              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            68              
00001074  2C43                      69              MOVE.L      D3,A6       *Move hex to END_ADDR
00001076  4283                      70              CLR.L       D3          *Clear D3
00001078  4E75                      71              RTS
0000107A                            72  
0000107A                            73  *-------------------ASCII_HEX-------------------------------
0000107A  0C01 0000                 74  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000107E  6700 0012                 75              BEQ         AH_DONE     *End subroutine if all converted
00001082  1419                      76              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001084  183C 0039                 77              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001088  B404                      78              CMP.B       D4,D2       *Check if ascii code is for a number or letter
0000108A  6F00 0008                 79              BLE         NUM         *Codes less than $39 imply a number, so branch
0000108E  6000 000E                 80              BRA         LET         *If not a number, must be a letter.            
00001092  4E75                      81  AH_DONE     RTS
00001094                            82  
00001094  183C 0030                 83  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
00001098  9404                      84              SUB.B       D4,D2       *convert to hexadecimal number
0000109A  6000 000C                 85              BRA         FORMAT      *branch to subroutine to store converted hex number
0000109E                            86              
0000109E  183C 0037                 87  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010A2  9404                      88              SUB.B       D4,D2       *convert to hexadecimal letter
000010A4  6000 0002                 89              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010A8                            90  
000010A8  5301                      91  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010AA  D602                      92              ADD.B       D2,D3       *Store converted number in D3
000010AC  0C01 0000                 93              CMPI.B      #$0,D1      *Check if we're all done converting
000010B0  67C8                      94              BEQ         ASCII_HEX   *If not continue conversion
000010B2  E983                      95              ASL.L       #4,D3       *Shift bits to the left to correct position
000010B4  60C4                      96              BRA         ASCII_HEX   *Branch back to label
000010B6                            97              
000010B6                            98  *-------------------DECODE_LOOP-----------------------------
000010B6  3E1D                      99  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010B8  47F9 00001A56            100              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010BE  49F9 00001A96            101              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010C4                           102              
000010C4  4EB9 00001122            103              JSR         INIT_STRS   *Initialize Bad and Good Str
000010CA                           104              
000010CA  4EB9 0000125A            105              JSR         JMP_TBL     *Start opcode identification waterfall
000010D0                           106              
000010D0  4EB9 0000117C            107              JSR         CLEAN_GS    *end of output string.
000010D6                           108              
000010D6  4EB9 00001222            109  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010DC  6000 000C                110              BRA         CONTINUE    *Continue the loop
000010E0  4EB9 00001238            111  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010E6  6000 0002                112              BRA         CONTINUE    *Continue the loop            
000010EA                           113              
000010EA  BCCD                     114  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010EC  6700 0160                115              BEQ         END_OPT     *if we're done, move to end options (ask user what to do)
000010F0                           116              
000010F0                           117                          
000010F0  5205                     118              ADDQ.B      #1,D5       *Increment line counter
000010F2  BA3C 0018                119              CMP.B       #24,D5      *See if page is full
000010F6  6700 0004                120              BEQ         NEXT_PAGE   *Jump to next page prompt
000010FA                           121              
000010FA  60BA                     122              BRA         DECODE_LOOP * Continue loop
000010FC                           123  
000010FC                           124  *-------------------NEXT_PAGE-----------------------------
000010FC  43F9 000019DF            125  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001102  4280                     126              CLR.L       D0          *Make sure D0 is empty
00001104  103C 000E                127              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001108  4E4F                     128              TRAP        #15            
0000110A                           129              
0000110A  103C 000C                130              MOVE.B      #12,D0      *Keyboard echo trap task
0000110E  4281                     131              CLR.L       D1          *Start keyboard echo trap
00001110  4E4F                     132              TRAP        #15         
00001112                           133              
00001112  103C 0005                134              MOVE.B      #5,D0       *Single char trap task
00001116  4E4F                     135              TRAP        #15         
00001118                           136              
00001118  B23C 000D                137              CMP.B       #$D,D1      *Check if ENTER key was pressed
0000111C  66DE                     138              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
0000111E                           139              
0000111E  4285                     140              CLR.L       D5          *Reset page counter
00001120                           141              
00001120  6094                     142              BRA         DECODE_LOOP *Continue the loop         
00001122                           143              
00001122                           144  *-------------------INIT_STRS-----------------------------
00001122  4EB9 00001130            145  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001128  4EB9 00001144            146              JSR         INIT_BAD    *Initialize the bad string
0000112E  4E75                     147              RTS
00001130                           148  *-------------------INIT_GOOD-----------------------------
00001130                           149  INIT_GOOD   
00001130                           150  *            MOVE.B      #'L',(A4)+  *Add to good string  
00001130                           151  *            MOVE.B      #'e',(A4)+ 
00001130                           152  *            MOVE.B      #'g',(A4)+ 
00001130                           153  *            MOVE.B      #'a',(A4)+ 
00001130                           154  *            MOVE.B      #'l',(A4)+
00001130                           155  *            MOVE.B      #' ',(A4)+
00001130                           156  *            MOVE.B      #' ',(A4)+ 
00001130                           157  *            MOVE.B      #':',(A4)+
00001130                           158  *            MOVE.B      #' ',(A4)+ 
00001130                           159  
00001130  18FC 0024                160              MOVE.B      #'$',(A4)+ 
00001134  4EB9 000011DA            161              JSR         HEX_ASCII_G *Now convert opcode to ASCII
0000113A                           162              
0000113A  18FC 0020                163              MOVE.B      #' ',(A4)+  *Add spaces after memory location added
0000113E  18FC 0020                164              MOVE.B      #' ',(A4)+
00001142                           165              
00001142                           166              *Add 'Legal: ', then add opcode (must go from hex to ascii)
00001142                           167              
00001142                           168              
00001142  4E75                     169              RTS
00001144                           170  
00001144                           171  *-------------------INIT_BAD------------------------------            
00001144  16FC 0049                172  INIT_BAD    MOVE.B      #'I',(A3)+  *Add to bad string
00001148  16FC 006C                173              MOVE.B      #'l',(A3)+ 
0000114C  16FC 006C                174              MOVE.B      #'l',(A3)+    
00001150  16FC 0065                175              MOVE.B      #'e',(A3)+ 
00001154  16FC 0067                176              MOVE.B      #'g',(A3)+ 
00001158  16FC 0061                177              MOVE.B      #'a',(A3)+ 
0000115C  16FC 006C                178              MOVE.B      #'l',(A3)+ 
00001160  16FC 003A                179              MOVE.B      #':',(A3)+
00001164  16FC 0020                180              MOVE.B      #' ',(A3)+ 
00001168  16FC 0024                181              MOVE.B      #'$',(A3)+  
0000116C                           182              
0000116C  4EB9 00001194            183              JSR         HEX_ASCII_B *Now convert opcode to ASCII
00001172                           184              
00001172  16FC 0020                185              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001176  16FC 0020                186              MOVE.B      #' ',(A3)+
0000117A                           187              
0000117A                           188              *Add 'Illegal: ', then add opcode (must go from from hex to ascii)
0000117A                           189              
0000117A  4E75                     190              RTS
0000117C                           191  
0000117C                           192  *-------------------GS_CLEAN--------------------------------
0000117C                           193  * This subroutine "cleans" the end of the good string.
0000117C                           194  * Prevents the previous string from showing content in the
0000117C                           195  * current string.
0000117C                           196  *-----------------------------------------------------------
0000117C  4280                     197  CLEAN_GS    CLR.L       D0
0000117E  103C 000F                198              MOVE.B      #15,D0      *Max 15 chars to clean
00001182                           199  
00001182  0C00 0000                200  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001186  6700 000A                201              BEQ         D_CLEAN
0000118A  18FC 0020                202              MOVE.B      #' ',(A4)+
0000118E  5300                     203              SUBI.B      #$1,D0
00001190  60F0                     204              BRA         GS_LOOP
00001192  4E75                     205  D_CLEAN     RTS
00001194                           206              
00001194                           207              
00001194                           208  *-------------------HEX_ASCII_B-----------------------------
00001194  4280                     209  HEX_ASCII_B CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     210              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     211              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     212              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  3207                     213              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000119E  103C 0004                214              MOVE.B      #$4,D0      *Counter
000011A2  6000 0002                215              BRA         ISO_DIG_B   *Begin isolating chars
000011A6                           216              
000011A6  E959                     217  ISO_DIG_B   ROL.W       #4,D1       *Move first significant hex char to least sig position
000011A8                           218              
000011A8  2401                     219              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AA                           220              
000011AA  163C 001C                221              MOVE.B      #28,D3      *Shift left 28 times
000011AE  E7AA                     222              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B0  E99A                     223              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B2                           224              
000011B2  0C02 0009                225              CMPI.B      #$9,D2      *Is it a number?
000011B6  6F00 0006                226              BLE         NUM_B       *If it is, process number
000011BA  6000 000A                227              BRA         LET_B       *If not, process letter
000011BE                           228  
000011BE  0602 0030                229  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
000011C2  6000 000A                230              BRA         ADD_CHAR_B  *add to strings and continue
000011C6                           231              
000011C6  0602 0037                232  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
000011CA  6000 0002                233              BRA         ADD_CHAR_B  *add to strings and continue
000011CE                           234              
000011CE  16C2                     235  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to bad data string
000011D0  5300                     236              SUBI.B      #$1,D0      *decrement counter
000011D2  0C00 0000                237              CMPI.B      #$0,D0      *Check if we're done            
000011D6  6ECE                     238              BGT         ISO_DIG_B   *If not, continue tranlation   
000011D8                           239              
000011D8  4E75                     240              RTS
000011DA                           241              
000011DA                           242  *-------------------HEX_ASCII_G-------------------------------            
000011DA  4280                     243  HEX_ASCII_G CLR.L       D0          *Make sure D0 is empty (Counter)
000011DC  4281                     244              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011DE  4282                     245              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E0  4283                     246              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E2  220D                     247              MOVE.L      A5,D1       *Copy address into D1
000011E4  5501                     248              SUBI.B      #2,D1       *Move addres back one byte (for post increment)
000011E6  103C 0008                249              MOVE.B      #$8,D0      *Counter
000011EA  6000 0002                250              BRA         ISO_DIG_G   *Begin isolating chars
000011EE                           251              
000011EE  E999                     252  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F0                           253              
000011F0  2401                     254              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F2                           255              
000011F2  163C 001C                256              MOVE.B      #28,D3      *Shift left 28 times
000011F6  E7AA                     257              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011F8  E99A                     258              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FA                           259              
000011FA  0C02 0009                260              CMPI.B      #$9,D2      *Is it a number?
000011FE  6F00 0006                261              BLE         NUM_G       *If it is, process number
00001202  6000 000A                262              BRA         LET_G       *If not, process letter
00001206                           263              
00001206  0602 0030                264  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
0000120A  6000 000A                265              BRA         ADD_CHAR_G  *add to strings and continue
0000120E                           266              
0000120E  0602 0037                267  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
00001212  6000 0002                268              BRA         ADD_CHAR_G  *add to strings and continue
00001216                           269  
00001216  18C2                     270  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
00001218  5300                     271              SUBI.B      #$1,D0      *decrement counter
0000121A  0C00 0000                272              CMPI.B      #$0,D0      *Check if we're done            
0000121E  6ECE                     273              BGT         ISO_DIG_G    *If not, continue tranlation   
00001220                           274              
00001220  4E75                     275              RTS
00001222                           276              
00001222                           277  *-------------------PRINT_G---------------------------------
00001222  18FC 0020                278  PRINT_G     MOVE.B      #' ',(A4)+
00001226  16FC 0000                279              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
0000122A  43F9 00001A96            280              LEA         GOOD_STR,A1 *Load good data for printing
00001230  103C 000D                281              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001234  4E4F                     282              TRAP        #15         *Display string
00001236                           283            
00001236  4E75                     284              RTS 
00001238                           285  
00001238                           286  *-------------------PRINT_B---------------------------------
00001238  18FC 0020                287  PRINT_B     MOVE.B      #' ',(A4)+
0000123C  18FC 0000                288              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001240  43F9 00001A56            289              LEA         BAD_STR,A1 *Load good data for printing
00001246  103C 000D                290              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000124A  4E4F                     291              TRAP        #15         *Display string
0000124C                           292              
0000124C  4E75                     293              RTS 
0000124E                           294  
0000124E                           295  *-------------------END_OPT---------------------------------
0000124E  4EF9 00001254            296  END_OPT     JMP         DONE        *Jump to done for now untill end options logic is implemented
00001254                           297              
00001254                           298  *-----------------------DONE--------------------------------
00001254  103C 0009                299  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
00001258  4E4F                     300              TRAP        #15         *Halt program, Trap#15 task 9
0000125A                           301              
0000125A                           302  *---------------Variables and Constants---------------------
0000125A                           303              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
0000125A                           304  
0000125A                           305  
0000125A  4282                     306  JMP_TBL     CLR.L       D2
0000125C  3407                     307              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000125E  4281                     308              CLR.L       D1
00001260  123C 000C                309              MOVE.B      #12,D1      *Moves 12 into D1
00001264  E26A                     310              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
00001266                           311                          
00001266  B43C 0000                312  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
0000126A  6600 000A                313              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
0000126E  4EB9 00001392            314              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
00001274  4E75                     315              RTS                     *Finished all jumping; whole instruction should be identified at this point
00001276                           316              
00001276  B43C 0001                317  JMP_1       CMP.B       #$1,D2
0000127A  6600 000A                318              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
0000127E  4EB9 0000145E            319              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
00001284  4E75                     320              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
00001286                           321             
00001286  B43C 0002                322  JMP_2       CMP.B       #$2,D2
0000128A  6600 000A                323              BNE         JMP_3 
0000128E  4EB9 000013BC            324              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
00001294  4E75                     325              RTS
00001296                           326              
00001296  B43C 0003                327  JMP_3       CMP.B       #$3,D2
0000129A  6600 000A                328              BNE         JMP_4
0000129E  4EB9 000013E0            329              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
000012A4  4E75                     330              RTS
000012A6                           331           
000012A6  B43C 0004                332  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
000012AA  6600 000A                333              BNE         JMP_5
000012AE  4EB9 00001404            334              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
000012B4  4E75                     335              RTS
000012B6                           336              
000012B6  B43C 0005                337  JMP_5       CMP.B       #$5,D2
000012BA  6600 000A                338              BNE         JMP_6
000012BE  4EB9 00001488            339              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
000012C4  4E75                     340              RTS
000012C6                           341              
000012C6  B43C 0006                342  JMP_6       CMP.B       #$6,D2
000012CA  6600 000A                343              BNE         JMP_7
000012CE  4EB9 00001442            344              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
000012D4  4E75                     345              RTS
000012D6                           346              
000012D6  B43C 0007                347  JMP_7       CMP.B       #$7,D2
000012DA  6600 000A                348              BNE         JMP_8
000012DE  4EB9 000014A4            349              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
000012E4  4E75                     350              RTS
000012E6                           351              
000012E6  B43C 0008                352  JMP_8       CMP.B       #$8,D2
000012EA  6600 000A                353              BNE         JMP_9
000012EE  4EB9 00001446            354              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000012F4  4E75                     355              RTS
000012F6                           356              
000012F6  B43C 0009                357  JMP_9       CMP.B       #$9,D2
000012FA  6600 000A                358              BNE         JMP_A
000012FE  4EB9 000014C2            359              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
00001304  4E75                     360              RTS
00001306                           361              
00001306  B43C 000A                362  JMP_A       CMP.B       #$A,D2
0000130A  6600 0008                363              BNE         JMP_B
0000130E  4EB8 10E0                364              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
00001312  4E75                     365              RTS
00001314                           366              
00001314  B43C 000B                367  JMP_B       CMP.B       #$B,D2
00001318  6600 0008                368              BNE         JMP_C
0000131C  4EB8 10E0                369              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
00001320  4E75                     370              RTS
00001322                           371              
00001322  B43C 000C                372  JMP_C       CMP.B       #$C,D2
00001326  6600 000A                373              BNE         JMP_D
0000132A  4EB9 0000144A            374              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
00001330  4E75                     375              RTS
00001332                           376              
00001332  B43C 000D                377  JMP_D       CMP.B       #$D,D2
00001336  6600 000A                378              BNE         JMP_E   
0000133A  4EB9 0000144E            379              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
00001340  4E75                     380              RTS
00001342                           381              
00001342  B43C 000F                382  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
00001346  6700 FD98                383              BEQ         INVALID     *If first hex value is F, jump to INVALID
0000134A  4EB9 00001452            384              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001350  4E75                     385              RTS
00001352                           386   
00001352  4282                     387  J_CLR4      CLR.L       D2                                
00001354  3407                     388              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001356  4281                     389              CLR.L       D1
00001358  E94A                     390              LSL.W       #4,D2       *Clear the most sig hex digit
0000135A  123C 000C                391              MOVE.B      #12,D1      *Moves 12 into D1
0000135E  E26A                     392              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001360  4E75                     393              RTS                     *Return back to JMP_Xn    
00001362                           394              
00001362  4282                     395  J_CLR3      CLR.L       D2          
00001364  3407                     396              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001366  4281                     397              CLR.L       D1
00001368  E94A                     398              LSL.W       #4,D2       *Clear the most sig hex digit
0000136A  123C 000D                399              MOVE.B      #13,D1      *Moves 13 into D1
0000136E  E26A                     400              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001370  4E75                     401              RTS                     *Return back to JMP_Xn  
00001372                           402  
00001372  4282                     403  J_CLR1  CLR.L       D2          
00001374  3407                     404          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001376  4281                     405          CLR.L       D1
00001378  EF4A                     406          LSL.W       #7,D2           *Clear the most sig 7 bits
0000137A  123C 0010                407          MOVE.B      #16,D1          *Moves 16 into D1
0000137E  E26A                     408          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001380  4E75                     409          RTS                         *Return back to JMP_Xn  
00001382                           410       
00001382  4282                     411  J_CLR_DM    CLR.L       D2          
00001384  3407                     412              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001386  4281                     413              CLR.L       D1
00001388  EF4A                     414              LSL.W       #7,D2       *Clear the most sig 7 bits
0000138A  123C 0011                415              MOVE.B      #17,D1      *Moves 17 into D1
0000138E  E26A                     416              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001390  4E75                     417              RTS                     *Return back to JMP_Xn     
00001392                           418   
00001392                           419  
00001392                           420          
00001392  4EB8 1352                421  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
00001396  B43C 0004                422              CMP.B       #$4,D2      *Is the next hex digit 4?
0000139A  6700 0010                423              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
0000139E  B43C 0005                424              CMP.B       #$5,D2      *Is the next hex digit 5?
000013A2  6700 0010                425              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
000013A6  4EB8 10E0                426              JSR         INVALID     *If neither, OPCODE is invalid
000013AA  4E75                     427              RTS
000013AC                           428  
000013AC  4EB9 00001456            429  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
000013B2  4E75                     430              RTS
000013B4                           431              
000013B4  4EB9 0000145A            432  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
000013BA  4E75                     433              RTS              
000013BC                           434  
000013BC  4EB8 1382                435  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013C0  B43C 0001                436              CMP.B       #$1,D2      *is the DEST MODE 1?
000013C4  6700 000A                437              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000013C8  4EB9 000013D8            438              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000013CE  4E75                     439              RTS
000013D0                           440  
000013D0  4EB9 000014E4            441  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000013D6  4E75                     442              RTS
000013D8                           443  
000013D8  4EB9 000014E6            444  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000013DE  4E75                     445              RTS                           
000013E0  4EB8 1382                446  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000013E4  B43C 0001                447              CMP.B       #$1,D2      *is the DEST MODE 1?
000013E8  6700 000A                448              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000013EC  4EB9 000013FC            449              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000013F2  4E75                     450              RTS
000013F4                           451  
000013F4  4EB9 000014E8            452  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000013FA  4E75                     453              RTS
000013FC                           454  
000013FC  4EB9 000014EA            455  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
00001402  4E75                     456              RTS
00001404  4EB8 1352                457  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
00001408  B43C 0007                458              CMP.B       #7,D2       *Is the next hex digit 7?
0000140C  6700 001C                459              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001410  4EB8 1372                460              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
00001414  B43C 0001                461              CMP.B       #1,D2       *Is the last bit 1?
00001418  6700 0018                462              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
0000141C  B43C 0000                463              CMP.B       #0,D2       *Is the last bit 0?
00001420  6700 0018                464              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
00001424  4EB8 10E0                465              JSR         INVALID     *If none of the above, OPCODE is invalid
00001428  4E75                     466              RTS
0000142A                           467                                           
0000142A                           468              
0000142A  4EB9 0000145E            469  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001430  4E75                     470              RTS
00001432                           471              
00001432  4EB9 000014E0            472  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
00001438  4E75                     473              RTS
0000143A                           474              
0000143A  4EB9 000014E2            475  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001440  4E75                     476              RTS
00001442                           477              
00001442                           478  
00001442  4EB8 10E0                479  JMP_6X      JSR         INVALID     *Temp, remove once implemented
00001446                           480  
00001446  4EB8 10E0                481  JMP_8X      JSR         INVALID     *Temp, remove once implemented
0000144A                           482  
0000144A  4EB8 10E0                483  JMP_CX      JSR         INVALID     *Temp, remove once implemented
0000144E                           484  
0000144E  4EB8 10E0                485  JMP_DX      JSR         INVALID     *Temp, remove once implemented
00001452                           486  
00001452  4EB8 10E0                487  JMP_EX      JSR         INVALID     *Temp, remove once implemented
00001456                           488  
00001456                           489     
00001456  4EB8 10E0                490  OPC_04XX    JSR         INVALID     *Temp, remove once implemented
0000145A                           491  
0000145A  4EB8 10E0                492  OPC_05XX    JSR         INVALID     *Temp, remove once implemented
0000145E                           493  
0000145E                           494  JMP_47X      
0000145E                           495  
0000145E                           496  
0000145E                           497  
0000145E  18FC 004D                498  OPC_1XXX    MOVE.B      #'M',(A4)+
00001462  18FC 004F                499              MOVE.B      #'O',(A4)+
00001466  18FC 0056                500              MOVE.B      #'V',(A4)+
0000146A  18FC 0045                501              MOVE.B      #'E',(A4)+
0000146E  18FC 002E                502              MOVE.B      #'.',(A4)+
00001472  18FC 0042                503              MOVE.B      #'B',(A4)+
00001476  18FC 0020                504              MOVE.B      #' ',(A4)+
0000147A  18FC 0020                505              MOVE.B      #' ',(A4)+
0000147E                           506              *YOU DO NOT NEED TO MANUALLY SET SIZE CODE IF YOU USE A
0000147E                           507              *GET SIZE SUBROUTINE CALL.
0000147E  4284                     508              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001480  4EB9 00001622            509              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001486  4E75                     510              RTS
00001488                           511  
00001488  18FC 0041                512  OPC_5XXX    MOVE.B      #'A',(A4)+
0000148C  18FC 0044                513              MOVE.B      #'D',(A4)+
00001490  18FC 0044                514              MOVE.B      #'D',(A4)+
00001494  18FC 0051                515              MOVE.B      #'Q',(A4)+
00001498  18FC 002E                516              MOVE.B      #'.',(A4)+
0000149C                           517              *NEED to Determine sizes here
0000149C  4EB9 000014FC            518              JSR         GET_SIZE_2
000014A2                           519              
000014A2                           520              *JUMP to EACODE table
000014A2  4E75                     521              RTS
000014A4                           522  
000014A4  18FC 004D                523  OPC_7XXX    MOVE.B      #'M',(A4)+
000014A8  18FC 004F                524              MOVE.B      #'O',(A4)+
000014AC  18FC 0056                525              MOVE.B      #'V',(A4)+
000014B0  18FC 0045                526              MOVE.B      #'E',(A4)+
000014B4  18FC 0051                527              MOVE.B      #'Q',(A4)+
000014B8  18FC 002E                528              MOVE.B      #'.',(A4)+
000014BC  18FC 004C                529              MOVE.B      #'L',(A4)+
000014C0                           530              
000014C0                           531              *Needs special EA decode logic
000014C0                           532              *jump to EACODE table
000014C0  4E75                     533              RTS
000014C2                           534  
000014C2  18FC 0053                535  OPC_9XXX    MOVE.B      #'S',(A4)+
000014C6  18FC 0055                536              MOVE.B      #'U',(A4)+
000014CA  18FC 0042                537              MOVE.B      #'B',(A4)+
000014CE  18FC 002E                538              MOVE.B      #'.',(A4)+
000014D2                           539              *NEED to Determine sizes here (opmode 3 bits)
000014D2  4EB9 000014EC            540              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000014D8  4EB9 00001522            541              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
000014DE                           542              *jump to EACODE table
000014DE  4E75                     543              RTS
000014E0                           544  
000014E0  4E75                     545  OPC_LEA     RTS
000014E2                           546  
000014E2                           547  
000014E2  4E75                     548  OPC_MOVEM   RTS
000014E4                           549  
000014E4  4E75                     550  OPC_MOVEAL  RTS
000014E6                           551  
000014E6  4E75                     552  OPC_MOVEL   RTS
000014E8                           553  
000014E8  4E75                     554  OPC_MOVEAW RTS
000014EA                           555  
000014EA  4E75                     556  OPC_MOVEW  RTS
000014EC                           557  
000014EC                           558  
000014EC  4284                     559  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
000014EE  3807                     560              MOVE.W      D7,D4       *Copy untouched opcode into D4
000014F0  EF4C                     561              LSL.W       #7,D4       *Clear more significant bits
000014F2  4283                     562              CLR.L       D3          *Make sure D3 is clear for shifting
000014F4  163C 000D                563              MOVE.B      #13,D3      *Shifting 13 times
000014F8  E66C                     564              LSR.W       D3,D4       *Move size bits to LSB position
000014FA  4E75                     565              RTS
000014FC                           566  
000014FC  4284                     567  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
000014FE  3807                     568              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001500  E14C                     569              LSL.W       #8,D4       *Clear more significant bits
00001502  4283                     570              CLR.L       D3          *Make sure D3 is clear for shifting
00001504  163C 000E                571              MOVE.B      #14,D3      *Shifting 14 times
00001508  E66C                     572              LSR.W       D3,D4       *Move size bits to LSB position
0000150A  4E75                     573              RTS
0000150C                           574  
0000150C  4284                     575  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
0000150E  3807                     576              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001510  4283                     577              CLR.L       D3          *Make sure D3 is clear for shifting
00001512  163C 0009                578              MOVE.B      #9,D3       *Shift 9 times to the left
00001516  E76C                     579              LSL.W       D3,D4       *Clear more significant bits
00001518  4283                     580              CLR.L       D3          *Make sure D3 is clear for shifting
0000151A  163C 000F                581              MOVE.B      #15,D3      *Shifting 15 times
0000151E  E66C                     582              LSR.W       D3,D4       *Move size bits to LSB position
00001520  4E75                     583              RTS
00001522                           584  
00001522  B83C 0000                585  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00001526  6700 002E                586              BEQ         B_EA
0000152A  B83C 0001                587              CMP.B       #1,D4       *Is it a W, <ea>,dn
0000152E  6700 003A                588              BEQ         W_EA
00001532  B83C 0002                589              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001536  6700 0046                590              BEQ         L_EA
0000153A                           591  
0000153A  B83C 0004                592              CMP.B       #4,D4       *Is it a B, dn,<ea>
0000153E  6700 0052                593              BEQ         B_DN
00001542  B83C 0005                594              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001546  6700 005E                595              BEQ         W_DN
0000154A  B83C 0006                596              CMP.B       #6,D4       *Is it a L, dn,<ea>
0000154E  6700 006A                597              BEQ         L_DN        
00001552  6000 FB8C                598              BRA         INVALID     *Got here, must be invalid data.
00001556                           599              
00001556  18FC 0042                600  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
0000155A  18FC 0020                601              MOVE.B      #' ',(A4)+
0000155E  18FC 0020                602              MOVE.B      #' ',(A4)+
00001562  4EB9 000015CE            603              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
00001568  4E75                     604              RTS
0000156A                           605  
0000156A  18FC 0057                606  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
0000156E  18FC 0020                607              MOVE.B      #' ',(A4)+
00001572  18FC 0020                608              MOVE.B      #' ',(A4)+
00001576  4EB9 000015CE            609              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
0000157C  4E75                     610              RTS
0000157E                           611  
0000157E  18FC 004C                612  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00001582  18FC 0020                613              MOVE.B      #' ',(A4)+
00001586  18FC 0020                614              MOVE.B      #' ',(A4)+
0000158A  4EB9 000015CE            615              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
00001590  4E75                     616              RTS
00001592                           617  
00001592  18FC 0042                618  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001596  18FC 0020                619              MOVE.B      #' ',(A4)+
0000159A  18FC 0020                620              MOVE.B      #' ',(A4)+
0000159E  4EB9 000015E4            621              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015A4  4E75                     622              RTS
000015A6                           623  
000015A6  18FC 0057                624  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
000015AA  18FC 0020                625              MOVE.B      #' ',(A4)+
000015AE  18FC 0020                626              MOVE.B      #' ',(A4)+
000015B2  4EB9 000015E4            627              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015B8  4E75                     628              RTS
000015BA                           629  
000015BA  18FC 004C                630  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
000015BE  18FC 0020                631              MOVE.B      #' ',(A4)+
000015C2  18FC 0020                632              MOVE.B      #' ',(A4)+
000015C6  4EB9 000015E4            633              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000015CC  4E75                     634              RTS            
000015CE                           635              
000015CE                           636              
000015CE                           637              
000015CE                           638              
000015CE                           639              
000015CE                           640              
000015CE                           641              
000015CE                           642  
000015CE                           643  
000015CE                           644  
000015CE                           645  -------------------- end include --------------------
000015CE                           646              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
000015CE                           647  
000015CE                           648  
000015CE  4EB9 00001600            649  EA_SRC      JSR         GEN_EA_CODE *Deal with EA code First
000015D4  18FC 002C                650              MOVE.B      #',',(A4)+
000015D8  18FC 0044                651              MOVE.B      #'D',(A4)+
000015DC  4EB9 00001668            652              JSR         REG_CODE    *Decode Dn and add number to string
000015E2  4E75                     653              RTS
000015E4                           654  
000015E4  18FC 0044                655  DN_SRC      MOVE.B      #'D',(A4)+
000015E8  4EB9 00001668            656              JSR         REG_CODE     *Decode Dn and add number to string
000015EE  18FC 002C                657              MOVE.B      #',',(A4)+
000015F2  4EB9 00001600            658              JSR         GEN_EA_CODE *Deal with EA code Second
000015F8  4E75                     659              RTS
000015FA                           660  
000015FA                           661  MM_OP_ORD 
000015FA  4E75                     662              RTS
000015FC                           663  
000015FC                           664  MM_EA_SRC   *Deal with EA code first
000015FC                           665              *Deal with list second
000015FC  4E75                     666              RTS
000015FE                           667  
000015FE                           668  MM_LS_SRC   *Deal with list first
000015FE                           669              *Deal with EA code second
000015FE  4E75                     670              RTS
00001600                           671  
00001600                           672  
00001600                           673  
00001600  4283                     674  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001602  4286                     675              CLR.L       D6          *Make sure D6 is clear
00001604  4281                     676              CLR.L       D1          *Make sure D1 is clear for shifting
00001606                           677              
00001606  3607                     678              MOVE.W      D7,D3       *Move untouched opcode into D3
00001608  3C07                     679              MOVE.W      D7,D6       *Move untouched opcode into D6
0000160A                           680              
0000160A  123C 000A                681              MOVE.B      #10,D1      *Shifting to isolate MODE
0000160E  E36E                     682              LSL.W       D1,D6       
00001610  123C 000D                683              MOVE.B      #13,D1
00001614  E26E                     684              LSR.W       D1,D6       *Move MODE bits to LSB position
00001616                           685              
00001616  E36B                     686              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001618  E26B                     687              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
0000161A                           688              
0000161A  4EB9 0000167E            689              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001620  4E75                     690              RTS
00001622                           691              
00001622  4283                     692  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001624  4286                     693              CLR.L       D6          *Make sure D6 is clear
00001626  4281                     694              CLR.L       D1          *Make sure D1 is clear for shifting
00001628                           695              
00001628  3607                     696              MOVE.W      D7,D3       *Move untouched opcode into D3
0000162A  3C07                     697              MOVE.W      D7,D6       *Move untouched opcode into D6
0000162C                           698              
0000162C  123C 000A                699              MOVE.B      #10,D1      *Shifting to isolate MODE
00001630  E36E                     700              LSL.W       D1,D6       
00001632  123C 000D                701              MOVE.B      #13,D1
00001636  E26E                     702              LSR.W       D1,D6       *Move MODE bits to LSB position
00001638                           703              
00001638  E36B                     704              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
0000163A  E26B                     705              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
0000163C                           706              
0000163C  4EB9 0000167E            707              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001642                           708              
00001642  18FC 002C                709              MOVE.B      #',',(A4)+  *SEPERATOR
00001646                           710              
00001646  4283                     711              CLR.L       D3          *Make sure D3 is clear
00001648  4286                     712              CLR.L       D6          *Make sure D6 is clear
0000164A  4281                     713              CLR.L       D1          *Make sure D1 is clear for shifting
0000164C                           714              
0000164C  3607                     715              MOVE.W      D7,D3       *Move untouched opcode into D3
0000164E  3C07                     716              MOVE.W      D7,D6       *Move untouched opcode into D6
00001650                           717              
00001650  123C 0007                718              MOVE.B      #7,D1      *Shifting to isolate MODE
00001654  E36E                     719              LSL.W       D1,D6       
00001656  123C 000D                720              MOVE.B      #13,D1
0000165A  E26E                     721              LSR.W       D1,D6       *Move MODE bits to LSB position
0000165C                           722              
0000165C  E94B                     723              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
0000165E  E26B                     724              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001660                           725              
00001660  4EB9 0000167E            726              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001666                           727              
00001666  4E75                     728              RTS
00001668                           729              
00001668                           730              
00001668  4283                     731  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
0000166A  3607                     732              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
0000166C  E94B                     733              LSL.W       #4,D3       *Isolate bits and move to LSB position
0000166E  4282                     734              CLR.L       D2
00001670  143C 000D                735              MOVE.B      #13,D2
00001674  E46B                     736              LSR.W       D2,D3
00001676  4EB9 00001716            737              JSR         REG_TBL     *Jump to register table.
0000167C  4E75                     738              RTS
0000167E                           739  
0000167E                           740  
0000167E  BC3C 0000                741  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
00001682  6700 002E                742              BEQ         DRD
00001686  BC3C 0001                743              CMP.B       #1,D6
0000168A  6700 0032                744              BEQ         ARD
0000168E  BC3C 0002                745              CMP.B       #2,D6
00001692  6700 0036                746              BEQ         ARI
00001696  BC3C 0003                747              CMP.B       #3,D6
0000169A  6700 0042                748              BEQ         ARI_INC
0000169E  BC3C 0004                749              CMP.B       #4,D6
000016A2  6700 0052                750              BEQ         ARI_DEC
000016A6  BC3C 0007                751              CMP.B       #7,D6
000016AA  6700 0062                752              BEQ         ABS_ADDR
000016AE  4EF8 10E0                753              JMP         INVALID     *Got here? Must be bad data.
000016B2                           754  
000016B2  18FC 0044                755  DRD         MOVE.B      #'D',(A4)+
000016B6  4EB9 00001716            756              JSR         REG_TBL     *Reg num should be in D3
000016BC  4E75                     757              RTS
000016BE                           758  
000016BE  18FC 0041                759  ARD         MOVE.B      #'A',(A4)+
000016C2  4EB9 00001716            760              JSR         REG_TBL     *Reg num should be in D3
000016C8  4E75                     761              RTS
000016CA                           762  
000016CA  18FC 0028                763  ARI         MOVE.B      #'(',(A4)+
000016CE  18FC 0041                764              MOVE.B      #'A',(A4)+
000016D2  4EB9 00001716            765              JSR         REG_TBL     *Reg num should be in D3
000016D8  18FC 0029                766              MOVE.B      #')',(A4)+
000016DC  4E75                     767              RTS
000016DE                           768  
000016DE  18FC 0028                769  ARI_INC     MOVE.B      #'(',(A4)+
000016E2  18FC 0041                770              MOVE.B      #'A',(A4)+
000016E6  4EB9 00001716            771              JSR         REG_TBL     *Reg num should be in D3
000016EC  18FC 0029                772              MOVE.B      #')',(A4)+
000016F0  18FC 002B                773              MOVE.B      #'+',(A4)+
000016F4  4E75                     774              RTS
000016F6                           775  
000016F6  18FC 002D                776  ARI_DEC     MOVE.B      #'-',(A4)+
000016FA  18FC 0028                777              MOVE.B      #'(',(A4)+
000016FE  18FC 0041                778              MOVE.B      #'A',(A4)+
00001702  4EB9 00001716            779              JSR         REG_TBL     *Reg num should be in D3
00001708  18FC 0029                780              MOVE.B      #')',(A4)+
0000170C  4E75                     781              RTS
0000170E                           782  
0000170E  4EB9 0000178A            783  ABS_ADDR    JSR         ABS_TBL
00001714  4E75                     784              RTS
00001716                           785              
00001716  B63C 0000                786  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
0000171A  6700 003E                787              BEQ         NUM_0
0000171E  B63C 0001                788              CMP.B       #1,D3
00001722  6700 003C                789              BEQ         NUM_1
00001726  B63C 0002                790              CMP.B       #2,D3
0000172A  6700 003A                791              BEQ         NUM_2
0000172E  B63C 0003                792              CMP.B       #3,D3
00001732  6700 0038                793              BEQ         NUM_3
00001736  B63C 0004                794              CMP.B       #4,D3
0000173A  6700 0036                795              BEQ         NUM_4
0000173E  B63C 0005                796              CMP.B       #5,D3
00001742  6700 0034                797              BEQ         NUM_5
00001746  B63C 0006                798              CMP.B       #6,D3
0000174A  6700 0032                799              BEQ         NUM_6
0000174E  B63C 0007                800              CMP.B       #7,D3
00001752  6700 0030                801              BEQ         NUM_7
00001756  4EF8 10E0                802              JMP         INVALID     *Got here? Must be bad data.
0000175A                           803              
0000175A  18FC 0030                804  NUM_0       MOVE.B      #'0',(A4)+
0000175E  4E75                     805              RTS              
00001760  18FC 0031                806  NUM_1       MOVE.B      #'1',(A4)+
00001764  4E75                     807              RTS
00001766  18FC 0032                808  NUM_2       MOVE.B      #'2',(A4)+
0000176A  4E75                     809              RTS
0000176C  18FC 0033                810  NUM_3       MOVE.B      #'3',(A4)+
00001770  4E75                     811              RTS
00001772  18FC 0034                812  NUM_4       MOVE.B      #'4',(A4)+
00001776  4E75                     813              RTS
00001778  18FC 0035                814  NUM_5       MOVE.B      #'5',(A4)+
0000177C  4E75                     815              RTS
0000177E  18FC 0036                816  NUM_6       MOVE.B      #'6',(A4)+
00001782  4E75                     817              RTS
00001784  18FC 0037                818  NUM_7       MOVE.B      #'7',(A4)+
00001788  4E75                     819              RTS
0000178A                           820  
0000178A  B63C 0000                821  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
0000178E  6700 0016                822              BEQ         ABW
00001792  B63C 0001                823              CMP.B       #1,D3
00001796  6700 001E                824              BEQ         ABL
0000179A  B63C 0004                825              CMP.B       #4,D3
0000179E  6700 0026                826              BEQ         IDATA
000017A2  4EF8 10E0                827              JMP         INVALID     *Got here? Must be bad data.
000017A6                           828              
000017A6  18FC 0024                829  ABW         MOVE.B      #'$',(A4)+
000017AA  4281                     830              CLR.L       D1          *Make sure D1 is clear
000017AC  321D                     831              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
000017AE  4EB9 00001870            832              JSR         W_H2A       *convert absolute value to ascii and add to good string
000017B4  4E75                     833              RTS
000017B6                           834  
000017B6  18FC 0024                835  ABL         MOVE.B      #'$',(A4)+
000017BA  4281                     836              CLR.L       D1          *Make sure D1 is clear
000017BC  221D                     837              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
000017BE  4EB9 000018B2            838              JSR         L_H2A
000017C4  4E75                     839              RTS
000017C6                           840              
000017C6  18FC 0023                841  IDATA       MOVE.B      #'#',(A4)+
000017CA  18FC 0024                842              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
000017CE  4EB9 000017D6            843              JSR         IMD_TBL
000017D4  4E75                     844              RTS
000017D6                           845              
000017D6  B83C 0000                846  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
000017DA  6700 002E                847              BEQ         B_IMD       
000017DE  B83C 0004                848              CMP.B       #4,D4
000017E2  6700 0026                849              BEQ         B_IMD
000017E6                           850  
000017E6  B83C 0001                851              CMP.B       #1,D4       *Is it a word size code?
000017EA  6700 002A                852              BEQ         W_IMD
000017EE  B83C 0005                853              CMP.B       #5,D4
000017F2  6700 0022                854              BEQ         W_IMD
000017F6                           855              
000017F6  B83C 0002                856              CMP.B       #2,D4       *Is it a long word size code?
000017FA  6700 0026                857              BEQ         L_IMD
000017FE  B83C 0006                858              CMP.B       #6,D4
00001802  6700 001E                859              BEQ         L_IMD
00001806                           860              
00001806  6000 F8D8                861              BRA         INVALID     *Got here? Must be bad data.
0000180A                           862              
0000180A  4281                     863  B_IMD       CLR.L       D1
0000180C  321D                     864              MOVE.W      (A5)+,D1    *Make sure D1 is clear
0000180E  4EB9 0000182E            865              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
00001814  4E75                     866              RTS
00001816                           867  
00001816  4281                     868  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001818  321D                     869              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
0000181A  4EB9 00001870            870              JSR         W_H2A
00001820  4E75                     871              RTS
00001822                           872  
00001822  4281                     873  L_IMD       CLR.L       D1          *Make sure D1 is clear
00001824  221D                     874              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
00001826  4EB9 000018B2            875              JSR         L_H2A
0000182C  4E75                     876              RTS
0000182E                           877                                 
0000182E                           878  
0000182E                           879  
0000182E                           880  
0000182E  4280                     881  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001830  4282                     882              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001832  4283                     883              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001834  103C 0002                884              MOVE.B      #$2,D0      *Counter
00001838  6000 0002                885              BRA         B_ISO_DIG   *Begin isolating chars
0000183C                           886              
0000183C  E919                     887  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
0000183E                           888              
0000183E  1401                     889              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001840                           890              
00001840  163C 0004                891              MOVE.B      #4,D3      *Shift left 28 times
00001844  E72A                     892              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00001846  E91A                     893              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00001848                           894              
00001848  0C02 0009                895              CMPI.B      #$9,D2      *Is it a number?
0000184C  6F00 0006                896              BLE         B_NUM       *If it is, process number
00001850  6000 000A                897              BRA         B_LET       *If not, process letter
00001854                           898              
00001854  0602 0030                899  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00001858  6000 000A                900              BRA         B_ADD_CHAR  *add to strings and continue
0000185C                           901              
0000185C  0602 0037                902  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00001860  6000 0002                903              BRA         B_ADD_CHAR  *add to strings and continue
00001864                           904  
00001864  18C2                     905  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00001866  5300                     906              SUBI.B      #$1,D0      *decrement counter
00001868  0C00 0000                907              CMPI.B      #$0,D0      *Check if we're done            
0000186C  6ECE                     908              BGT         B_ISO_DIG   *If not, continue tranlation   
0000186E                           909              
0000186E  4E75                     910              RTS
00001870                           911  
00001870  4280                     912  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001872  4282                     913              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001874  4283                     914              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00001876  103C 0004                915              MOVE.B      #$4,D0      *Counter
0000187A  6000 0002                916              BRA         W_ISO_DIG   *Begin isolating chars
0000187E                           917              
0000187E  E959                     918  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001880                           919              
00001880  1401                     920              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00001882                           921              
00001882  163C 000C                922              MOVE.B      #12,D3      *Shift left 28 times
00001886  E76A                     923              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
00001888  E95A                     924              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
0000188A                           925              
0000188A  0C02 0009                926              CMPI.B      #$9,D2      *Is it a number?
0000188E  6F00 0006                927              BLE         W_NUM       *If it is, process number
00001892  6000 000A                928              BRA         W_LET       *If not, process letter
00001896                           929              
00001896  0602 0030                930  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
0000189A  6000 000A                931              BRA         W_ADD_CHAR  *add to strings and continue
0000189E                           932              
0000189E  0602 0037                933  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000018A2  6000 0002                934              BRA         W_ADD_CHAR  *add to strings and continue
000018A6                           935  
000018A6  18C2                     936  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018A8  5300                     937              SUBI.B      #$1,D0      *decrement counter
000018AA  0C00 0000                938              CMPI.B      #$0,D0      *Check if we're done            
000018AE  6ECE                     939              BGT         W_ISO_DIG   *If not, continue tranlation   
000018B0                           940              
000018B0  4E75                     941              RTS
000018B2  4280                     942  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000018B4  4282                     943              CLR.L       D2          *Make sure D2 is empty (each individual char)
000018B6  4283                     944              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000018B8  103C 0008                945              MOVE.B      #$8,D0      *Counter
000018BC  6000 0002                946              BRA         L_ISO_DIG   *Begin isolating chars
000018C0                           947              
000018C0  E999                     948  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
000018C2                           949              
000018C2  1401                     950              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
000018C4                           951              
000018C4  163C 001C                952              MOVE.B      #28,D3      *Shift left 28 times
000018C8  E7AA                     953              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000018CA  E99A                     954              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000018CC                           955              
000018CC  0C02 0009                956              CMPI.B      #$9,D2      *Is it a number?
000018D0  6F00 0006                957              BLE         L_NUM       *If it is, process number
000018D4  6000 000A                958              BRA         L_LET       *If not, process letter
000018D8                           959              
000018D8  0602 0030                960  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000018DC  6000 000A                961              BRA         L_ADD_CHAR  *add to strings and continue
000018E0                           962              
000018E0  0602 0037                963  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000018E4  6000 0002                964              BRA         L_ADD_CHAR  *add to strings and continue
000018E8                           965  
000018E8  18C2                     966  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000018EA  5300                     967              SUBI.B      #$1,D0      *decrement counter
000018EC  0C00 0000                968              CMPI.B      #$0,D0      *Check if we're done            
000018F0  6ECE                     969              BGT         L_ISO_DIG   *If not, continue tranlation   
000018F2                           970              
000018F2  4E75                     971              RTS
000018F4                           972  
000018F4                           973  
000018F4                           974  
000018F4                           975  
000018F4                           976  
000018F4                           977  -------------------- end include --------------------
000018F4                           978  
000018F4  =0000000D                979  CR          EQU         $0D
000018F4  =0000000A                980  LF          EQU         $0A
000018F4                           981  
000018F4= 2D 2D 2D 2D 2D 2D ...    982  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
0000191E= 48 65 6E 72 79 20 ...    983              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00001947= 43 53 53 20 34 32 ...    984              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
00001970= 2D 2D 2D 2D 2D 2D ...    985              DC.B        '----------------------------------------',CR,LF,0
0000199B                           986              
0000199B= 45 6E 74 65 72 20 ...    987  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
000019BE= 45 6E 74 65 72 20 ...    988  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000019DF= 50 72 65 73 73 20 ...    989  NXT_PG      DC.B        'Press enter key to contiune reading',CR,LF,0
00001A05                           990  
00001A05                           991  STA_ADDR    DS.B        40
00001A2D                           992  END_ADDR    DS.B        40
00001A55                           993  
00001A55                           994  
00001A55                           995  
00001A55                           996  
00001A56= 00000001                 997  BAD_STR     DC.L        1
00001A5A                           998  
00001A5A= 00000050                 999  SPACER11    DC.L        80
00001A5E= 00000050                1000  SPACER22    DC.L        80
00001A62= 00000050                1001  SPACER33    DC.L        80
00001A66= 00000050                1002  SPACER44    DC.L        80
00001A6A= 00000050                1003  SPACER55    DC.L        80
00001A6E= 00000050                1004  SPACER66    DC.L        80
00001A72= 00000050                1005  SPACER77    DC.L        80
00001A76= 00000050                1006  SPACER88    DC.L        80
00001A7A= 00000050                1007  SPACER99    DC.L        80
00001A7E= 00000050                1008  SPACERAA    DC.L        80
00001A82= 00000050                1009  SPACERBB    DC.L        80
00001A86= 00000050                1010  SPACERCC    DC.L        80
00001A8A= 00000050                1011  SPACERDD    DC.L        80
00001A8E= 00000050                1012  SPACEREE    DC.L        80
00001A92= 00000050                1013  SPACERFF    DC.L        80
00001A96                          1014  
00001A96= 00000001                1015  GOOD_STR    DC.L        1
00001A9A                          1016  
00001A9A= 00000050                1017  SPACER1     DC.L        80
00001A9E= 00000050                1018  SPACER2     DC.L        80
00001AA2= 00000050                1019  SPACER3     DC.L        80
00001AA6= 00000050                1020  SPACER4     DC.L        80
00001AAA= 00000050                1021  SPACER5     DC.L        80
00001AAE= 00000050                1022  SPACER6     DC.L        80
00001AB2= 00000050                1023  SPACER7     DC.L        80
00001AB6= 00000050                1024  SPACER8     DC.L        80
00001ABA= 00000050                1025  SPACER9     DC.L        80
00001ABE= 00000050                1026  SPACERA     DC.L        80
00001AC2= 00000050                1027  SPACERB     DC.L        80
00001AC6= 00000050                1028  SPACERC     DC.L        80
00001ACA= 00000050                1029  SPACERD     DC.L        80
00001ACE= 00000050                1030  SPACERE     DC.L        80
00001AD2= 00000050                1031  SPACERF     DC.L        80
00001AD6                          1032  
00001AD6                          1033              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 17B6
ABS_ADDR            170E
ABS_TBL             178A
ABW                 17A6
ADD_CHAR_B          11CE
ADD_CHAR_G          1216
AH_DONE             1092
ARD                 16BE
ARI                 16CA
ARI_DEC             16F6
ARI_INC             16DE
ASCII_HEX           107A
BAD_STR             1A56
B_ADD_CHAR          1864
B_DN                1592
B_EA                1556
B_H2A               182E
B_IMD               180A
B_ISO_DIG           183C
B_LET               185C
B_NUM               1854
CLEAN_GS            117C
CONTINUE            10EA
CR                  D
DECODE_LOOP         10B6
DN_SRC              15E4
DONE                1254
DRD                 16B2
D_CLEAN             1192
EA_SRC              15CE
EA_TBL              167E
END_ADDR            1A2D
END_MSG             19BE
END_OPT             124E
FORMAT              10A8
GEN_EA_CODE         1600
GET_INPUT           1020
GET_SIZE_1          150C
GET_SIZE_2          14FC
GET_SIZE_3          14EC
GOOD_STR            1A96
GS_LOOP             1182
HEX_ASCII_B         1194
HEX_ASCII_G         11DA
IDATA               17C6
IMD_TBL             17D6
INIT_BAD            1144
INIT_GOOD           1130
INIT_STRS           1122
INTRO               1012
INVALID             10E0
ISO_DIG_B           11A6
ISO_DIG_G           11EE
JMP_0               1266
JMP_0X              1392
JMP_1               1276
JMP_2               1286
JMP_2X              13BC
JMP_3               1296
JMP_3X              13E0
JMP_4               12A6
JMP_47X             145E
JMP_4X              1404
JMP_5               12B6
JMP_6               12C6
JMP_6X              1442
JMP_7               12D6
JMP_8               12E6
JMP_8X              1446
JMP_9               12F6
JMP_A               1306
JMP_B               1314
JMP_C               1322
JMP_CX              144A
JMP_D               1332
JMP_DX              144E
JMP_E               1342
JMP_EX              1452
JMP_TBL             125A
J_47X               142A
J_ADDI              13B4
J_CLR1              1372
J_CLR3              1362
J_CLR4              1352
J_CLR_DM            1382
J_LEA               1432
J_MOVEAL            13D0
J_MOVEAW            13F4
J_MOVEL             13D8
J_MOVEM             143A
J_MOVEW             13FC
J_SUBI              13AC
LET                 109E
LET_B               11C6
LET_G               120E
LF                  A
L_ADD_CHAR          18E8
L_DN                15BA
L_EA                157E
L_H2A               18B2
L_IMD               1822
L_ISO_DIG           18C0
L_LET               18E0
L_NUM               18D8
MM_EA_SRC           15FC
MM_LS_SRC           15FE
MM_OP_ORD           15FA
MOV_EA_CODE         1622
NEXT_PAGE           10FC
NL_INTRO            18F4
NUM                 1094
NUM_0               175A
NUM_1               1760
NUM_2               1766
NUM_3               176C
NUM_4               1772
NUM_5               1778
NUM_6               177E
NUM_7               1784
NUM_B               11BE
NUM_G               1206
NXT_PG              19DF
OPC_04XX            1456
OPC_05XX            145A
OPC_1XXX            145E
OPC_5XXX            1488
OPC_7XXX            14A4
OPC_9XXX            14C2
OPC_LEA             14E0
OPC_MOVEAL          14E4
OPC_MOVEAW          14E8
OPC_MOVEL           14E6
OPC_MOVEM           14E2
OPC_MOVEW           14EA
OR_ADD_SIZE         1522
PRINT_B             1238
PRINT_G             1222
PRINT_GOOD          10D6
PROC_END            106E
PROC_STA            1062
REG_CODE            1668
REG_TBL             1716
SPACER1             1A9A
SPACER11            1A5A
SPACER2             1A9E
SPACER22            1A5E
SPACER3             1AA2
SPACER33            1A62
SPACER4             1AA6
SPACER44            1A66
SPACER5             1AAA
SPACER55            1A6A
SPACER6             1AAE
SPACER66            1A6E
SPACER7             1AB2
SPACER77            1A72
SPACER8             1AB6
SPACER88            1A76
SPACER9             1ABA
SPACER99            1A7A
SPACERA             1ABE
SPACERAA            1A7E
SPACERB             1AC2
SPACERBB            1A82
SPACERC             1AC6
SPACERCC            1A86
SPACERD             1ACA
SPACERDD            1A8A
SPACERE             1ACE
SPACEREE            1A8E
SPACERF             1AD2
SPACERFF            1A92
START               1000
STA_ADDR            1A05
STA_MSG             199B
W_ADD_CHAR          18A6
W_DN                15A6
W_EA                156A
W_H2A               1870
W_IMD               1816
W_ISO_DIG           187E
W_LET               189E
W_NUM               1896
