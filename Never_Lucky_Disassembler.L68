00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/31/2017 8:50:09 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010C2             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 000020C0             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 00002167             28  GET_INPUT   LEA         IN_WARN,A1 *Load INTRO1 message into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display intro
0000102A  4E4F                      30              TRAP        #15 
0000102C                            31  
0000102C  43F9 0000242E             32              LEA         STA_MSG,A1  *Load STA_MSG into A1
00001032  103C 000E                 33              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  43F9 000024E3             36              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
0000103E  103C 0002                 37              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001042  4E4F                      38              TRAP        #15         
00001044                            39              
00001044  4EB9 0000106E             40              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000104A  4281                      41              CLR.L       D1          *Clear input length from D1
0000104C                            42              
0000104C  43F9 00002451             43              LEA         END_MSG,A1  *Load END_MSG into A1
00001052  103C 000E                 44              MOVE.B      #14,D0      *Trap task 14, display end address msg
00001056  4E4F                      45              TRAP        #15
00001058                            46              
00001058  43F9 0000250B             47              LEA         END_ADDR,A1 *Store input in END_ADDR variable
0000105E  103C 0002                 48              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001062  4E4F                      49              TRAP        #15         
00001064                            50              
00001064  4EB9 0000107A             51              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000106A  4281                      52              CLR.L       D1          *Clear input length from D1
0000106C                            53              
0000106C  4E75                      54              RTS
0000106E                            55              
0000106E                            56  *--------------------PROC_STA-------------------------------
0000106E                            57  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
0000106E  4EB9 00001086             58              JSR         ASCII_HEX   *Convert input into Hex
00001074                            59              
00001074                            60              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            61              
00001074  2A43                      62              MOVEA.L     D3,A5       *Move hex to STA_ADDR
00001076  4283                      63              CLR.L       D3          *Clear D3
00001078  4E75                      64              RTS                     
0000107A                            65  
0000107A                            66  *--------------------PROC_END-------------------------------
0000107A                            67  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000107A                            68              *      does not fall before start
0000107A  4EB9 00001086             69              JSR         ASCII_HEX   *Convert input into Hex
00001080                            70              
00001080                            71              *assuming all error checking is done before the next instruction (not yet implemented)
00001080                            72              
00001080  2C43                      73              MOVE.L      D3,A6       *Move hex to END_ADDR
00001082  4283                      74              CLR.L       D3          *Clear D3
00001084  4E75                      75              RTS
00001086                            76  
00001086                            77  *-------------------ASCII_HEX-------------------------------
00001086  0C01 0000                 78  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000108A  6700 0012                 79              BEQ         AH_DONE     *End subroutine if all converted
0000108E  1419                      80              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001090  183C 0039                 81              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001094  B404                      82              CMP.B       D4,D2       *Check if ascii code is for a number or letter
00001096  6F00 0008                 83              BLE         NUM         *Codes less than $39 imply a number, so branch
0000109A  6000 000E                 84              BRA         LET         *If not a number, must be a letter.            
0000109E  4E75                      85  AH_DONE     RTS
000010A0                            86  
000010A0  183C 0030                 87  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
000010A4  9404                      88              SUB.B       D4,D2       *convert to hexadecimal number
000010A6  6000 000C                 89              BRA         FORMAT      *branch to subroutine to store converted hex number
000010AA                            90              
000010AA  183C 0037                 91  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010AE  9404                      92              SUB.B       D4,D2       *convert to hexadecimal letter
000010B0  6000 0002                 93              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010B4                            94  
000010B4  5301                      95  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010B6  D602                      96              ADD.B       D2,D3       *Store converted number in D3
000010B8  0C01 0000                 97              CMPI.B      #$0,D1      *Check if we're all done converting
000010BC  67C8                      98              BEQ         ASCII_HEX   *If not continue conversion
000010BE  E983                      99              ASL.L       #4,D3       *Shift bits to the left to correct position
000010C0  60C4                     100              BRA         ASCII_HEX   *Branch back to label
000010C2                           101              
000010C2                           102  *-------------------DECODE_LOOP-----------------------------
000010C2  3E1D                     103  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010C4  47F9 00002534            104              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010CA  49F9 00002574            105              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010D0                           106              
000010D0  4EB9 00001140            107              JSR         INIT_STRS   *Initialize Bad and Good Str
000010D6                           108              
000010D6  4EB9 00001310            109              JSR         JMP_TBL     *Start opcode identification waterfall
000010DC                           110              
000010DC  4EB9 0000112A            111              JSR         CLEAN_GS    *end of output string.
000010E2                           112              
000010E2  4EB9 0000126A            113  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010E8  6000 000C                114              BRA         CONTINUE    *Continue the loop
000010EC  4EB9 00001280            115  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010F2  6000 0002                116              BRA         CONTINUE    *Continue the loop            
000010F6                           117              
000010F6  220D                     118  CONTINUE    MOVE.L      A5,D1
000010F8  240E                     119              MOVE.L      A6,D2
000010FA  B481                     120              CMP.L       D1,D2
000010FC  6F00 01E8                121              BLE         END_OPT     *if we're done, move to end options (ask user what to do)
00001100                           122              
00001100                           123                          
00001100  5205                     124              ADDQ.B      #1,D5       *Increment line counter
00001102  BA3C 001D                125              CMP.B       #29,D5      *See if page is full
00001106  6700 0004                126              BEQ         NEXT_PAGE   *Jump to next page prompt
0000110A                           127              
0000110A  60B6                     128              BRA         DECODE_LOOP * Continue loop
0000110C                           129  
0000110C                           130  *-------------------NEXT_PAGE-----------------------------
0000110C  43F9 00002472            131  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001112  4280                     132              CLR.L       D0          *Make sure D0 is empty
00001114  103C 000E                133              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001118  4E4F                     134              TRAP        #15            
0000111A                           135              
0000111A  103C 0005                136              MOVE.B      #5,D0       *Single char trap task
0000111E  4E4F                     137              TRAP        #15         
00001120                           138              
00001120  B23C 000D                139              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001124  66E6                     140              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
00001126                           141              
00001126  4285                     142              CLR.L       D5          *Reset page counter
00001128                           143              
00001128  6098                     144              BRA         DECODE_LOOP *Continue the loop
0000112A                           145              
0000112A                           146  *-------------------GS_CLEAN--------------------------------
0000112A                           147  * This subroutine "cleans" the end of the good string.
0000112A                           148  * Prevents the previous string from showing content in the
0000112A                           149  * current string.
0000112A                           150  *-----------------------------------------------------------
0000112A  4280                     151  CLEAN_GS    CLR.L       D0
0000112C  103C 000F                152              MOVE.B      #15,D0      *Max 15 chars to clean
00001130                           153  
00001130  0C00 0000                154  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001134  6700 0008                155              BEQ         D_CLEAN
00001138  421C                     156              CLR.B       (A4)+
0000113A  5300                     157              SUBI.B      #$1,D0
0000113C  60F2                     158              BRA         GS_LOOP
0000113E  4E75                     159  D_CLEAN     RTS
00001140                           160              
00001140                           161  *-------------------INIT_STRS-----------------------------
00001140  4EB9 0000114E            162  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001146  4EB9 00001162            163              JSR         INIT_BAD    *Initialize the bad string
0000114C  4E75                     164              RTS
0000114E                           165              
0000114E                           166  *-------------------INIT_GOOD-----------------------------
0000114E  18FC 0024                167  INIT_GOOD   MOVE.B      #'$',(A4)+ 
00001152  4EB9 00001194            168              JSR         H2A_G_ADDR *Now convert address to ASCII
00001158                           169              
00001158  18FC 0020                170              MOVE.B      #' ',(A4)+  *Add spaces after addr
0000115C  18FC 0020                171              MOVE.B      #' ',(A4)+
00001160                           172              
00001160  4E75                     173              RTS
00001162                           174  
00001162                           175  *-------------------INIT_BAD------------------------------            
00001162  16FC 0024                176  INIT_BAD    MOVE.B      #'$',(A3)+
00001166  4EB9 000011DC            177              JSR         H2A_B_ADDR  *Add the address to the bad string
0000116C  16FC 0020                178              MOVE.B      #' ',(A3)+    
00001170  16FC 0020                179              MOVE.B      #' ',(A3)+
00001174                           180              
00001174  16FC 0044                181              MOVE.B      #'D',(A3)+  
00001178  16FC 0041                182              MOVE.B      #'A',(A3)+ 
0000117C  16FC 0054                183              MOVE.B      #'T',(A3)+    
00001180  16FC 0041                184              MOVE.B      #'A',(A3)+ 
00001184                           185              
00001184  16FC 0020                186              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001188  16FC 0020                187              MOVE.B      #' ',(A3)+
0000118C  4EB9 00001224            188              JSR         H2A_B_OP   *Add the opcode to the bad string
00001192                           189              
00001192  4E75                     190              RTS
00001194                           191              
00001194                           192  *-------------------H2A_G_ADDR-------------------------------            
00001194  4280                     193  H2A_G_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     194              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     195              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     196              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  220D                     197              MOVE.L      A5,D1       *Copy address into D1
0000119E  5581                     198              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011A0  103C 0008                199              MOVE.B      #$8,D0      *Counter
000011A4  6000 0002                200              BRA         ISO_DIG_G   *Begin isolating chars
000011A8                           201              
000011A8  E999                     202  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011AA                           203              
000011AA  2401                     204              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AC                           205              
000011AC  163C 001C                206              MOVE.B      #28,D3      *Shift left 28 times
000011B0  E7AA                     207              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B2  E99A                     208              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B4                           209              
000011B4  0C02 0009                210              CMPI.B      #$9,D2      *Is it a number?
000011B8  6F00 0006                211              BLE         NUM_G       *If it is, process number
000011BC  6000 000A                212              BRA         LET_G       *If not, process letter
000011C0                           213              
000011C0  0602 0030                214  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
000011C4  6000 000A                215              BRA         ADD_CHAR_G  *add to strings and continue
000011C8                           216              
000011C8  0602 0037                217  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
000011CC  6000 0002                218              BRA         ADD_CHAR_G  *add to strings and continue
000011D0                           219  
000011D0  18C2                     220  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
000011D2  5300                     221              SUBI.B      #$1,D0      *decrement counter
000011D4  0C00 0000                222              CMPI.B      #$0,D0      *Check if we're done            
000011D8  6ECE                     223              BGT         ISO_DIG_G    *If not, continue tranlation   
000011DA                           224              
000011DA  4E75                     225              RTS
000011DC                           226              
000011DC                           227  *-------------------H2A_B_ADDR-------------------------------            
000011DC  4280                     228  H2A_B_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
000011DE  4281                     229              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011E0  4282                     230              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E2  4283                     231              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E4  220D                     232              MOVE.L      A5,D1       *Copy address into D1
000011E6  5581                     233              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011E8  103C 0008                234              MOVE.B      #$8,D0      *Counter
000011EC  6000 0002                235              BRA         ISO_DIG_B   *Begin isolating chars
000011F0                           236              
000011F0  E999                     237  ISO_DIG_B   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F2                           238              
000011F2  2401                     239              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F4                           240              
000011F4  163C 001C                241              MOVE.B      #28,D3      *Shift left 28 times
000011F8  E7AA                     242              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011FA  E99A                     243              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FC                           244              
000011FC  0C02 0009                245              CMPI.B      #$9,D2      *Is it a number?
00001200  6F00 0006                246              BLE         NUM_B       *If it is, process number
00001204  6000 000A                247              BRA         LET_B       *If not, process letter
00001208                           248              
00001208  0602 0030                249  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
0000120C  6000 000A                250              BRA         ADD_CHAR_B  *add to strings and continue
00001210                           251              
00001210  0602 0037                252  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
00001214  6000 0002                253              BRA         ADD_CHAR_B  *add to strings and continue
00001218                           254  
00001218  16C2                     255  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to the good data string
0000121A  5300                     256              SUBI.B      #$1,D0      *decrement counter
0000121C  0C00 0000                257              CMPI.B      #$0,D0      *Check if we're done            
00001220  6ECE                     258              BGT         ISO_DIG_B    *If not, continue tranlation   
00001222                           259              
00001222  4E75                     260              RTS
00001224                           261              
00001224                           262  *-------------------H2A_B_OP--------------------------------
00001224  4280                     263  H2A_B_OP    CLR.L       D0          *Make sure D0 is empty (Counter)
00001226  4281                     264              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001228  4282                     265              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000122A  4283                     266              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000122C  3207                     267              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000122E  103C 0004                268              MOVE.B      #$4,D0      *Counter
00001232  6000 0002                269              BRA         ISODIG_BO   *Begin isolating chars
00001236                           270              
00001236  E959                     271  ISODIG_BO   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001238                           272              
00001238  2401                     273              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
0000123A                           274              
0000123A  163C 001C                275              MOVE.B      #28,D3      *Shift left 28 times
0000123E  E7AA                     276              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001240  E99A                     277              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001242                           278              
00001242  0C02 0009                279              CMPI.B      #$9,D2      *Is it a number?
00001246  6F00 0006                280              BLE         NUM_BO      *If it is, process number
0000124A  6000 000A                281              BRA         LET_BO      *If not, process letter
0000124E                           282  
0000124E  0602 0030                283  NUM_BO      ADDI.B      #$30,D2     *Make it an ascii number
00001252  6000 000A                284              BRA         ADD_CHAR_BO *add to strings and continue
00001256                           285              
00001256  0602 0037                286  LET_BO      ADDI.B      #$37,D2     *Make it an ascii letter
0000125A  6000 0002                287              BRA         ADD_CHAR_BO *add to strings and continue
0000125E                           288              
0000125E  16C2                     289  ADD_CHAR_BO MOVE.B      D2,(A3)+    *Add to bad data string
00001260  5300                     290              SUBI.B      #$1,D0      *decrement counter
00001262  0C00 0000                291              CMPI.B      #$0,D0      *Check if we're done            
00001266  6ECE                     292              BGT         ISODIG_BO  *If not, continue tranlation   
00001268                           293              
00001268  4E75                     294              RTS
0000126A                           295              
0000126A                           296  *-------------------PRINT_G---------------------------------
0000126A  18FC 0020                297  PRINT_G     MOVE.B      #' ',(A4)+
0000126E  16FC 0000                298              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
00001272  43F9 00002574            299              LEA         GOOD_STR,A1 *Load good data for printing
00001278  103C 000D                300              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000127C  4E4F                     301              TRAP        #15         *Display string
0000127E                           302            
0000127E  4E75                     303              RTS 
00001280                           304  
00001280                           305  *-------------------PRINT_B---------------------------------
00001280  18FC 0020                306  PRINT_B     MOVE.B      #' ',(A4)+
00001284  18FC 0000                307              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001288  43F9 00002534            308              LEA         BAD_STR,A1  *Load good data for printing
0000128E  103C 000D                309              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001292  4E4F                     310              TRAP        #15         *Display string
00001294                           311              
00001294  4E75                     312              RTS 
00001296                           313  *-------------------PRG_RESET-------------------------------
00001296  2E7C 01000000            314  PRG_RESET   MOVEA.L     #$01000000,A7   *Reset the stack pointer
0000129C                           315              
0000129C  207C 00000000            316              MOVEA.L     #$00000000,A0   *Clear Address Registers
000012A2  227C 00000000            317              MOVEA.L     #$00000000,A1
000012A8  247C 00000000            318              MOVEA.L     #$00000000,A2
000012AE  267C 00000000            319              MOVEA.L     #$00000000,A3
000012B4  287C 00000000            320              MOVEA.L     #$00000000,A4
000012BA  2A7C 00000000            321              MOVEA.L     #$00000000,A5
000012C0  2C7C 00000000            322              MOVEA.L     #$00000000,A6
000012C6                           323              
000012C6  4280                     324              CLR.L       D0              *Reset Data registers
000012C8  4281                     325              CLR.L       D1
000012CA  4282                     326              CLR.L       D2
000012CC  4283                     327              CLR.L       D3
000012CE  4284                     328              CLR.L       D4
000012D0  4285                     329              CLR.L       D5
000012D2  4286                     330              CLR.L       D6
000012D4  4287                     331              CLR.L       D7
000012D6                           332  
000012D6  103C 000B                333              MOVE.B      #11,D0          *Clear Screen
000012DA  323C FF00                334              MOVE.W      #$FF00,D1
000012DE  4E4F                     335              TRAP        #15
000012E0                           336              
000012E0  4281                     337              CLR.L       D1
000012E2                           338              
000012E2  4EF8 1000                339              JMP         START           *Restart the program
000012E6                           340  
000012E6                           341  *-------------------END_OPT---------------------------------
000012E6  43F9 0000249B            342  END_OPT     LEA         END_PGR,A1  *Display Ending messages
000012EC  4280                     343              CLR.L       D0          
000012EE  103C 000E                344              MOVE.B      #14,D0      
000012F2  4E4F                     345              TRAP        #15             
000012F4                           346              
000012F4  103C 0005                347              MOVE.B      #5,D0       *Single char trap task
000012F8  4E4F                     348              TRAP        #15         
000012FA                           349              
000012FA  B23C 0020                350              CMP.B       #$20,D1     *Check if SPACE key was pressed
000012FE  6796                     351              BEQ         PRG_RESET   *Decode another memory image if enter is pressed
00001300                           352              
00001300  B23C 001B                353              CMP.B       #$1B,D1     *Check if ESC key was pressed
00001304  6700 0004                354              BEQ         DONE        *End program
00001308                           355              
00001308  60DC                     356              BRA         END_OPT     *Else, loop (force space or esc)
0000130A                           357              
0000130A                           358  *-----------------------DONE--------------------------------
0000130A  103C 0009                359  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
0000130E  4E4F                     360              TRAP        #15         *Halt program, Trap#15 task 9
00001310                           361              
00001310                           362  *---------------Variables and Constants---------------------
00001310                           363              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
00001310                           364  
00001310                           365  
00001310  4282                     366  JMP_TBL     CLR.L       D2
00001312  3407                     367              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001314  4281                     368              CLR.L       D1
00001316  123C 000C                369              MOVE.B      #12,D1      *Moves 12 into D1
0000131A  E26A                     370              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000131C                           371                          
0000131C  B43C 0000                372  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00001320  6600 000A                373              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001324  4EB9 0000147A            374              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000132A  4E75                     375              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000132C                           376              
0000132C  B43C 0001                377  JMP_1       CMP.B       #$1,D2
00001330  6600 000A                378              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00001334  4EB9 0000168A            379              JSR         OPC_MOVEB   *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_MOVEB in OPCODE table.
0000133A  4E75                     380              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000133C                           381             
0000133C  B43C 0002                382  JMP_2       CMP.B       #$2,D2
00001340  6600 000A                383              BNE         JMP_3 
00001344  4EB9 000014A4            384              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000134A  4E75                     385              RTS
0000134C                           386              
0000134C  B43C 0003                387  JMP_3       CMP.B       #$3,D2
00001350  6600 000A                388              BNE         JMP_4
00001354  4EB9 000014C8            389              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
0000135A  4E75                     390              RTS
0000135C                           391           
0000135C  B43C 0004                392  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
00001360  6600 000A                393              BNE         JMP_5
00001364  4EB9 000014EC            394              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
0000136A  4E75                     395              RTS
0000136C                           396              
0000136C  B43C 0005                397  JMP_5       CMP.B       #$5,D2
00001370  6600 000A                398              BNE         JMP_6
00001374  4EB9 000016AE            399              JSR         OPC_ADDQ    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_ADDQ in OPCODE table.
0000137A  4E75                     400              RTS
0000137C                           401              
0000137C  B43C 0006                402  JMP_6       CMP.B       #$6,D2
00001380  6600 000A                403              BNE         JMP_7
00001384  4EB9 00001532            404              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
0000138A  4E75                     405              RTS
0000138C                           406              
0000138C  B43C 0007                407  JMP_7       CMP.B       #$7,D2
00001390  6600 000A                408              BNE         JMP_8
00001394  4EB9 000016D6            409              JSR         OPC_MOVEQ    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_MOVEQ in OPCODE table.
0000139A  4E75                     410              RTS
0000139C                           411              
0000139C  B43C 0008                412  JMP_8       CMP.B       #$8,D2
000013A0  6600 000A                413              BNE         JMP_9
000013A4  4EB9 00001556            414              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000013AA  4E75                     415              RTS
000013AC                           416              
000013AC  B43C 0009                417  JMP_9       CMP.B       #$9,D2
000013B0  6600 000A                418              BNE         JMP_A
000013B4  4EB9 000016F2            419              JSR         OPC_SUB    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000013BA  4E75                     420              RTS
000013BC                           421              
000013BC  B43C 000A                422  JMP_A       CMP.B       #$A,D2
000013C0  6600 0008                423              BNE         JMP_B
000013C4  4EB8 10EC                424              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
000013C8  4E75                     425              RTS
000013CA                           426              
000013CA  B43C 000B                427  JMP_B       CMP.B       #$B,D2
000013CE  6600 0008                428              BNE         JMP_C
000013D2  4EB8 10EC                429              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000013D6  4E75                     430              RTS
000013D8                           431              
000013D8  B43C 000C                432  JMP_C       CMP.B       #$C,D2
000013DC  6600 000A                433              BNE         JMP_D
000013E0  4EB9 0000157A            434              JSR         JMP_CX
000013E6                           435        *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000013E6  4E75                     436              RTS
000013E8                           437              
000013E8  B43C 000D                438  JMP_D       CMP.B       #$D,D2
000013EC  6600 000A                439              BNE         JMP_E   
000013F0  4EB9 0000159E            440              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000013F6  4E75                     441              RTS
000013F8                           442              
000013F8  B43C 000F                443  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
000013FC  6700 FCEE                444              BEQ         INVALID     *If first hex value is F, jump to INVALID
00001400  4EB9 00001C44            445              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001406                           446              
00001406  4EF8 10EC                447              JMP         INVALID     *Got here? Must be invalid.
0000140A  4E75                     448              RTS
0000140C                           449   
0000140C  4282                     450  J_CLR4      CLR.L       D2                                
0000140E  3407                     451              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001410  4281                     452              CLR.L       D1
00001412  E94A                     453              LSL.W       #4,D2       *Clear the most sig hex digit
00001414  123C 000C                454              MOVE.B      #12,D1      *Moves 12 into D1
00001418  E26A                     455              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
0000141A  4E75                     456              RTS                     *Return back to JMP_Xn    
0000141C                           457              
0000141C  4282                     458  J_CLR3      CLR.L       D2          
0000141E  3407                     459              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001420  4281                     460              CLR.L       D1
00001422  E94A                     461              LSL.W       #4,D2       *Clear the most sig hex digit
00001424  123C 000D                462              MOVE.B      #13,D1      *Moves 13 into D1
00001428  E26A                     463              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000142A  4E75                     464              RTS                     *Return back to JMP_Xn  
0000142C                           465  
0000142C  4282                     466  J_CLR2  CLR.L       D2          
0000142E  3407                     467          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001430  4281                     468          CLR.L       D1
00001432  E14A                     469          LSL.W       #8,D2           *Clear the most sig 7 bits
00001434  123C 000E                470          MOVE.B      #14,D1          *Moves 16 into D1
00001438  E26A                     471          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000143A  4E75                     472          RTS     
0000143C                           473  
0000143C  4282                     474  J_CLR1  CLR.L       D2          
0000143E  3407                     475          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001440  4281                     476          CLR.L       D1
00001442  EF4A                     477          LSL.W       #7,D2           *Clear the most sig 7 bits
00001444  123C 000F                478          MOVE.B      #15,D1          *Moves 16 into D1
00001448  E26A                     479          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000144A  4E75                     480          RTS                         *Return back to JMP_Xn
0000144C                           481          
0000144C                           482          
0000144C  4282                     483  J_CLR_LEA   CLR.L       D2          
0000144E  3407                     484              MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001450  4281                     485              CLR.L       D1
00001452  EF4A                     486              LSL.W       #7,D2           *Clear the most sig 7 bits
00001454  123C 000D                487              MOVE.B      #13,D1          *Moves 16 into D1
00001458  E26A                     488              LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000145A  4E75                     489              RTS    
0000145C                           490              
0000145C                           491  
0000145C  4282                     492  J_CLR_MM    CLR.L       D2          
0000145E  3407                     493              MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00001460  4281                     494              CLR.L       D1   
00001462  123C 000B                495              MOVE.B      #11,D1          *Moves 16 into D1
00001466  E26A                     496              LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
00001468  4E75                     497              RTS  
0000146A                           498       
0000146A  4282                     499  J_CLR_DM    CLR.L       D2          
0000146C  3407                     500              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000146E  4281                     501              CLR.L       D1
00001470  EF4A                     502              LSL.W       #7,D2       *Clear the most sig 7 bits
00001472  123C 000D                503              MOVE.B      #13,D1      *Moves 17 into D1
00001476  E26A                     504              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001478  4E75                     505              RTS                     *Return back to JMP_Xn     
0000147A                           506   
0000147A                           507  
0000147A                           508          
0000147A  4EB8 140C                509  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
0000147E  B43C 0004                510              CMP.B       #$4,D2      *Is the next hex digit 4?
00001482  6700 0010                511              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00001486  B43C 0006                512              CMP.B       #$6,D2      *Is the next hex digit 5?
0000148A  6700 0010                513              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
0000148E  4EB8 10EC                514              JSR         INVALID     *If neither, OPCODE is invalid
00001492  4E75                     515              RTS
00001494                           516  
00001494  4EB9 0000163A            517  J_SUBI      JSR         OPC_SUBI    *Jump to OPC_SUBI in OPCODE table
0000149A  4E75                     518              RTS
0000149C                           519              
0000149C  4EB9 00001662            520  J_ADDI      JSR         OPC_ADDI    *Jump to OPC_ADDI in OPCODE table
000014A2  4E75                     521              RTS              
000014A4                           522  
000014A4                           523  
000014A4  4EB8 146A                524  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014A8  B43C 0001                525              CMP.B       #$1,D2      *is the DEST MODE 1?
000014AC  6700 000A                526              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000014B0  4EB9 000014C0            527              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000014B6  4E75                     528              RTS
000014B8                           529  
000014B8  4EB9 0000177A            530  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000014BE  4E75                     531              RTS
000014C0                           532  
000014C0  4EB9 000017A6            533  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000014C6  4E75                     534              RTS                           
000014C8                           535              
000014C8  4EB8 146A                536  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014CC  B43C 0001                537              CMP.B       #$1,D2      *is the DEST MODE 1?
000014D0  6700 000A                538              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000014D4  4EB9 000014E4            539              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000014DA  4E75                     540              RTS
000014DC                           541  
000014DC  4EB9 000017CE            542  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000014E2  4E75                     543              RTS
000014E4                           544  
000014E4  4EB9 000017FA            545  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
000014EA  4E75                     546              RTS
000014EC  4EB8 140C                547  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
000014F0  B43C 000E                548              CMP.B       #$E,D2      *Is the next hex digit E?
000014F4  6700 0024                549              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
000014F8  4EB8 143C                550              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
000014FC  4EB8 144C                551              JSR         J_CLR_LEA
00001500  B43C 0007                552              CMP.B       #7,D2       *Is the last bit 7?
00001504  6700 001C                553              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
00001508  4EB8 145C                554              JSR         J_CLR_MM
0000150C  B43C 0009                555              CMP.B       #9,D2       *Is the last bit 0?
00001510  6700 0018                556              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
00001514  4EB8 10EC                557              JSR         INVALID     *If none of the above, OPCODE is invalid
00001518  4E75                     558              RTS                                         
0000151A                           559              
0000151A  4EB9 00001602            560  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001520  4E75                     561              RTS
00001522                           562              
00001522  4EB9 00001710            563  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
00001528  4E75                     564              RTS
0000152A                           565              
0000152A  4EB9 00001732            566  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001530  4E75                     567              RTS
00001532                           568              
00001532  4EB8 140C                569  JMP_6X      JSR         J_CLR4       *Isolate next hex digit 
00001536  B43C 0000                570              CMP.B       #0,D2        *Is the next hex digit 0?
0000153A  6700 000A                571              BEQ         J_BRA        *Instruction is determined to be BRA. Jump to intermediate OPCODE table jump
0000153E  4EB9 0000154E            572              JSR         J_Bcc        *Otherwise, Instruction is determined to be some form of Bcc. Jump to intermediate OPCODE table jump
00001544  4E75                     573              RTS
00001546                           574              
00001546  4EB9 00001822            575  J_BRA       JSR         OPC_BRA      *Jump to OPC_BRA in the OPCODE table  
0000154C                           576  
0000154C  4E75                     577              RTS
0000154E                           578  
0000154E  4EB9 0000183E            579  J_Bcc       JSR         OPC_Bcc      *Jump to OPC_Bcc in the OPCODE table  
00001554                           580  
00001554  4E75                     581              RTS
00001556                           582              
00001556  4EB8 146A                583  JMP_8X      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
0000155A  B43C 0003                584              CMP.B       #3,D2       *Are the bits equivalent to $3?
0000155E  6700 000A                585              BEQ         J_DIVU      *Instruction is determined to be DIVU. Jump to intermediate OPCODE table jump
00001562  4EB9 00001572            586              JSR         J_OR        *Otherwise, Instruction is determined to be OR. Jump to intermediate OPCODE table jump
00001568  4E75                     587              RTS
0000156A                           588  
0000156A  4EB9 0000184A            589  J_DIVU      JSR         OPC_DIVU    *Jump to OPC_DIVU in the OPCODE table  
00001570  4E75                     590              RTS
00001572                           591              
00001572  4EB9 00001870            592  J_OR        JSR         OPC_OR      *Jump to OPC_OR in the OPCODE table  
00001578  4E75                     593              RTS
0000157A                           594  
0000157A  4EB8 146A                595  JMP_CX      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
0000157E  B43C 0007                596              CMP.B       #7,D2       *Are the bits equivalent to $7?
00001582  6700 000A                597              BEQ         J_MULS      *Instruction is determined to be MULS. Jump to intermediate OPCODE table jump
00001586  4EB9 00001596            598              JSR         J_AND       *Otherwise, Instruction is determined to be AND. Jump to intermediate OPCODE table jump
0000158C  4E75                     599              RTS
0000158E                           600  
0000158E  4EB9 0000188A            601  J_MULS      JSR         OPC_MULS    *Jump to OPC_MULS in the OPCODE table  
00001594  4E75                     602              RTS
00001596                           603              
00001596  4EB9 000018B0            604  J_AND       JSR         OPC_AND     *Jump to OPC_AND in the OPCODE table  
0000159C  4E75                     605              RTS
0000159E                           606  
0000159E  4EB8 146A                607  JMP_DX      JSR         J_CLR_DM    *Isolate OPMODE bits to determine if ADD or ADDA
000015A2  4284                     608              CLR.L       D4          *For adding size (easy to do it here).
000015A4  183C 0001                609              MOVE.B      #1,D4       *Set size to WORD
000015A8  B43C 0003                610              CMP.B       #3,D2       *Is it Word ADDA?
000015AC  6700 0044                611              BEQ         OP_ADDA
000015B0  183C 0002                612              MOVE.B      #2,D4       *set size to LONG
000015B4  B43C 0007                613              CMP.B       #7,D2       *is it Long ADDA?
000015B8  6700 0038                614              BEQ         OP_ADDA
000015BC                           615              
000015BC  4284                     616              CLR.L       D4          *Not ADDA? Clear the manual size sets
000015BE                           617              
000015BE  B83C 0000                618              CMP.B       #0,D4       Is it ADD?
000015C2  6700 0036                619              BEQ         OP_ADD
000015C6  B83C 0001                620              CMP.B       #1,D4       
000015CA  6700 002E                621              BEQ         OP_ADD
000015CE  B83C 0002                622              CMP.B       #2,D4       
000015D2  6700 0026                623              BEQ         OP_ADD
000015D6  B83C 0004                624              CMP.B       #4,D4 
000015DA  6700 001E                625              BEQ         OP_ADD
000015DE  B83C 0005                626              CMP.B       #5,D4     
000015E2  6700 0016                627              BEQ         OP_ADD
000015E6  B83C 0006                628              CMP.B       #6,D4     
000015EA  6700 000E                629              BEQ         OP_ADD       
000015EE                           630           
000015EE  6000 FAFC                631              BRA         INVALID     *Got here, must be invalid data.    
000015F2                           632              
000015F2  4EB9 000018CE            633  OP_ADDA     JSR         OPC_ADDA
000015F8  4E75                     634              RTS
000015FA                           635              
000015FA  4EB9 000018F0            636  OP_ADD      JSR         OPC_ADD
00001600  4E75                     637              RTS
00001602                           638  
00001602                           639       
00001602                           640  
00001602                           641     
00001602  BE7C 4E71                642  JMP_47X     CMP.W       #$4E71,D7    *Is it NOP?
00001606  6700 001A                643              BEQ         O_NOP
0000160A  BE7C 4E75                644              CMP.W       #$4E75,D7       *Is it RTS?
0000160E  6700 001A                645              BEQ         O_RTS
00001612  4EB8 142C                646              JSR         J_CLR2       *Isolate the 6th and 7th bit
00001616  B43C 0002                647              CMP.B       #2,D2        *Is it JSR?
0000161A  6700 0016                648              BEQ         O_JSR
0000161E  4EF8 10EC                649              JMP         INVALID      *Got here? Must be invalid data.
00001622                           650  
00001622  4EB9 0000192A            651  O_NOP       JSR         OPC_NOP
00001628  4E75                     652              RTS
0000162A                           653  
0000162A  4EB9 00001938            654  O_RTS       JSR         OPC_RTS
00001630  4E75                     655              RTS
00001632                           656  
00001632  4EB9 0000190E            657  O_JSR       JSR         OPC_JSR
00001638  4E75                     658              RTS
0000163A                           659           
0000163A                           660  
0000163A                           661  
0000163A  18FC 0053                662  OPC_SUBI    MOVE.B      #'S',(A4)+
0000163E  18FC 0055                663              MOVE.B      #'U',(A4)+
00001642  18FC 0042                664              MOVE.B      #'B',(A4)+
00001646  18FC 0049                665              MOVE.B      #'I',(A4)+
0000164A  18FC 002E                666              MOVE.B      #'.',(A4)+
0000164E                           667              
0000164E  4EB9 00001B72            668              JSR         GET_SIZE_2  *Get 2 bit size code
00001654  4EB9 00001B20            669              JSR         ADD_SIZE    *Add the size character based on size code
0000165A                           670              
0000165A  4EB9 00001C88            671              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
00001660                           672              
00001660  4E75                     673              RTS
00001662                           674  
00001662  18FC 0041                675  OPC_ADDI    MOVE.B      #'A',(A4)+
00001666  18FC 0044                676              MOVE.B      #'D',(A4)+
0000166A  18FC 0044                677              MOVE.B      #'D',(A4)+
0000166E  18FC 0049                678              MOVE.B      #'I',(A4)+
00001672  18FC 002E                679              MOVE.B      #'.',(A4)+
00001676                           680              
00001676  4EB9 00001B72            681              JSR         GET_SIZE_2  *Get 2 bit size code
0000167C  4EB9 00001B20            682              JSR         ADD_SIZE    *Add the size character based on size code
00001682                           683              
00001682  4EB9 00001C88            684              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
00001688                           685              
00001688  4E75                     686              RTS
0000168A                           687  
0000168A  18FC 004D                688  OPC_MOVEB   MOVE.B      #'M',(A4)+
0000168E  18FC 004F                689              MOVE.B      #'O',(A4)+
00001692  18FC 0056                690              MOVE.B      #'V',(A4)+
00001696  18FC 0045                691              MOVE.B      #'E',(A4)+
0000169A  18FC 002E                692              MOVE.B      #'.',(A4)+
0000169E                           693  
0000169E                           694  
0000169E  4284                     695              CLR.L       D4          *Manually set size to byte (D4 = 0)
000016A0  4EB9 00001B20            696              JSR         ADD_SIZE    *Add size characters
000016A6                           697              
000016A6  4EB9 00001D7A            698              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000016AC                           699              
000016AC  4E75                     700              RTS
000016AE                           701  
000016AE  18FC 0041                702  OPC_ADDQ    MOVE.B      #'A',(A4)+
000016B2  18FC 0044                703              MOVE.B      #'D',(A4)+
000016B6  18FC 0044                704              MOVE.B      #'D',(A4)+
000016BA  18FC 0051                705              MOVE.B      #'Q',(A4)+
000016BE  18FC 002E                706              MOVE.B      #'.',(A4)+
000016C2                           707  
000016C2  4EB9 00001B72            708              JSR         GET_SIZE_2   *Get size code (placed in D4)
000016C8  4EB9 00001B20            709              JSR         ADD_SIZE     *Add size character to string (B/W/L)
000016CE                           710              
000016CE  4EB9 00001D20            711              JSR         ADDQ_EA      *Start the EA/operand decode logic
000016D4                           712   
000016D4  4E75                     713              RTS
000016D6                           714  
000016D6  18FC 004D                715  OPC_MOVEQ   MOVE.B      #'M',(A4)+
000016DA  18FC 004F                716              MOVE.B      #'O',(A4)+
000016DE  18FC 0056                717              MOVE.B      #'V',(A4)+
000016E2  18FC 0045                718              MOVE.B      #'E',(A4)+
000016E6  18FC 0051                719              MOVE.B      #'Q',(A4)+
000016EA                           720              
000016EA  4EB9 00001CEC            721              JSR         MOVEQ_EA     *Start the EA/opderand decode logic for moveq
000016F0                           722            
000016F0  4E75                     723              RTS
000016F2                           724  
000016F2  18FC 0053                725  OPC_SUB     MOVE.B      #'S',(A4)+
000016F6  18FC 0055                726              MOVE.B      #'U',(A4)+
000016FA  18FC 0042                727              MOVE.B      #'B',(A4)+
000016FE  18FC 002E                728              MOVE.B      #'.',(A4)+
00001702                           729  
00001702  4EB9 00001B62            730              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001708                           731              
00001708  4EB9 00001B98            732              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
0000170E                           733  
0000170E  4E75                     734              RTS
00001710                           735  
00001710  18FC 004C                736  OPC_LEA     MOVE.B      #'L',(A4)+
00001714  18FC 0045                737              MOVE.B      #'E',(A4)+
00001718  18FC 0041                738              MOVE.B      #'A',(A4)+
0000171C  18FC 0020                739              MOVE.B      #' ',(A4)+
00001720  18FC 0020                740              MOVE.B      #' ',(A4)+
00001724                           741              
00001724  4284                     742              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001726  183C 0002                743              MOVE.B      #2,D4       *Manually set size to long.
0000172A                           744              
0000172A  4EB9 00001C5C            745              JSR         EASRC_ADES
00001730                           746              
00001730  4E75                     747              RTS
00001732                           748              
00001732  18FC 004D                749  OPC_MOVEM   MOVE.B      #'M',(A4)+
00001736  18FC 004F                750              MOVE.B      #'O',(A4)+
0000173A  18FC 0056                751              MOVE.B      #'V',(A4)+
0000173E  18FC 0045                752              MOVE.B      #'E',(A4)+
00001742  18FC 004D                753              MOVE.B      #'M',(A4)+
00001746  18FC 002E                754              MOVE.B      #'.',(A4)+
0000174A                           755              
0000174A  4EB9 00001B82            756              JSR         GET_SIZE_1
00001750                           757              
00001750  B83C 0000                758              CMP.B       #0,D4       *Change size code so it matches standard formatting
00001754  6700 000A                759              BEQ         MM_WORD
00001758  B83C 0001                760              CMP.B       #1,D4
0000175C  6700 000A                761              BEQ         MM_LONG
00001760                           762  
00001760  183C 0001                763  MM_WORD     MOVE.B      #1,D4
00001764  6000 0006                764              BRA         MM_ADD_S
00001768                           765  
00001768  183C 0002                766  MM_LONG     MOVE.B      #2,D4
0000176C                           767         
0000176C  4EB9 00001B20            768  MM_ADD_S    JSR         ADD_SIZE
00001772  4EB9 00001C9A            769              JSR         MM_OP_ORD
00001778                           770              
00001778  4E75                     771              RTS
0000177A                           772  
0000177A                           773  
0000177A  18FC 004D                774  OPC_MOVEAL  MOVE.B      #'M',(A4)+
0000177E  18FC 004F                775              MOVE.B      #'O',(A4)+
00001782  18FC 0056                776              MOVE.B      #'V',(A4)+
00001786  18FC 0045                777              MOVE.B      #'E',(A4)+
0000178A  18FC 0041                778              MOVE.B      #'A',(A4)+
0000178E  18FC 002E                779              MOVE.B      #'.',(A4)+
00001792                           780  
00001792  4284                     781              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001794  183C 0002                782              MOVE.B      #2,D4       *Set size code to long
00001798  4EB9 00001B20            783              JSR         ADD_SIZE    *Add size characters
0000179E                           784              
0000179E  4EB9 00001D7A            785              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017A4  4E75                     786              RTS
000017A6                           787  
000017A6                           788  
000017A6  18FC 004D                789  OPC_MOVEL   MOVE.B      #'M',(A4)+
000017AA  18FC 004F                790              MOVE.B      #'O',(A4)+
000017AE  18FC 0056                791              MOVE.B      #'V',(A4)+
000017B2  18FC 0045                792              MOVE.B      #'E',(A4)+
000017B6  18FC 002E                793              MOVE.B      #'.',(A4)+
000017BA                           794  
000017BA  4284                     795              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017BC  183C 0002                796              MOVE.B      #2,D4       *Set size code to long
000017C0  4EB9 00001B20            797              JSR         ADD_SIZE    *Add size characters
000017C6                           798              
000017C6  4EB9 00001D7A            799              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017CC  4E75                     800              RTS
000017CE                           801  
000017CE  18FC 004D                802  OPC_MOVEAW  MOVE.B      #'M',(A4)+
000017D2  18FC 004F                803              MOVE.B      #'O',(A4)+
000017D6  18FC 0056                804              MOVE.B      #'V',(A4)+
000017DA  18FC 0045                805              MOVE.B      #'E',(A4)+
000017DE  18FC 0041                806              MOVE.B      #'A',(A4)+
000017E2  18FC 002E                807              MOVE.B      #'.',(A4)+
000017E6                           808  
000017E6  4284                     809              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017E8  183C 0001                810              MOVE.B      #1,D4       *Set size code to word
000017EC  4EB9 00001B20            811              JSR         ADD_SIZE    *Add size characters
000017F2                           812              
000017F2  4EB9 00001D7A            813              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000017F8  4E75                     814              RTS
000017FA                           815  
000017FA                           816  
000017FA  18FC 004D                817  OPC_MOVEW   MOVE.B      #'M',(A4)+
000017FE  18FC 004F                818              MOVE.B      #'O',(A4)+
00001802  18FC 0056                819              MOVE.B      #'V',(A4)+
00001806  18FC 0045                820              MOVE.B      #'E',(A4)+
0000180A  18FC 002E                821              MOVE.B      #'.',(A4)+
0000180E                           822  
0000180E  4284                     823              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001810  183C 0001                824              MOVE.B      #1,D4       *Set size code to word
00001814  4EB9 00001B20            825              JSR         ADD_SIZE    *Add size characters
0000181A                           826              
0000181A  4EB9 00001D7A            827              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001820  4E75                     828              RTS
00001822                           829  
00001822                           830  
00001822  18FC 0042                831  OPC_BRA     MOVE.B      #'B',(A4)+
00001826  18FC 0052                832              MOVE.B      #'R',(A4)+
0000182A  18FC 0041                833              MOVE.B      #'A',(A4)+
0000182E  18FC 0020                834              MOVE.B      #' ',(A4)+
00001832  18FC 0020                835              MOVE.B      #' ',(A4)+
00001836                           836              
00001836  4EB9 00001EFE            837              JSR         ABW       *Grab the next word value (BRA bug)
0000183C                           838                          
0000183C  4E75                     839              RTS
0000183E                           840  
0000183E  18FC 0042                841  OPC_Bcc     MOVE.B      #'B',(A4)+
00001842                           842              *BCC bug, does not use 8bit displacment, but is next word value (ABSW)
00001842  4EB9 00001946            843              JSR         BCC_CODE    *Get condition code and start decoding
00001848                           844              
00001848  4E75                     845              RTS
0000184A                           846  
0000184A  18FC 0044                847  OPC_DIVU    MOVE.B      #'D',(A4)+
0000184E  18FC 0049                848              MOVE.B      #'I',(A4)+
00001852  18FC 0056                849              MOVE.B      #'V',(A4)+
00001856  18FC 0055                850              MOVE.B      #'U',(A4)+
0000185A  18FC 0020                851              MOVE.B      #' ',(A4)+
0000185E  18FC 0020                852              MOVE.B      #' ',(A4)+
00001862                           853              
00001862  4284                     854              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001864  183C 0001                855              MOVE.B      #1,D4       *Set size code to word
00001868                           856              
00001868  4EB9 00001C46            857              JSR         EASRC_DDES  *Start operand <ea>,Dn
0000186E                           858              
0000186E                           859              
0000186E  4E75                     860              RTS
00001870                           861  
00001870  18FC 004F                862  OPC_OR      MOVE.B      #'O',(A4)+
00001874  18FC 0052                863              MOVE.B      #'R',(A4)+
00001878  18FC 002E                864              MOVE.B      #'.',(A4)+
0000187C                           865  
0000187C  4EB9 00001B62            866              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001882                           867              
00001882  4EB9 00001B98            868              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
00001888                           869  
00001888  4E75                     870              RTS
0000188A                           871  
0000188A  18FC 004D                872  OPC_MULS    MOVE.B      #'M',(A4)+
0000188E  18FC 0055                873              MOVE.B      #'U',(A4)+
00001892  18FC 004C                874              MOVE.B      #'L',(A4)+
00001896  18FC 0053                875              MOVE.B      #'S',(A4)+
0000189A  18FC 0020                876              MOVE.B      #' ',(A4)+
0000189E  18FC 0020                877              MOVE.B      #' ',(A4)+
000018A2                           878              
000018A2  4284                     879              CLR.L       D4          *Manually set size to byte (D4 = 0)
000018A4  183C 0001                880              MOVE.B      #1,D4       *Set size code to word
000018A8                           881              
000018A8  4EB9 00001C46            882              JSR         EASRC_DDES  *Jump to <ea>,Dn
000018AE                           883              
000018AE  4E75                     884              RTS
000018B0                           885  
000018B0  18FC 0041                886  OPC_AND     MOVE.B      #'A',(A4)+
000018B4  18FC 004E                887              MOVE.B      #'N',(A4)+
000018B8  18FC 0044                888              MOVE.B      #'D',(A4)+
000018BC  18FC 002E                889              MOVE.B      #'.',(A4)+
000018C0                           890  
000018C0  4EB9 00001B62            891              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000018C6                           892              
000018C6  4EB9 00001B98            893              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
000018CC                           894  
000018CC  4E75                     895              RTS
000018CE                           896              
000018CE  18FC 0041                897  OPC_ADDA    MOVE.B      #'A',(A4)+
000018D2  18FC 0044                898              MOVE.B      #'D',(A4)+
000018D6  18FC 0044                899              MOVE.B      #'D',(A4)+
000018DA  18FC 0041                900              MOVE.B      #'A',(A4)+
000018DE  18FC 002E                901              MOVE.B      #'.',(A4)+
000018E2                           902              
000018E2  4EB9 00001B20            903              JSR         ADD_SIZE    *Size should already be in D4 (special case for ADDA)
000018E8                           904              
000018E8  4EB9 00001C5C            905              JSR         EASRC_ADES  *Start operand decode for <ea>,An format
000018EE                           906              
000018EE  4E75                     907              RTS
000018F0                           908  
000018F0  18FC 0041                909  OPC_ADD     MOVE.B      #'A',(A4)+
000018F4  18FC 0044                910              MOVE.B      #'D',(A4)+
000018F8  18FC 0044                911              MOVE.B      #'D',(A4)+
000018FC  18FC 002E                912              MOVE.B      #'.',(A4)+
00001900                           913  
00001900  4EB9 00001B62            914              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001906                           915              
00001906  4EB9 00001B98            916              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
0000190C                           917  
0000190C  4E75                     918              RTS
0000190E                           919  
0000190E  18FC 004A                920  OPC_JSR     MOVE.B      #'J',(A4)+
00001912  18FC 0053                921              MOVE.B      #'S',(A4)+
00001916  18FC 0052                922              MOVE.B      #'R',(A4)+
0000191A  18FC 0020                923              MOVE.B      #' ',(A4)+
0000191E  18FC 0020                924              MOVE.B      #' ',(A4)+
00001922  4EB9 00001D58            925              JSR         GEN_EA_CODE *Get EA code
00001928                           926              
00001928  4E75                     927              RTS
0000192A                           928  
0000192A  18FC 004E                929  OPC_NOP     MOVE.B      #'N',(A4)+
0000192E  18FC 004F                930              MOVE.B      #'O',(A4)+
00001932  18FC 0050                931              MOVE.B      #'P',(A4)+
00001936                           932              
00001936  4E75                     933              RTS
00001938                           934  
00001938  18FC 0052                935  OPC_RTS     MOVE.B      #'R',(A4)+
0000193C  18FC 0054                936              MOVE.B      #'T',(A4)+
00001940  18FC 0053                937              MOVE.B      #'S',(A4)+
00001944                           938              
00001944  4E75                     939              RTS
00001946                           940  
00001946                           941  
00001946  4283                     942  BCC_CODE    CLR.L       D3          *Make sure D3 is empty to hold condition code
00001948  3607                     943              MOVE.W      D7,D3       *Move in original address to be shifted
0000194A  E94B                     944              LSL.W       #4,D3
0000194C  4282                     945              CLR.L       D2
0000194E  143C 000C                946              MOVE.B      #12,D2
00001952  E46B                     947              LSR.W       D2,D3
00001954  4EB9 0000195C            948              JSR         BCC_TABLE   *Jump to BCC table now that condition code is in D3
0000195A  4E75                     949              RTS
0000195C                           950  
0000195C  B63C 0002                951  BCC_TABLE   CMP.B       #$2,D3      *Is it BHI?
00001960  6700 006E                952              BEQ         BCC_HI
00001964  B63C 0003                953              CMP.B       #$3,D3      *Is it BLS?
00001968  6700 007E                954              BEQ         BCC_LS      
0000196C  B63C 0004                955              CMP.B       #$4,D3      *Is it BCC?
00001970  6700 008E                956              BEQ         BCC_CC
00001974  B63C 0005                957              CMP.B       #$5,D3      *Is it BCS?
00001978  6700 009E                958              BEQ         BCC_CS
0000197C  B63C 0006                959              CMP.B       #$6,D3      *Is it BNE?
00001980  6700 00AE                960              BEQ         BCC_NE
00001984  B63C 0007                961              CMP.B       #$7,D3      *Is it BEQ?
00001988  6700 00BE                962              BEQ         BCC_EQ
0000198C  B63C 0008                963              CMP.B       #$8,D3      *Is it BVC?
00001990  6700 00CE                964              BEQ         BCC_VC      
00001994  B63C 0009                965              CMP.B       #$9,D3      *Is it BVS?
00001998  6700 00DE                966              BEQ         BCC_VS
0000199C  B63C 000A                967              CMP.B       #$A,D3      *Is it BPL?
000019A0  6700 00EE                968              BEQ         BCC_PL
000019A4  B63C 000B                969              CMP.B       #$B,D3      *Is it BMI?
000019A8  6700 00FE                970              BEQ         BCC_MI
000019AC  B63C 000C                971              CMP.B       #$C,D3      *Is it BGE?
000019B0  6700 010E                972              BEQ         BCC_GE
000019B4  B63C 000D                973              CMP.B       #$D,D3      *Is it BLT?
000019B8  6700 011E                974              BEQ         BCC_LT
000019BC  B63C 000E                975              CMP.B       #$E,D3      *Is it BGT?
000019C0  6700 012E                976              BEQ         BCC_GT      
000019C4  B63C 000F                977              CMP.B       #$F,D3      *Is it BLE?
000019C8  6700 013E                978              BEQ         BCC_LE
000019CC  4EF8 10EC                979              JMP         INVALID     *Got here? Something is wrong.
000019D0                           980  
000019D0  18FC 0048                981  BCC_HI      MOVE.B      #'H',(A4)+
000019D4  18FC 0049                982              MOVE.B      #'I',(A4)+
000019D8  18FC 0020                983              MOVE.B      #' ',(A4)+
000019DC  18FC 0020                984              MOVE.B      #' ',(A4)+
000019E0  4EB9 00001EFE            985              JSR         ABW         *Add absolute word in next word address.
000019E6  4E75                     986              RTS
000019E8                           987  
000019E8  18FC 004C                988  BCC_LS      MOVE.B      #'L',(A4)+
000019EC  18FC 0053                989              MOVE.B      #'S',(A4)+
000019F0  18FC 0020                990              MOVE.B      #' ',(A4)+
000019F4  18FC 0020                991              MOVE.B      #' ',(A4)+
000019F8  4EB9 00001EFE            992              JSR         ABW         *Add absolute word in next word address.
000019FE  4E75                     993              RTS
00001A00                           994  
00001A00  18FC 0043                995  BCC_CC      MOVE.B      #'C',(A4)+
00001A04  18FC 0043                996              MOVE.B      #'C',(A4)+
00001A08  18FC 0020                997              MOVE.B      #' ',(A4)+
00001A0C  18FC 0020                998              MOVE.B      #' ',(A4)+
00001A10  4EB9 00001EFE            999              JSR         ABW         *Add absolute word in next word address.
00001A16  4E75                    1000              RTS
00001A18                          1001              
00001A18  18FC 0043               1002  BCC_CS      MOVE.B      #'C',(A4)+
00001A1C  18FC 0053               1003              MOVE.B      #'S',(A4)+
00001A20  18FC 0020               1004              MOVE.B      #' ',(A4)+
00001A24  18FC 0020               1005              MOVE.B      #' ',(A4)+
00001A28  4EB9 00001EFE           1006              JSR         ABW         *Add absolute word in next word address.
00001A2E  4E75                    1007              RTS
00001A30                          1008              
00001A30  18FC 004E               1009  BCC_NE      MOVE.B      #'N',(A4)+
00001A34  18FC 0045               1010              MOVE.B      #'E',(A4)+
00001A38  18FC 0020               1011              MOVE.B      #' ',(A4)+
00001A3C  18FC 0020               1012              MOVE.B      #' ',(A4)+
00001A40  4EB9 00001EFE           1013              JSR         ABW         *Add absolute word in next word address.
00001A46  4E75                    1014              RTS
00001A48                          1015              
00001A48  18FC 0045               1016  BCC_EQ      MOVE.B      #'E',(A4)+
00001A4C  18FC 0051               1017              MOVE.B      #'Q',(A4)+
00001A50  18FC 0020               1018              MOVE.B      #' ',(A4)+
00001A54  18FC 0020               1019              MOVE.B      #' ',(A4)+
00001A58  4EB9 00001EFE           1020              JSR         ABW         *Add absolute word in next word address.
00001A5E  4E75                    1021              RTS
00001A60                          1022              
00001A60  18FC 0056               1023  BCC_VC      MOVE.B      #'V',(A4)+
00001A64  18FC 0043               1024              MOVE.B      #'C',(A4)+
00001A68  18FC 0020               1025              MOVE.B      #' ',(A4)+
00001A6C  18FC 0020               1026              MOVE.B      #' ',(A4)+
00001A70  4EB9 00001EFE           1027              JSR         ABW         *Add absolute word in next word address.
00001A76  4E75                    1028              RTS
00001A78                          1029  
00001A78  18FC 0056               1030  BCC_VS      MOVE.B      #'V',(A4)+
00001A7C  18FC 0053               1031              MOVE.B      #'S',(A4)+
00001A80  18FC 0020               1032              MOVE.B      #' ',(A4)+
00001A84  18FC 0020               1033              MOVE.B      #' ',(A4)+
00001A88  4EB9 00001EFE           1034              JSR         ABW         *Add absolute word in next word address.
00001A8E  4E75                    1035              RTS
00001A90                          1036              
00001A90  18FC 0050               1037  BCC_PL      MOVE.B      #'P',(A4)+
00001A94  18FC 004C               1038              MOVE.B      #'L',(A4)+
00001A98  18FC 0020               1039              MOVE.B      #' ',(A4)+
00001A9C  18FC 0020               1040              MOVE.B      #' ',(A4)+
00001AA0  4EB9 00001EFE           1041              JSR         ABW         *Add absolute word in next word address.
00001AA6  4E75                    1042              RTS
00001AA8                          1043              
00001AA8  18FC 004D               1044  BCC_MI      MOVE.B      #'M',(A4)+
00001AAC  18FC 0049               1045              MOVE.B      #'I',(A4)+
00001AB0  18FC 0020               1046              MOVE.B      #' ',(A4)+
00001AB4  18FC 0020               1047              MOVE.B      #' ',(A4)+
00001AB8  4EB9 00001EFE           1048              JSR         ABW         *Add absolute word in next word address.
00001ABE  4E75                    1049              RTS
00001AC0                          1050              
00001AC0  18FC 0047               1051  BCC_GE      MOVE.B      #'G',(A4)+
00001AC4  18FC 0045               1052              MOVE.B      #'E',(A4)+
00001AC8  18FC 0020               1053              MOVE.B      #' ',(A4)+
00001ACC  18FC 0020               1054              MOVE.B      #' ',(A4)+
00001AD0  4EB9 00001EFE           1055              JSR         ABW         *Add absolute word in next word address.
00001AD6  4E75                    1056              RTS
00001AD8                          1057              
00001AD8  18FC 004C               1058  BCC_LT      MOVE.B      #'L',(A4)+
00001ADC  18FC 0054               1059              MOVE.B      #'T',(A4)+
00001AE0  18FC 0020               1060              MOVE.B      #' ',(A4)+
00001AE4  18FC 0020               1061              MOVE.B      #' ',(A4)+
00001AE8  4EB9 00001EFE           1062              JSR         ABW         *Add absolute word in next word address.
00001AEE  4E75                    1063              RTS
00001AF0                          1064              
00001AF0  18FC 0047               1065  BCC_GT      MOVE.B      #'G',(A4)+
00001AF4  18FC 0054               1066              MOVE.B      #'T',(A4)+
00001AF8  18FC 0020               1067              MOVE.B      #' ',(A4)+
00001AFC  18FC 0020               1068              MOVE.B      #' ',(A4)+
00001B00  4EB9 00001EFE           1069              JSR         ABW         *Add absolute word in next word address.
00001B06  4E75                    1070              RTS
00001B08                          1071              
00001B08  18FC 004C               1072  BCC_LE      MOVE.B      #'L',(A4)+
00001B0C  18FC 0045               1073              MOVE.B      #'E',(A4)+
00001B10  18FC 0020               1074              MOVE.B      #' ',(A4)+
00001B14  18FC 0020               1075              MOVE.B      #' ',(A4)+
00001B18  4EB9 00001EFE           1076              JSR         ABW         *Add absolute word in next word address.
00001B1E  4E75                    1077              RTS
00001B20                          1078  
00001B20                          1079  
00001B20  B83C 0000               1080  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn/an
00001B24  6700 0012               1081              BEQ         B_SIZE
00001B28  B83C 0001               1082              CMP.B       #1,D4       *Is it a W, <ea>,dn/an
00001B2C  6700 0018               1083              BEQ         W_SIZE
00001B30  B83C 0002               1084              CMP.B       #2,D4       *Is it a L, <ea>,dn/an
00001B34  6700 001E               1085              BEQ         L_SIZE 
00001B38                          1086              
00001B38  18FC 0042               1087  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
00001B3C  18FC 0020               1088              MOVE.B      #' ',(A4)+
00001B40  18FC 0020               1089              MOVE.B      #' ',(A4)+
00001B44  4E75                    1090              RTS
00001B46                          1091  
00001B46  18FC 0057               1092  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
00001B4A  18FC 0020               1093              MOVE.B      #' ',(A4)+
00001B4E  18FC 0020               1094              MOVE.B      #' ',(A4)+
00001B52  4E75                    1095              RTS
00001B54                          1096  
00001B54  18FC 004C               1097  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
00001B58  18FC 0020               1098              MOVE.B      #' ',(A4)+
00001B5C  18FC 0020               1099              MOVE.B      #' ',(A4)+
00001B60  4E75                    1100              RTS
00001B62                          1101  
00001B62  4284                    1102  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B64  3807                    1103              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B66  EF4C                    1104              LSL.W       #7,D4       *Clear more significant bits
00001B68  4283                    1105              CLR.L       D3          *Make sure D3 is clear for shifting
00001B6A  163C 000D               1106              MOVE.B      #13,D3      *Shifting 13 times
00001B6E  E66C                    1107              LSR.W       D3,D4       *Move size bits to LSB position
00001B70  4E75                    1108              RTS
00001B72                          1109  
00001B72  4284                    1110  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B74  3807                    1111              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B76  E14C                    1112              LSL.W       #8,D4       *Clear more significant bits
00001B78  4283                    1113              CLR.L       D3          *Make sure D3 is clear for shifting
00001B7A  163C 000E               1114              MOVE.B      #14,D3      *Shifting 14 times
00001B7E  E66C                    1115              LSR.W       D3,D4       *Move size bits to LSB position
00001B80  4E75                    1116              RTS
00001B82                          1117  
00001B82  4284                    1118  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001B84  3807                    1119              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001B86  4283                    1120              CLR.L       D3          *Make sure D3 is clear for shifting
00001B88  163C 0009               1121              MOVE.B      #9,D3       *Shift 9 times to the left
00001B8C  E76C                    1122              LSL.W       D3,D4       *Clear more significant bits
00001B8E  4283                    1123              CLR.L       D3          *Make sure D3 is clear for shifting
00001B90  163C 000F               1124              MOVE.B      #15,D3      *Shifting 15 times
00001B94  E66C                    1125              LSR.W       D3,D4       *Move size bits to LSB position
00001B96  4E75                    1126              RTS
00001B98                          1127  
00001B98  B83C 0000               1128  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00001B9C  6700 002E               1129              BEQ         B_EA
00001BA0  B83C 0001               1130              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001BA4  6700 003A               1131              BEQ         W_EA
00001BA8  B83C 0002               1132              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001BAC  6700 0046               1133              BEQ         L_EA
00001BB0                          1134  
00001BB0  B83C 0004               1135              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001BB4  6700 0052               1136              BEQ         B_DN
00001BB8  B83C 0005               1137              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001BBC  6700 005E               1138              BEQ         W_DN
00001BC0  B83C 0006               1139              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001BC4  6700 006A               1140              BEQ         L_DN        
00001BC8  6000 F522               1141              BRA         INVALID     *Got here, must be invalid data.
00001BCC                          1142              
00001BCC  18FC 0042               1143  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
00001BD0  18FC 0020               1144              MOVE.B      #' ',(A4)+
00001BD4  18FC 0020               1145              MOVE.B      #' ',(A4)+
00001BD8  4EB9 00001C46           1146              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001BDE  4E75                    1147              RTS
00001BE0                          1148  
00001BE0  18FC 0057               1149  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
00001BE4  18FC 0020               1150              MOVE.B      #' ',(A4)+
00001BE8  18FC 0020               1151              MOVE.B      #' ',(A4)+
00001BEC  4EB9 00001C46           1152              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001BF2  4E75                    1153              RTS
00001BF4                          1154  
00001BF4  18FC 004C               1155  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00001BF8  18FC 0020               1156              MOVE.B      #' ',(A4)+
00001BFC  18FC 0020               1157              MOVE.B      #' ',(A4)+
00001C00  4EB9 00001C46           1158              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001C06  4E75                    1159              RTS
00001C08                          1160  
00001C08  18FC 0042               1161  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001C0C  18FC 0020               1162              MOVE.B      #' ',(A4)+
00001C10  18FC 0020               1163              MOVE.B      #' ',(A4)+
00001C14  4EB9 00001C72           1164              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C1A  4E75                    1165              RTS
00001C1C                          1166  
00001C1C  18FC 0057               1167  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
00001C20  18FC 0020               1168              MOVE.B      #' ',(A4)+
00001C24  18FC 0020               1169              MOVE.B      #' ',(A4)+
00001C28  4EB9 00001C72           1170              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C2E  4E75                    1171              RTS
00001C30                          1172  
00001C30  18FC 004C               1173  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001C34  18FC 0020               1174              MOVE.B      #' ',(A4)+
00001C38  18FC 0020               1175              MOVE.B      #' ',(A4)+
00001C3C  4EB9 00001C72           1176              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001C42  4E75                    1177              RTS            
00001C44                          1178              
00001C44                          1179              
00001C44                          1180              
00001C44                          1181              
00001C44                          1182              
00001C44                          1183              
00001C44                          1184              
00001C44                          1185  
00001C44                          1186  
00001C44                          1187  
00001C44                          1188  
00001C44                          1189  
00001C44                          1190  
00001C44                          1191  
00001C44                          1192  -------------------- end include --------------------
00001C44                          1193              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001C44                          1194  
00001C44                          1195  
00001C44                          1196  JMP_EX      
00001C44  4E75                    1197              RTS
00001C46                          1198  
00001C46                          1199  
00001C46                          1200  
00001C46                          1201  
00001C46                          1202  
00001C46  4EB9 00001D58           1203  EASRC_DDES  JSR         GEN_EA_CODE *Deal with EA code First
00001C4C  18FC 002C               1204              MOVE.B      #',',(A4)+
00001C50  18FC 0044               1205              MOVE.B      #'D',(A4)+
00001C54  4EB9 00001DC0           1206              JSR         REG_CODE    *Decode Dn and add number to string
00001C5A  4E75                    1207              RTS
00001C5C                          1208  
00001C5C  4EB9 00001D58           1209  EASRC_ADES  JSR         GEN_EA_CODE *Deal with EA code first
00001C62  18FC 002C               1210              MOVE.B      #',',(A4)+
00001C66  18FC 0041               1211              MOVE.B      #'A',(A4)+
00001C6A  4EB9 00001DC0           1212              JSR         REG_CODE    *Decode Dn and add number to string
00001C70  4E75                    1213              RTS        
00001C72                          1214  
00001C72  18FC 0044               1215  DN_SRC      MOVE.B      #'D',(A4)+
00001C76  4EB9 00001DC0           1216              JSR         REG_CODE    *Decode Dn and add number to string
00001C7C  18FC 002C               1217              MOVE.B      #',',(A4)+
00001C80  4EB9 00001D58           1218              JSR         GEN_EA_CODE *Deal with EA code Second
00001C86  4E75                    1219              RTS
00001C88                          1220  
00001C88  4EB9 00001F1E           1221  IDATASRC_EA JSR     IDATA       *Add immediate data
00001C8E  18FC 002C               1222              MOVE.B  #',',(A4)+  
00001C92  4EB9 00001D58           1223              JSR     GEN_EA_CODE *Add ea code
00001C98  4E75                    1224              RTS
00001C9A                          1225  
00001C9A                          1226  
00001C9A  4EB9 00001D48           1227  MM_OP_ORD   JSR         MM_DR       *Isolate DR bit into D2
00001CA0                          1228  
00001CA0  B43C 0000               1229              CMP.B       #0,D2       *Is it Register to Memory
00001CA4  6700 000A               1230              BEQ         MM_R2M
00001CA8  B43C 0001               1231              CMP.B       #1,D2       *Is it Memory to Register
00001CAC  6700 000A               1232              BEQ         MM_M2R
00001CB0                          1233              
00001CB0  4EB9 00001CD6           1234  MM_R2M      JSR         MM_LS_SRC
00001CB6  4E75                    1235              RTS
00001CB8                          1236  
00001CB8  4EB9 00001CC0           1237  MM_M2R      JSR         MM_EA_SRC
00001CBE  4E75                    1238              RTS
00001CC0                          1239  
00001CC0  4EB9 00001D58           1240  MM_EA_SRC   JSR         GEN_EA_CODE *Add EA code
00001CC6  18FC 002C               1241              MOVE.B      #',',(A4)+
00001CCA                          1242              *JSR         ISO_MASK    *Isolate the Mask
00001CCA                          1243              
00001CCA                          1244              *Bandaid, instead of decoding list, just display hex value
00001CCA  18FC 0024               1245              MOVE.B      #'$',(A4)+
00001CCE  4EB9 00001F6E           1246              JSR         W_IMD
00001CD4                          1247                      
00001CD4                          1248              *deal with list
00001CD4  4E75                    1249              RTS
00001CD6                          1250  
00001CD6                          1251  MM_LS_SRC   *Bandaid, instead of decoding list, just display hex value
00001CD6  18FC 0024               1252              MOVE.B      #'$',(A4)+
00001CDA  4EB9 00001F6E           1253              JSR         W_IMD
00001CE0                          1254              
00001CE0                          1255              *Deal with list first
00001CE0  18FC 002C               1256              MOVE.B      #',',(A4)+
00001CE4  4EB9 00001D58           1257              JSR         GEN_EA_CODE *Add EA code
00001CEA  4E75                    1258              RTS
00001CEC                          1259  
00001CEC  4281                    1260  MOVEQ_EA    CLR.L       D1          *Make sure D1 is clear
00001CEE  3207                    1261              MOVE.W      D7,D1       *copy original opcode
00001CF0  18FC 0020               1262              MOVE.B      #' ',(A4)+
00001CF4  18FC 0020               1263              MOVE.B      #' ',(A4)+
00001CF8  18FC 0023               1264              MOVE.B      #'#',(A4)+
00001CFC  18FC 0024               1265              MOVE.B      #'$',(A4)+
00001D00  4EB9 00001FFA           1266              JSR         B_H2A       *Add data in 8 least sig bits (byte)
00001D06  18FC 002C               1267              MOVE.B      #',',(A4)+
00001D0A  18FC 0044               1268              MOVE.B      #'D',(A4)+
00001D0E                          1269              
00001D0E  4281                    1270              CLR.L       D1
00001D10  123C 000D               1271              MOVE.B      #13,D1
00001D14  E94B                    1272              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001D16  E26B                    1273              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D18                          1274              
00001D18  4EB9 00001DC0           1275              JSR         REG_CODE    *Decode Dn and add number to string            
00001D1E                          1276  
00001D1E  4E75                    1277              RTS
00001D20                          1278              
00001D20  4281                    1279  ADDQ_EA     CLR.L       D1          *Make sure D1 is clear
00001D22  3207                    1280              MOVE.W      D7,D1       *Move untoched opcode into D1 for Manipulation
00001D24                          1281              
00001D24  E949                    1282              LSL.W       #4,D1       *Clear more sig bits
00001D26  4282                    1283              CLR.L       D2          * for shifting
00001D28  143C 000D               1284              MOVE.B      #13,D2      *To move data bits into lsb
00001D2C  E469                    1285              LSR.W       D2,D1       *Data now in lsb
00001D2E                          1286              
00001D2E  18FC 0023               1287              MOVE.B      #'#',(A4)+
00001D32  18FC 0024               1288              MOVE.B      #'$',(A4)+
00001D36  4EB9 00001F86           1289              JSR         ADDQ_ID     *Jump to ADDQ_ID (immeidate data selector)
00001D3C  18FC 002C               1290              MOVE.B      #',',(A4)+  *Add seperator
00001D40  4EB9 00001D58           1291              JSR         GEN_EA_CODE *Add the ea code
00001D46                          1292              
00001D46  4E75                    1293              RTS
00001D48                          1294  
00001D48                          1295  
00001D48                          1296  
00001D48  4281                    1297  MM_DR       CLR.L       D1
00001D4A  4282                    1298              CLR.L       D2
00001D4C  3407                    1299              MOVE.W      D7,D2
00001D4E  EB4A                    1300              LSL.W       #5,D2
00001D50  123C 000F               1301              MOVE.B      #15,D1
00001D54  E26A                    1302              LSR.W       D1,D2
00001D56  4E75                    1303              RTS
00001D58                          1304  
00001D58  4283                    1305  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001D5A  4286                    1306              CLR.L       D6          *Make sure D6 is clear
00001D5C  4281                    1307              CLR.L       D1          *Make sure D1 is clear for shifting
00001D5E                          1308              
00001D5E  3607                    1309              MOVE.W      D7,D3       *Move untouched opcode into D3
00001D60  3C07                    1310              MOVE.W      D7,D6       *Move untouched opcode into D6
00001D62                          1311              
00001D62  123C 000A               1312              MOVE.B      #10,D1      *Shifting to isolate MODE
00001D66  E36E                    1313              LSL.W       D1,D6       
00001D68  123C 000D               1314              MOVE.B      #13,D1
00001D6C  E26E                    1315              LSR.W       D1,D6       *Move MODE bits to LSB position
00001D6E                          1316              
00001D6E  E36B                    1317              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001D70  E26B                    1318              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D72                          1319              
00001D72  4EB9 00001DD6           1320              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001D78  4E75                    1321              RTS
00001D7A                          1322              
00001D7A  4283                    1323  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001D7C  4286                    1324              CLR.L       D6          *Make sure D6 is clear
00001D7E  4281                    1325              CLR.L       D1          *Make sure D1 is clear for shifting
00001D80                          1326              
00001D80  3607                    1327              MOVE.W      D7,D3       *Move untouched opcode into D3
00001D82  3C07                    1328              MOVE.W      D7,D6       *Move untouched opcode into D6
00001D84                          1329              
00001D84  123C 000A               1330              MOVE.B      #10,D1      *Shifting to isolate MODE
00001D88  E36E                    1331              LSL.W       D1,D6       
00001D8A  123C 000D               1332              MOVE.B      #13,D1
00001D8E  E26E                    1333              LSR.W       D1,D6       *Move MODE bits to LSB position
00001D90                          1334              
00001D90  E36B                    1335              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001D92  E26B                    1336              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001D94                          1337              
00001D94  4EB9 00001DD6           1338              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001D9A                          1339              
00001D9A  18FC 002C               1340              MOVE.B      #',',(A4)+  *SEPERATOR
00001D9E                          1341              
00001D9E  4283                    1342              CLR.L       D3          *Make sure D3 is clear
00001DA0  4286                    1343              CLR.L       D6          *Make sure D6 is clear
00001DA2  4281                    1344              CLR.L       D1          *Make sure D1 is clear for shifting
00001DA4                          1345              
00001DA4  3607                    1346              MOVE.W      D7,D3       *Move untouched opcode into D3
00001DA6  3C07                    1347              MOVE.W      D7,D6       *Move untouched opcode into D6
00001DA8                          1348              
00001DA8  123C 0007               1349              MOVE.B      #7,D1      *Shifting to isolate MODE
00001DAC  E36E                    1350              LSL.W       D1,D6       
00001DAE  123C 000D               1351              MOVE.B      #13,D1
00001DB2  E26E                    1352              LSR.W       D1,D6       *Move MODE bits to LSB position
00001DB4                          1353              
00001DB4  E94B                    1354              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001DB6  E26B                    1355              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001DB8                          1356              
00001DB8  4EB9 00001DD6           1357              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001DBE                          1358              
00001DBE  4E75                    1359              RTS
00001DC0                          1360              
00001DC0                          1361              
00001DC0  4283                    1362  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
00001DC2  3607                    1363              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
00001DC4  E94B                    1364              LSL.W       #4,D3       *Isolate bits and move to LSB position
00001DC6  4282                    1365              CLR.L       D2
00001DC8  143C 000D               1366              MOVE.B      #13,D2
00001DCC  E46B                    1367              LSR.W       D2,D3
00001DCE  4EB9 00001E6E           1368              JSR         REG_TBL     *Jump to register table.
00001DD4  4E75                    1369              RTS
00001DD6                          1370              
00001DD6                          1371  
00001DD6                          1372  
00001DD6                          1373  
00001DD6  BC3C 0000               1374  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
00001DDA  6700 002E               1375              BEQ         DRD
00001DDE  BC3C 0001               1376              CMP.B       #1,D6
00001DE2  6700 0032               1377              BEQ         ARD
00001DE6  BC3C 0002               1378              CMP.B       #2,D6
00001DEA  6700 0036               1379              BEQ         ARI
00001DEE  BC3C 0003               1380              CMP.B       #3,D6
00001DF2  6700 0042               1381              BEQ         ARI_INC
00001DF6  BC3C 0004               1382              CMP.B       #4,D6
00001DFA  6700 0052               1383              BEQ         ARI_DEC
00001DFE  BC3C 0007               1384              CMP.B       #7,D6
00001E02  6700 0062               1385              BEQ         ABS_ADDR
00001E06  4EF8 10EC               1386              JMP         INVALID     *Got here? Must be bad data.
00001E0A                          1387  
00001E0A  18FC 0044               1388  DRD         MOVE.B      #'D',(A4)+
00001E0E  4EB9 00001E6E           1389              JSR         REG_TBL     *Reg num should be in D3
00001E14  4E75                    1390              RTS
00001E16                          1391  
00001E16  18FC 0041               1392  ARD         MOVE.B      #'A',(A4)+
00001E1A  4EB9 00001E6E           1393              JSR         REG_TBL     *Reg num should be in D3
00001E20  4E75                    1394              RTS
00001E22                          1395  
00001E22  18FC 0028               1396  ARI         MOVE.B      #'(',(A4)+
00001E26  18FC 0041               1397              MOVE.B      #'A',(A4)+
00001E2A  4EB9 00001E6E           1398              JSR         REG_TBL     *Reg num should be in D3
00001E30  18FC 0029               1399              MOVE.B      #')',(A4)+
00001E34  4E75                    1400              RTS
00001E36                          1401  
00001E36  18FC 0028               1402  ARI_INC     MOVE.B      #'(',(A4)+
00001E3A  18FC 0041               1403              MOVE.B      #'A',(A4)+
00001E3E  4EB9 00001E6E           1404              JSR         REG_TBL     *Reg num should be in D3
00001E44  18FC 0029               1405              MOVE.B      #')',(A4)+
00001E48  18FC 002B               1406              MOVE.B      #'+',(A4)+
00001E4C  4E75                    1407              RTS
00001E4E                          1408  
00001E4E  18FC 002D               1409  ARI_DEC     MOVE.B      #'-',(A4)+
00001E52  18FC 0028               1410              MOVE.B      #'(',(A4)+
00001E56  18FC 0041               1411              MOVE.B      #'A',(A4)+
00001E5A  4EB9 00001E6E           1412              JSR         REG_TBL     *Reg num should be in D3
00001E60  18FC 0029               1413              MOVE.B      #')',(A4)+
00001E64  4E75                    1414              RTS
00001E66                          1415  
00001E66  4EB9 00001EE2           1416  ABS_ADDR    JSR         ABS_TBL
00001E6C  4E75                    1417              RTS
00001E6E                          1418              
00001E6E  B63C 0000               1419  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001E72  6700 003E               1420              BEQ         NUM_0
00001E76  B63C 0001               1421              CMP.B       #1,D3
00001E7A  6700 003C               1422              BEQ         NUM_1
00001E7E  B63C 0002               1423              CMP.B       #2,D3
00001E82  6700 003A               1424              BEQ         NUM_2
00001E86  B63C 0003               1425              CMP.B       #3,D3
00001E8A  6700 0038               1426              BEQ         NUM_3
00001E8E  B63C 0004               1427              CMP.B       #4,D3
00001E92  6700 0036               1428              BEQ         NUM_4
00001E96  B63C 0005               1429              CMP.B       #5,D3
00001E9A  6700 0034               1430              BEQ         NUM_5
00001E9E  B63C 0006               1431              CMP.B       #6,D3
00001EA2  6700 0032               1432              BEQ         NUM_6
00001EA6  B63C 0007               1433              CMP.B       #7,D3
00001EAA  6700 0030               1434              BEQ         NUM_7
00001EAE  4EF8 10EC               1435              JMP         INVALID     *Got here? Must be bad data.
00001EB2                          1436              
00001EB2  18FC 0030               1437  NUM_0       MOVE.B      #'0',(A4)+
00001EB6  4E75                    1438              RTS              
00001EB8  18FC 0031               1439  NUM_1       MOVE.B      #'1',(A4)+
00001EBC  4E75                    1440              RTS
00001EBE  18FC 0032               1441  NUM_2       MOVE.B      #'2',(A4)+
00001EC2  4E75                    1442              RTS
00001EC4  18FC 0033               1443  NUM_3       MOVE.B      #'3',(A4)+
00001EC8  4E75                    1444              RTS
00001ECA  18FC 0034               1445  NUM_4       MOVE.B      #'4',(A4)+
00001ECE  4E75                    1446              RTS
00001ED0  18FC 0035               1447  NUM_5       MOVE.B      #'5',(A4)+
00001ED4  4E75                    1448              RTS
00001ED6  18FC 0036               1449  NUM_6       MOVE.B      #'6',(A4)+
00001EDA  4E75                    1450              RTS
00001EDC  18FC 0037               1451  NUM_7       MOVE.B      #'7',(A4)+
00001EE0  4E75                    1452              RTS
00001EE2                          1453  
00001EE2  B63C 0000               1454  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001EE6  6700 0016               1455              BEQ         ABW
00001EEA  B63C 0001               1456              CMP.B       #1,D3
00001EEE  6700 001E               1457              BEQ         ABL
00001EF2  B63C 0004               1458              CMP.B       #4,D3
00001EF6  6700 0026               1459              BEQ         IDATA
00001EFA  4EF8 10EC               1460              JMP         INVALID     *Got here? Must be bad data.
00001EFE                          1461              
00001EFE  18FC 0024               1462  ABW         MOVE.B      #'$',(A4)+
00001F02  4281                    1463              CLR.L       D1          *Make sure D1 is clear
00001F04  321D                    1464              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F06  4EB9 0000203C           1465              JSR         W_H2A       *convert absolute value to ascii and add to good string
00001F0C  4E75                    1466              RTS
00001F0E                          1467  
00001F0E  18FC 0024               1468  ABL         MOVE.B      #'$',(A4)+
00001F12  4281                    1469              CLR.L       D1          *Make sure D1 is clear
00001F14  221D                    1470              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F16  4EB9 0000207E           1471              JSR         L_H2A
00001F1C  4E75                    1472              RTS
00001F1E                          1473              
00001F1E  18FC 0023               1474  IDATA       MOVE.B      #'#',(A4)+
00001F22  18FC 0024               1475              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
00001F26  4EB9 00001F2E           1476              JSR         IMD_TBL
00001F2C  4E75                    1477              RTS
00001F2E                          1478              
00001F2E  B83C 0000               1479  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
00001F32  6700 002E               1480              BEQ         B_IMD       
00001F36  B83C 0004               1481              CMP.B       #4,D4
00001F3A  6700 0026               1482              BEQ         B_IMD
00001F3E                          1483  
00001F3E  B83C 0001               1484              CMP.B       #1,D4       *Is it a word size code?
00001F42  6700 002A               1485              BEQ         W_IMD
00001F46  B83C 0005               1486              CMP.B       #5,D4
00001F4A  6700 0022               1487              BEQ         W_IMD
00001F4E                          1488              
00001F4E  B83C 0002               1489              CMP.B       #2,D4       *Is it a long word size code?
00001F52  6700 0026               1490              BEQ         L_IMD
00001F56  B83C 0006               1491              CMP.B       #6,D4
00001F5A  6700 001E               1492              BEQ         L_IMD
00001F5E                          1493              
00001F5E  6000 F18C               1494              BRA         INVALID     *Got here? Must be bad data.
00001F62                          1495              
00001F62  4281                    1496  B_IMD       CLR.L       D1
00001F64  321D                    1497              MOVE.W      (A5)+,D1    *Make sure D1 is clear
00001F66  4EB9 00001FFA           1498              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
00001F6C  4E75                    1499              RTS
00001F6E                          1500  
00001F6E  4281                    1501  W_IMD       CLR.L       D1          *Make sure D1 is clear
00001F70  321D                    1502              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
00001F72  4EB9 0000203C           1503              JSR         W_H2A
00001F78  4E75                    1504              RTS
00001F7A                          1505  
00001F7A  4281                    1506  L_IMD       CLR.L       D1          *Make sure D1 is clear
00001F7C  221D                    1507              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
00001F7E  4EB9 0000207E           1508              JSR         L_H2A
00001F84  4E75                    1509              RTS
00001F86                          1510  
00001F86  B23C 0000               1511  ADDQ_ID     CMP.B       #0,D1       *Select correct number to add to output strings
00001F8A  6700 003E               1512              BEQ         AQ_0
00001F8E  B23C 0001               1513              CMP.B       #1,D1
00001F92  6700 003C               1514              BEQ         AQ_1
00001F96  B23C 0002               1515              CMP.B       #2,D1
00001F9A  6700 003A               1516              BEQ         AQ_2
00001F9E  B23C 0003               1517              CMP.B       #3,D1
00001FA2  6700 0038               1518              BEQ         AQ_3
00001FA6  B23C 0004               1519              CMP.B       #4,D1
00001FAA  6700 0036               1520              BEQ         AQ_4
00001FAE  B23C 0005               1521              CMP.B       #5,D1
00001FB2  6700 0034               1522              BEQ         AQ_5
00001FB6  B23C 0006               1523              CMP.B       #6,D1
00001FBA  6700 0032               1524              BEQ         AQ_6
00001FBE  B23C 0007               1525              CMP.B       #7,D1
00001FC2  6700 0030               1526              BEQ         AQ_7
00001FC6  4EF8 10EC               1527              JMP         INVALID     *Got here? Something is wrong.
00001FCA                          1528              
00001FCA  18FC 0038               1529  AQ_0        MOVE.B      #'8',(A4)+
00001FCE  4E75                    1530              RTS              
00001FD0  18FC 0031               1531  AQ_1        MOVE.B      #'1',(A4)+
00001FD4  4E75                    1532              RTS
00001FD6  18FC 0032               1533  AQ_2        MOVE.B      #'2',(A4)+
00001FDA  4E75                    1534              RTS
00001FDC  18FC 0033               1535  AQ_3        MOVE.B      #'3',(A4)+
00001FE0  4E75                    1536              RTS
00001FE2  18FC 0034               1537  AQ_4        MOVE.B      #'4',(A4)+
00001FE6  4E75                    1538              RTS
00001FE8  18FC 0035               1539  AQ_5        MOVE.B      #'5',(A4)+
00001FEC  4E75                    1540              RTS
00001FEE  18FC 0036               1541  AQ_6        MOVE.B      #'6',(A4)+
00001FF2  4E75                    1542              RTS
00001FF4  18FC 0037               1543  AQ_7        MOVE.B      #'7',(A4)+
00001FF8  4E75                    1544              RTS          
00001FFA                          1545  
00001FFA                          1546              
00001FFA                          1547  
00001FFA                          1548  
00001FFA                          1549  INV_DATA *need to implement currently invalid data is treated as an invalid opcode.
00001FFA                          1550  
00001FFA                          1551  
00001FFA  4280                    1552  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00001FFC  4282                    1553              CLR.L       D2          *Make sure D2 is empty (each individual char)
00001FFE  4283                    1554              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002000  103C 0002               1555              MOVE.B      #$2,D0      *Counter
00002004  6000 0002               1556              BRA         B_ISO_DIG   *Begin isolating chars
00002008                          1557              
00002008  E919                    1558  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
0000200A                          1559              
0000200A  1401                    1560              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000200C                          1561              
0000200C  163C 0004               1562              MOVE.B      #4,D3      *Shift left 28 times
00002010  E72A                    1563              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00002012  E91A                    1564              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00002014                          1565              
00002014  0C02 0009               1566              CMPI.B      #$9,D2      *Is it a number?
00002018  6F00 0006               1567              BLE         B_NUM       *If it is, process number
0000201C  6000 000A               1568              BRA         B_LET       *If not, process letter
00002020                          1569              
00002020  0602 0030               1570  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002024  6000 000A               1571              BRA         B_ADD_CHAR  *add to strings and continue
00002028                          1572              
00002028  0602 0037               1573  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000202C  6000 0002               1574              BRA         B_ADD_CHAR  *add to strings and continue
00002030                          1575  
00002030  18C2                    1576  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00002032  5300                    1577              SUBI.B      #$1,D0      *decrement counter
00002034  0C00 0000               1578              CMPI.B      #$0,D0      *Check if we're done            
00002038  6ECE                    1579              BGT         B_ISO_DIG   *If not, continue tranlation   
0000203A                          1580              
0000203A  4E75                    1581              RTS
0000203C                          1582  
0000203C  4280                    1583  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
0000203E  4282                    1584              CLR.L       D2          *Make sure D2 is empty (each individual char)
00002040  4283                    1585              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002042  103C 0004               1586              MOVE.B      #$4,D0      *Counter
00002046  6000 0002               1587              BRA         W_ISO_DIG   *Begin isolating chars
0000204A                          1588              
0000204A  E959                    1589  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
0000204C                          1590              
0000204C  1401                    1591              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000204E                          1592              
0000204E  163C 000C               1593              MOVE.B      #12,D3      *Shift left 28 times
00002052  E76A                    1594              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
00002054  E95A                    1595              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
00002056                          1596              
00002056  0C02 0009               1597              CMPI.B      #$9,D2      *Is it a number?
0000205A  6F00 0006               1598              BLE         W_NUM       *If it is, process number
0000205E  6000 000A               1599              BRA         W_LET       *If not, process letter
00002062                          1600              
00002062  0602 0030               1601  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002066  6000 000A               1602              BRA         W_ADD_CHAR  *add to strings and continue
0000206A                          1603              
0000206A  0602 0037               1604  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000206E  6000 0002               1605              BRA         W_ADD_CHAR  *add to strings and continue
00002072                          1606  
00002072  18C2                    1607  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00002074  5300                    1608              SUBI.B      #$1,D0      *decrement counter
00002076  0C00 0000               1609              CMPI.B      #$0,D0      *Check if we're done            
0000207A  6ECE                    1610              BGT         W_ISO_DIG   *If not, continue tranlation   
0000207C                          1611              
0000207C  4E75                    1612              RTS
0000207E  4280                    1613  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
00002080  4282                    1614              CLR.L       D2          *Make sure D2 is empty (each individual char)
00002082  4283                    1615              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002084  103C 0008               1616              MOVE.B      #$8,D0      *Counter
00002088  6000 0002               1617              BRA         L_ISO_DIG   *Begin isolating chars
0000208C                          1618              
0000208C  E999                    1619  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
0000208E                          1620              
0000208E  1401                    1621              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00002090                          1622              
00002090  163C 001C               1623              MOVE.B      #28,D3      *Shift left 28 times
00002094  E7AA                    1624              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00002096  E99A                    1625              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00002098                          1626              
00002098  0C02 0009               1627              CMPI.B      #$9,D2      *Is it a number?
0000209C  6F00 0006               1628              BLE         L_NUM       *If it is, process number
000020A0  6000 000A               1629              BRA         L_LET       *If not, process letter
000020A4                          1630              
000020A4  0602 0030               1631  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000020A8  6000 000A               1632              BRA         L_ADD_CHAR  *add to strings and continue
000020AC                          1633              
000020AC  0602 0037               1634  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000020B0  6000 0002               1635              BRA         L_ADD_CHAR  *add to strings and continue
000020B4                          1636  
000020B4  18C2                    1637  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000020B6  5300                    1638              SUBI.B      #$1,D0      *decrement counter
000020B8  0C00 0000               1639              CMPI.B      #$0,D0      *Check if we're done            
000020BC  6ECE                    1640              BGT         L_ISO_DIG   *If not, continue tranlation   
000020BE                          1641              
000020BE  4E75                    1642              RTS
000020C0                          1643  
000020C0                          1644  
000020C0                          1645  
000020C0                          1646  
000020C0                          1647  
000020C0                          1648  
000020C0                          1649  
000020C0                          1650  
000020C0                          1651  -------------------- end include --------------------
000020C0                          1652  
000020C0  =0000000D               1653  CR          EQU         $0D
000020C0  =0000000A               1654  LF          EQU         $0A
000020C0                          1655  
000020C0= 2D 2D 2D 2D 2D 2D ...   1656  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
000020EA= 48 65 6E 72 79 20 ...   1657              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00002113= 43 53 53 20 34 32 ...   1658              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
0000213C= 2D 2D 2D 2D 2D 2D ...   1659              DC.B        '----------------------------------------',CR,LF,0
00002167                          1660  
00002167= 59 6F 75 20 4D 55 ...   1661  IN_WARN     DC.B        'You MUST follow the following input rules:',CR,LF
00002193= 31 2E 20 59 6F 75 ...   1662              DC.B        '1. Your starting address must be greater than or equal to $3000',CR,LF
000021D4= 20 20 20 28 74 68 ...   1663              DC.B        '   (this means your data file must be orged at $3000 or greater)',CR,LF
00002216= 32 2E 20 59 6F 75 ...   1664              DC.B        '2. Your ending address must be greater than your starting address',CR,LF
00002259= 33 2E 20 59 6F 75 ...   1665              DC.B        '3. You must enter something for both starting and ending (no NULL inputs)',CR,LF
000022A4= 34 2E 20 42 6F 74 ...   1666              DC.B        '4. Both your starting and ending address must be in the range of:',CR,LF
000022E7= 20 20 20 5B 24 33 ...   1667              DC.B        '   [$3000,$FFFFFFFF) (interval notation)',CR,LF
00002311= 35 2E 20 59 6F 75 ...   1668              DC.B        '5. Your inputs for both addresses may NOT be ODD values.',CR,LF
0000234B= 36 2E 20 59 6F 75 ...   1669              DC.B        '6. Your inputs for both must ONLY contain standard hexidecimal characters:',CR,LF
00002397= 20 20 20 30 20 31 ...   1670              DC.B        '   0 1 2 3 4 5 6 7 8 9 A B C D E F (Do NOT include spaces or $)',CR,LF
000023D8= 46 61 69 6C 75 72 ...   1671              DC.B        'Failure to follow these instructions WILL result in crash or unexpected behavior.',CR,LF,CR,LF,0
0000242E                          1672   
0000242E                          1673              
0000242E= 45 6E 74 65 72 20 ...   1674  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
00002451= 45 6E 74 65 72 20 ...   1675  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
00002472                          1676  
00002472= 0D 0A 50 72 65 73 ...   1677  NXT_PG      DC.B        CR,LF,'Press ENTER key to contiune reading',CR,CR,LF,0
0000249B                          1678  
0000249B= 0D 0A 50 72 65 73 ...   1679  END_PGR     DC.B        CR,LF,'Prese SPACE to decode another memory image.',CR,LF
000024CA= 50 72 65 73 73 20 ...   1680              DC.B        'Press ESC key to QUIT.',CR,LF,0
000024E3                          1681  
000024E3                          1682  STA_ADDR    DS.B        40
0000250B                          1683  END_ADDR    DS.B        40
00002533                          1684  
00002533                          1685  
00002533                          1686  
00002533                          1687  
00002534= 00000001                1688  BAD_STR     DC.L        1
00002538                          1689  
00002538= 00000050                1690  SPACER11    DC.L        80
0000253C= 00000050                1691  SPACER22    DC.L        80
00002540= 00000050                1692  SPACER33    DC.L        80
00002544= 00000050                1693  SPACER44    DC.L        80
00002548= 00000050                1694  SPACER55    DC.L        80
0000254C= 00000050                1695  SPACER66    DC.L        80
00002550= 00000050                1696  SPACER77    DC.L        80
00002554= 00000050                1697  SPACER88    DC.L        80
00002558= 00000050                1698  SPACER99    DC.L        80
0000255C= 00000050                1699  SPACERAA    DC.L        80
00002560= 00000050                1700  SPACERBB    DC.L        80
00002564= 00000050                1701  SPACERCC    DC.L        80
00002568= 00000050                1702  SPACERDD    DC.L        80
0000256C= 00000050                1703  SPACEREE    DC.L        80
00002570= 00000050                1704  SPACERFF    DC.L        80
00002574                          1705  
00002574= 00000001                1706  GOOD_STR    DC.L        1
00002578                          1707  
00002578= 00000050                1708  SPACER1     DC.L        80
0000257C= 00000050                1709  SPACER2     DC.L        80
00002580= 00000050                1710  SPACER3     DC.L        80
00002584= 00000050                1711  SPACER4     DC.L        80
00002588= 00000050                1712  SPACER5     DC.L        80
0000258C= 00000050                1713  SPACER6     DC.L        80
00002590= 00000050                1714  SPACER7     DC.L        80
00002594= 00000050                1715  SPACER8     DC.L        80
00002598= 00000050                1716  SPACER9     DC.L        80
0000259C= 00000050                1717  SPACERA     DC.L        80
000025A0= 00000050                1718  SPACERB     DC.L        80
000025A4= 00000050                1719  SPACERC     DC.L        80
000025A8= 00000050                1720  SPACERD     DC.L        80
000025AC= 00000050                1721  SPACERE     DC.L        80
000025B0= 00000050                1722  SPACERF     DC.L        80
000025B4                          1723  
000025B4                          1724              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 1F0E
ABS_ADDR            1E66
ABS_TBL             1EE2
ABW                 1EFE
ADDQ_EA             1D20
ADDQ_ID             1F86
ADD_CHAR_B          1218
ADD_CHAR_BO         125E
ADD_CHAR_G          11D0
ADD_SIZE            1B20
AH_DONE             109E
AQ_0                1FCA
AQ_1                1FD0
AQ_2                1FD6
AQ_3                1FDC
AQ_4                1FE2
AQ_5                1FE8
AQ_6                1FEE
AQ_7                1FF4
ARD                 1E16
ARI                 1E22
ARI_DEC             1E4E
ARI_INC             1E36
ASCII_HEX           1086
BAD_STR             2534
BCC_CC              1A00
BCC_CODE            1946
BCC_CS              1A18
BCC_EQ              1A48
BCC_GE              1AC0
BCC_GT              1AF0
BCC_HI              19D0
BCC_LE              1B08
BCC_LS              19E8
BCC_LT              1AD8
BCC_MI              1AA8
BCC_NE              1A30
BCC_PL              1A90
BCC_TABLE           195C
BCC_VC              1A60
BCC_VS              1A78
B_ADD_CHAR          2030
B_DN                1C08
B_EA                1BCC
B_H2A               1FFA
B_IMD               1F62
B_ISO_DIG           2008
B_LET               2028
B_NUM               2020
B_SIZE              1B38
CLEAN_GS            112A
CONTINUE            10F6
CR                  D
DECODE_LOOP         10C2
DN_SRC              1C72
DONE                130A
DRD                 1E0A
D_CLEAN             113E
EASRC_ADES          1C5C
EASRC_DDES          1C46
EA_TBL              1DD6
END_ADDR            250B
END_MSG             2451
END_OPT             12E6
END_PGR             249B
FORMAT              10B4
GEN_EA_CODE         1D58
GET_INPUT           1020
GET_SIZE_1          1B82
GET_SIZE_2          1B72
GET_SIZE_3          1B62
GOOD_STR            2574
GS_LOOP             1130
H2A_B_ADDR          11DC
H2A_B_OP            1224
H2A_G_ADDR          1194
IDATA               1F1E
IDATASRC_EA         1C88
IMD_TBL             1F2E
INIT_BAD            1162
INIT_GOOD           114E
INIT_STRS           1140
INTRO               1012
INVALID             10EC
INV_DATA            1FFA
IN_WARN             2167
ISODIG_BO           1236
ISO_DIG_B           11F0
ISO_DIG_G           11A8
JMP_0               131C
JMP_0X              147A
JMP_1               132C
JMP_2               133C
JMP_2X              14A4
JMP_3               134C
JMP_3X              14C8
JMP_4               135C
JMP_47X             1602
JMP_4X              14EC
JMP_5               136C
JMP_6               137C
JMP_6X              1532
JMP_7               138C
JMP_8               139C
JMP_8X              1556
JMP_9               13AC
JMP_A               13BC
JMP_B               13CA
JMP_C               13D8
JMP_CX              157A
JMP_D               13E8
JMP_DX              159E
JMP_E               13F8
JMP_EX              1C44
JMP_TBL             1310
J_47X               151A
J_ADDI              149C
J_AND               1596
J_BCC               154E
J_BRA               1546
J_CLR1              143C
J_CLR2              142C
J_CLR3              141C
J_CLR4              140C
J_CLR_DM            146A
J_CLR_LEA           144C
J_CLR_MM            145C
J_DIVU              156A
J_LEA               1522
J_MOVEAL            14B8
J_MOVEAW            14DC
J_MOVEL             14C0
J_MOVEM             152A
J_MOVEW             14E4
J_MULS              158E
J_OR                1572
J_SUBI              1494
LET                 10AA
LET_B               1210
LET_BO              1256
LET_G               11C8
LF                  A
L_ADD_CHAR          20B4
L_DN                1C30
L_EA                1BF4
L_H2A               207E
L_IMD               1F7A
L_ISO_DIG           208C
L_LET               20AC
L_NUM               20A4
L_SIZE              1B54
MM_ADD_S            176C
MM_DR               1D48
MM_EA_SRC           1CC0
MM_LONG             1768
MM_LS_SRC           1CD6
MM_M2R              1CB8
MM_OP_ORD           1C9A
MM_R2M              1CB0
MM_WORD             1760
MOVEQ_EA            1CEC
MOV_EA_CODE         1D7A
NEXT_PAGE           110C
NL_INTRO            20C0
NUM                 10A0
NUM_0               1EB2
NUM_1               1EB8
NUM_2               1EBE
NUM_3               1EC4
NUM_4               1ECA
NUM_5               1ED0
NUM_6               1ED6
NUM_7               1EDC
NUM_B               1208
NUM_BO              124E
NUM_G               11C0
NXT_PG              2472
OPC_ADD             18F0
OPC_ADDA            18CE
OPC_ADDI            1662
OPC_ADDQ            16AE
OPC_AND             18B0
OPC_BCC             183E
OPC_BRA             1822
OPC_DIVU            184A
OPC_JSR             190E
OPC_LEA             1710
OPC_MOVEAL          177A
OPC_MOVEAW          17CE
OPC_MOVEB           168A
OPC_MOVEL           17A6
OPC_MOVEM           1732
OPC_MOVEQ           16D6
OPC_MOVEW           17FA
OPC_MULS            188A
OPC_NOP             192A
OPC_OR              1870
OPC_RTS             1938
OPC_SUB             16F2
OPC_SUBI            163A
OP_ADD              15FA
OP_ADDA             15F2
OR_ADD_SIZE         1B98
O_JSR               1632
O_NOP               1622
O_RTS               162A
PRG_RESET           1296
PRINT_B             1280
PRINT_G             126A
PRINT_GOOD          10E2
PROC_END            107A
PROC_STA            106E
REG_CODE            1DC0
REG_TBL             1E6E
SPACER1             2578
SPACER11            2538
SPACER2             257C
SPACER22            253C
SPACER3             2580
SPACER33            2540
SPACER4             2584
SPACER44            2544
SPACER5             2588
SPACER55            2548
SPACER6             258C
SPACER66            254C
SPACER7             2590
SPACER77            2550
SPACER8             2594
SPACER88            2554
SPACER9             2598
SPACER99            2558
SPACERA             259C
SPACERAA            255C
SPACERB             25A0
SPACERBB            2560
SPACERC             25A4
SPACERCC            2564
SPACERD             25A8
SPACERDD            2568
SPACERE             25AC
SPACEREE            256C
SPACERF             25B0
SPACERFF            2570
START               1000
STA_ADDR            24E3
STA_MSG             242E
W_ADD_CHAR          2072
W_DN                1C1C
W_EA                1BE0
W_H2A               203C
W_IMD               1F6E
W_ISO_DIG           204A
W_LET               206A
W_NUM               2062
W_SIZE              1B46
