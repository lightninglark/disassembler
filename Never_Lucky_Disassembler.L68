00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/19/2017 4:04:50 PM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C                            13              
0000100C                            14              *Assuming all input error checking is done before the next call (not yet implemented)
0000100C                            15              
0000100C  4EB9 000010B6             16              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            17              
00001012                            18              * final call of program, may need to be removed if we jump directly to DONE from the loop
00001012                            19              *JMP         DONE        *End Program               
00001012                            20                 
00001012                            21  *-----------------------INTRO-------------------------------
00001012  43F9 000016F2             22  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 23              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      24              TRAP        #15         
0000101E  4E75                      25              RTS         
00001020                            26  
00001020                            27  *--------------------GET_INPUT------------------------------
00001020  43F9 00001799             28  GET_INPUT   LEA         STA_MSG,A1  *Load STA_MSG into A1
00001026  103C 000E                 29              MOVE.B      #14,D0      *Trap task 14, display start address msg
0000102A  4E4F                      30              TRAP        #15         
0000102C                            31              
0000102C  43F9 00001803             32              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
00001032  103C 0002                 33              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001036  4E4F                      34              TRAP        #15         
00001038                            35              
00001038  4EB9 00001062             36              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000103E  4281                      37              CLR.L       D1          *Clear input length from D1
00001040                            38              
00001040  43F9 000017BC             39              LEA         END_MSG,A1  *Load END_MSG into A1
00001046  103C 000E                 40              MOVE.B      #14,D0      *Trap task 14, display end address msg
0000104A  4E4F                      41              TRAP        #15
0000104C                            42              
0000104C  43F9 0000182B             43              LEA         END_ADDR,A1 *Store input in END_ADDR variable
00001052  103C 0002                 44              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001056  4E4F                      45              TRAP        #15         
00001058                            46              
00001058  4EB9 0000106E             47              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000105E  4281                      48              CLR.L       D1          *Clear input length from D1
00001060                            49              
00001060  4E75                      50              RTS
00001062                            51              
00001062                            52  *--------------------PROC_STA-------------------------------
00001062                            53  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
00001062  4EB9 0000107A             54              JSR         ASCII_HEX   *Convert input into Hex
00001068                            55              
00001068                            56              *assuming all error checking is done before the next instruction (not yet implemented)
00001068                            57              
00001068  2A43                      58              MOVEA.L     D3,A5       *Move hex to STA_ADDR
0000106A  4283                      59              CLR.L       D3          *Clear D3
0000106C  4E75                      60              RTS                     
0000106E                            61  
0000106E                            62  *--------------------PROC_END-------------------------------
0000106E                            63  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000106E                            64              *      does not fall before start
0000106E  4EB9 0000107A             65              JSR         ASCII_HEX   *Convert input into Hex
00001074                            66              
00001074                            67              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            68              
00001074  2C43                      69              MOVE.L      D3,A6       *Move hex to END_ADDR
00001076  4283                      70              CLR.L       D3          *Clear D3
00001078  4E75                      71              RTS
0000107A                            72  
0000107A                            73  *-------------------ASCII_HEX-------------------------------
0000107A  0C01 0000                 74  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000107E  6700 0012                 75              BEQ         AH_DONE     *End subroutine if all converted
00001082  1419                      76              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001084  183C 0039                 77              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001088  B404                      78              CMP.B       D4,D2       *Check if ascii code is for a number or letter
0000108A  6F00 0008                 79              BLE         NUM         *Codes less than $39 imply a number, so branch
0000108E  6000 000E                 80              BRA         LET         *If not a number, must be a letter.            
00001092  4E75                      81  AH_DONE     RTS
00001094                            82  
00001094  183C 0030                 83  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
00001098  9404                      84              SUB.B       D4,D2       *convert to hexadecimal number
0000109A  6000 000C                 85              BRA         FORMAT      *branch to subroutine to store converted hex number
0000109E                            86              
0000109E  183C 0037                 87  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010A2  9404                      88              SUB.B       D4,D2       *convert to hexadecimal letter
000010A4  6000 0002                 89              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010A8                            90  
000010A8  5301                      91  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010AA  D602                      92              ADD.B       D2,D3       *Store converted number in D3
000010AC  0C01 0000                 93              CMPI.B      #$0,D1      *Check if we're all done converting
000010B0  67C8                      94              BEQ         ASCII_HEX   *If not continue conversion
000010B2  E983                      95              ASL.L       #4,D3       *Shift bits to the left to correct position
000010B4  60C4                      96              BRA         ASCII_HEX   *Branch back to label
000010B6                            97              
000010B6                            98  *-------------------DECODE_LOOP-----------------------------
000010B6  3E1D                      99  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010B8  47F9 00001894            100              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010BE  49F9 00001854            101              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010C4                           102              
000010C4  4EB9 0000111E            103              JSR         INIT_STRS   *Initialize Bad and Good Str
000010CA                           104              
000010CA  4EB9 00001262            105              JSR         JMP_TBL    *Start opcode identification waterfall
000010D0                           106              
000010D0                           107              *BELOW COMMENTED CODE TO BE REMOVED
000010D0                           108              *CMPI.B      #$FF,D6     *Look for good sentry value in D6 ($AA = good, $FF = bad)
000010D0                           109              *BEQ         PRINT_BAD   *Print good string if good opcode
000010D0                           110              *BRA         PRINT_GOOD  *Print bad string if bad opcode
000010D0  4EB9 0000122A            111  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010D6  6000 000C                112              BRA         CONTINUE    *Continue the loop
000010DA  4EB9 00001240            113  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010E0  6000 0002                114              BRA         CONTINUE    *Continue the loop            
000010E4                           115              
000010E4  BCCD                     116  CONTINUE    CMP.W       A5,A6       *Check if we're done
000010E6  6700 016E                117              BEQ         END_OPT     *if we're done, move to end options (ask user what to do)
000010EA                           118              
000010EA  4286                     119              CLR.L       D6          *Clear the bad/good flag register
000010EC                           120              
000010EC  5205                     121              ADDQ.B      #1,D5       *Increment line counter
000010EE  BA3C 0018                122              CMP.B       #24,D5      *See if page is full
000010F2  6700 0004                123              BEQ         NEXT_PAGE   *Jump to next page prompt
000010F6                           124              
000010F6                           125              *Maybe a BGT check here also? would that ever be possible?
000010F6                           126              *Need to implement line/page display (one page at a time via enter)
000010F6                           127              
000010F6  60BE                     128              BRA         DECODE_LOOP * Continue loop
000010F8                           129  
000010F8                           130  *-------------------NEXT_PAGE-----------------------------
000010F8  43F9 000017DD            131  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
000010FE  4280                     132              CLR.L       D0          *Make sure D0 is empty
00001100  103C 000E                133              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001104  4E4F                     134              TRAP        #15            
00001106                           135              
00001106  103C 000C                136              MOVE.B      #12,D0      *Keyboard echo trap task
0000110A  4281                     137              CLR.L       D1          *Start keyboard echo trap
0000110C  4E4F                     138              TRAP        #15         
0000110E                           139              
0000110E  103C 0005                140              MOVE.B      #5,D0       *Single char trap task
00001112  4E4F                     141              TRAP        #15         
00001114                           142              
00001114  B23C 000D                143              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001118  66DE                     144              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
0000111A                           145              
0000111A  4285                     146              CLR.L       D5          *Reset page counter
0000111C                           147              
0000111C  6098                     148              BRA         DECODE_LOOP *Continue the loop         
0000111E                           149              
0000111E                           150  *-------------------INIT_STRS-----------------------------
0000111E  4EB9 0000112C            151  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001124  4EB9 00001164            152              JSR         INIT_BAD    *Initialize the bad string
0000112A  4E75                     153              RTS
0000112C                           154  *-------------------INIT_GOOD-----------------------------
0000112C  18FC 004C                155  INIT_GOOD   MOVE.B      #'L',(A4)+  *Add to good string  
00001130  18FC 0065                156              MOVE.B      #'e',(A4)+ 
00001134  18FC 0067                157              MOVE.B      #'g',(A4)+ 
00001138  18FC 0061                158              MOVE.B      #'a',(A4)+ 
0000113C  18FC 006C                159              MOVE.B      #'l',(A4)+
00001140  18FC 0020                160              MOVE.B      #' ',(A4)+
00001144  18FC 0020                161              MOVE.B      #' ',(A4)+ 
00001148  18FC 003A                162              MOVE.B      #':',(A4)+
0000114C  18FC 0020                163              MOVE.B      #' ',(A4)+ 
00001150  18FC 0024                164              MOVE.B      #'$',(A4)+ 
00001154                           165              
00001154  4EB9 000011E2            166              JSR         HEX_ASCII_G *Now convert opcode to ASCII
0000115A                           167              
0000115A  18FC 0020                168              MOVE.B      #' ',(A4)+  *Add spaces after memory location added
0000115E  18FC 0020                169              MOVE.B      #' ',(A4)+
00001162                           170              
00001162                           171              *Add 'Legal: ', then add opcode (must go from hex to ascii)
00001162                           172              
00001162                           173              
00001162  4E75                     174              RTS
00001164                           175  
00001164                           176  *-------------------INIT_BAD------------------------------            
00001164  16FC 0049                177  INIT_BAD    MOVE.B      #'I',(A3)+  *Add to bad string
00001168  16FC 006C                178              MOVE.B      #'l',(A3)+ 
0000116C  16FC 006C                179              MOVE.B      #'l',(A3)+    
00001170  16FC 0065                180              MOVE.B      #'e',(A3)+ 
00001174  16FC 0067                181              MOVE.B      #'g',(A3)+ 
00001178  16FC 0061                182              MOVE.B      #'a',(A3)+ 
0000117C  16FC 006C                183              MOVE.B      #'l',(A3)+ 
00001180  16FC 003A                184              MOVE.B      #':',(A3)+
00001184  16FC 0020                185              MOVE.B      #' ',(A3)+ 
00001188  16FC 0024                186              MOVE.B      #'$',(A3)+  
0000118C                           187              
0000118C  4EB9 0000119C            188              JSR         HEX_ASCII_B *Now convert opcode to ASCII
00001192                           189              
00001192  18FC 0020                190              MOVE.B      #' ',(A4)+  *Add spaces after bad code added
00001196  18FC 0020                191              MOVE.B      #' ',(A4)+
0000119A                           192              
0000119A                           193              *Add 'Illegal: ', then add opcode (must go from from hex to ascii)
0000119A                           194              
0000119A  4E75                     195              RTS
0000119C                           196              
0000119C                           197  *-------------------HEX_ASCII_B-------------------------------
0000119C  4280                     198  HEX_ASCII_B CLR.L       D0          *Make sure D0 is empty (Counter)
0000119E  4281                     199              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011A0  4282                     200              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011A2  4283                     201              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011A4  3207                     202              MOVE.W      D7,D1       *Copy opcode into D0 for working with
000011A6  103C 0004                203              MOVE.B      #$4,D0      *Counter
000011AA  6000 0002                204              BRA         ISO_DIG_B   *Begin isolating chars
000011AE                           205              
000011AE  E959                     206  ISO_DIG_B   ROL.W       #4,D1       *Move first significant hex char to least sig position
000011B0                           207              
000011B0  2401                     208              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011B2                           209              
000011B2  163C 001C                210              MOVE.B      #28,D3      *Shift left 28 times
000011B6  E7AA                     211              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B8  E99A                     212              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011BA                           213              
000011BA  0C02 0009                214              CMPI.B      #$9,D2      *Is it a number?
000011BE  6F00 0006                215              BLE         NUM_B       *If it is, process number
000011C2  6000 000A                216              BRA         LET_B       *If not, process letter
000011C6                           217  
000011C6  0602 0030                218  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
000011CA  6000 000A                219              BRA         ADD_CHAR_B  *add to strings and continue
000011CE                           220              
000011CE  0602 0037                221  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
000011D2  6000 0002                222              BRA         ADD_CHAR_B  *add to strings and continue
000011D6                           223              
000011D6  16C2                     224  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to bad data string
000011D8  5300                     225              SUBI.B      #$1,D0      *decrement counter
000011DA  0C00 0000                226              CMPI.B      #$0,D0      *Check if we're done            
000011DE  6ECE                     227              BGT         ISO_DIG_B   *If not, continue tranlation   
000011E0                           228              
000011E0  4E75                     229              RTS
000011E2                           230              
000011E2                           231  *-------------------HEX_ASCII_G-------------------------------            
000011E2  4280                     232  HEX_ASCII_G CLR.L       D0          *Make sure D0 is empty (Counter)
000011E4  4281                     233              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011E6  4282                     234              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E8  4283                     235              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011EA  220D                     236              MOVE.L      A5,D1       *Copy address into D7
000011EC  5501                     237              SUBI.B      #2,D1       *Move addres back one byte (for post increment)
000011EE  103C 0008                238              MOVE.B      #$8,D0      *Counter
000011F2  6000 0002                239              BRA         ISO_DIG_G   *Begin isolating chars
000011F6                           240              
000011F6  E999                     241  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F8                           242              
000011F8  2401                     243              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011FA                           244              
000011FA  163C 001C                245              MOVE.B      #28,D3      *Shift left 28 times
000011FE  E7AA                     246              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001200  E99A                     247              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001202                           248              
00001202  0C02 0009                249              CMPI.B      #$9,D2      *Is it a number?
00001206  6F00 0006                250              BLE         NUM_G       *If it is, process number
0000120A  6000 000A                251              BRA         LET_G       *If not, process letter
0000120E                           252              
0000120E  0602 0030                253  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
00001212  6000 000A                254              BRA         ADD_CHAR_G  *add to strings and continue
00001216                           255              
00001216  0602 0037                256  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
0000121A  6000 0002                257              BRA         ADD_CHAR_G  *add to strings and continue
0000121E                           258  
0000121E  18C2                     259  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
00001220  5300                     260              SUBI.B      #$1,D0      *decrement counter
00001222  0C00 0000                261              CMPI.B      #$0,D0      *Check if we're done            
00001226  6ECE                     262              BGT         ISO_DIG_G    *If not, continue tranlation   
00001228                           263              
00001228  4E75                     264              RTS
0000122A                           265              
0000122A                           266  *-------------------PRINT_G---------------------------------
0000122A  18FC 0020                267  PRINT_G     MOVE.B      #' ',(A4)+
0000122E  16FC 0000                268              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
00001232  43F9 00001854            269              LEA         GOOD_STR,A1 *Load good data for printing
00001238  103C 000D                270              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000123C  4E4F                     271              TRAP        #15         *Display string
0000123E                           272            
0000123E  4E75                     273              RTS 
00001240                           274  
00001240                           275  *-------------------PRINT_B---------------------------------
00001240  18FC 0020                276  PRINT_B     MOVE.B      #' ',(A4)+
00001244  18FC 0000                277              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001248  43F9 00001894            278              LEA         BAD_STR,A1 *Load good data for printing
0000124E  103C 000D                279              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001252  4E4F                     280              TRAP        #15         *Display string
00001254                           281              
00001254  4E75                     282              RTS 
00001256                           283  
00001256                           284  *-------------------END_OPT---------------------------------
00001256  4EF9 0000125C            285  END_OPT     JMP         DONE        *Jump to done for now untill end options logic is implemented
0000125C                           286              
0000125C                           287  *-----------------------DONE--------------------------------
0000125C  103C 0009                288  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
00001260  4E4F                     289              TRAP        #15         *Halt program, Trap#15 task 9
00001262                           290              
00001262                           291  *---------------Variables and Constants---------------------
00001262                           292              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
00001262                           293  
00001262                           294  
00001262  4282                     295  JMP_TBL     CLR.L       D2
00001264  3407                     296              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001266  4281                     297              CLR.L       D1
00001268  123C 000C                298              MOVE.B      #12,D1      *Moves 12 into D1
0000126C  E26A                     299              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000126E                           300                          
0000126E  B43C 0000                301  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00001272  6600 000A                302              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001276  4EB9 0000138A            303              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000127C  4E75                     304              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000127E                           305              
0000127E  B43C 0001                306  JMP_1       CMP.B       #$1,D2
00001282  6600 000A                307              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00001286  4EB9 000013EC            308              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
0000128C  4E75                     309              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000128E                           310             
0000128E  B43C 0002                311  JMP_2       CMP.B       #$2,D2
00001292  6600 000A                312              BNE         JMP_3 
00001296  4EB9 000013B4            313              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000129C  4E75                     314              RTS
0000129E                           315              
0000129E  B43C 0003                316  JMP_3       CMP.B       #$3,D2
000012A2  6600 000A                317              BNE         JMP_4
000012A6  4EB9 000013C0            318              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
000012AC  4E75                     319              RTS
000012AE                           320           
000012AE  B43C 0004                321  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
000012B2  6600 000A                322              BNE         JMP_5
000012B6  4EB9 000013C4            323              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
000012BC  4E75                     324              RTS
000012BE                           325              
000012BE  B43C 0005                326  JMP_5       CMP.B       #$5,D2
000012C2  6600 000A                327              BNE         JMP_6
000012C6  4EB9 0000140E            328              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
000012CC  4E75                     329              RTS
000012CE                           330              
000012CE  B43C 0006                331  JMP_6       CMP.B       #$6,D2
000012D2  6600 000A                332              BNE         JMP_7
000012D6  4EB9 000013C8            333              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
000012DC  4E75                     334              RTS
000012DE                           335              
000012DE  B43C 0007                336  JMP_7       CMP.B       #$7,D2
000012E2  6600 000A                337              BNE         JMP_8
000012E6  4EB9 00001424            338              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
000012EC  4E75                     339              RTS
000012EE                           340              
000012EE  B43C 0008                341  JMP_8       CMP.B       #$8,D2
000012F2  6600 000A                342              BNE         JMP_9
000012F6  4EB9 000013CC            343              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000012FC  4E75                     344              RTS
000012FE                           345              
000012FE  B43C 0009                346  JMP_9       CMP.B       #$9,D2
00001302  6600 000A                347              BNE         JMP_A
00001306  4EB9 00001442            348              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
0000130C  4E75                     349              RTS
0000130E                           350              
0000130E  B43C 000A                351  JMP_A       CMP.B       #$A,D2
00001312  6600 0008                352              BNE         JMP_B
00001316  4EB8 10DA                353              JSR         INVALID     *0xA is an invalid first hex digit. Jump to INVALID
0000131A  4E75                     354              RTS
0000131C                           355              
0000131C  B43C 000B                356  JMP_B       CMP.B       #$B,D2
00001320  6600 0008                357              BNE         JMP_C
00001324  4EB8 10DA                358              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
00001328  4E75                     359              RTS
0000132A                           360              
0000132A  B43C 000C                361  JMP_C       CMP.B       #$C,D2
0000132E  6600 000A                362              BNE         JMP_D
00001332  4EB9 000013D0            363              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
00001338  4E75                     364              RTS
0000133A                           365              
0000133A  B43C 000D                366  JMP_D       CMP.B       #$D,D2
0000133E  6600 000A                367              BNE         JMP_E   
00001342  4EB9 000013D4            368              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
00001348  4E75                     369              RTS
0000134A                           370              
0000134A  B43C 000F                371  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
0000134E  6700 FD8A                372              BEQ         INVALID     *If first hex value is F, jump to INVALID
00001352  4EB9 000013D8            373              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001358  4E75                     374              RTS
0000135A                           375   
0000135A                           376  
0000135A  4282                     377  J_CLR4      CLR.L       D2                                
0000135C  3407                     378              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000135E  4281                     379              CLR.L       D1
00001360  E94A                     380              LSL.W       #4,D2       *Clear the most sig hex digit
00001362  123C 000C                381              MOVE.B      #12,D1      *Moves 12 into D1
00001366  E26A                     382              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
00001368  4E75                     383              RTS                     *Return back to JMP_Xn    
0000136A                           384              
0000136A  4282                     385  J_CLR3      CLR.L       D2          
0000136C  3407                     386              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000136E  4281                     387              CLR.L       D1
00001370  E94A                     388              LSL.W       #4,D2       *Clear the most sig hex digit
00001372  123C 000D                389              MOVE.B      #13,D1      *Moves 13 into D1
00001376  E26A                     390              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
00001378  4E75                     391              RTS                     *Return back to JMP_Xn  
0000137A                           392  
0000137A  4282                     393  J_CLR_DM    CLR.L       D2          
0000137C  3407                     394              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
0000137E  4281                     395              CLR.L       D1
00001380  EF4A                     396              LSL.W       #7,D2       *Clear the most sig 7 bits
00001382  123C 0011                397              MOVE.B      #17,D1      *Moves 17 into D1
00001386  E26A                     398              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
00001388  4E75                     399              RTS                     *Return back to JMP_Xn     
0000138A                           400           
0000138A  4EB8 135A                401  JMP_0X      JSR         J_CLR4      *Prepare data registers for data manipulation on the second input hex digit
0000138E  B43C 0004                402              CMP.B       #$4,D2      *Is the next hex digit 4?
00001392  6700 0010                403              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00001396  B43C 0005                404              CMP.B       #$5,D2      *Is the next hex digit 5?
0000139A  6700 0010                405              BEQ         J_ADDI     *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
0000139E  4EB8 10DA                406              JSR         INVALID     *If neither, OPCODE is invalid
000013A2  4E75                     407              RTS
000013A4                           408  
000013A4  4EB9 000013DC            409  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
000013AA  4E75                     410              RTS
000013AC                           411              
000013AC  4EB9 000013E0            412  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
000013B2  4E75                     413              RTS              
000013B4                           414  
000013B4  4EB8 137A                415  JMP_2X      JSR         J_CLR_DM    *Prepare data registers for data manipulation on the DEST MODE digits
000013B8  B43C 0001                416              CMP.B       #$1,D2      *is the DEST MODE 1?
000013BC  6700 002A                417              BEQ         J_MOVEAL    *Instruction is determiend to be MOVEA.L                                     ================= < stopped at this point
000013C0                           418               
000013C0  4EB8 10DA                419  JMP_3X      JSR         INVALID     *Temp, remove once implemented
000013C4                           420  
000013C4  4EB8 10DA                421  JMP_4X      JSR         INVALID     *Temp, remove once implemented      
000013C8                           422  
000013C8  4EB8 10DA                423  JMP_6X      JSR         INVALID     *Temp, remove once implemented
000013CC                           424  
000013CC  4EB8 10DA                425  JMP_8X      JSR         INVALID     *Temp, remove once implemented
000013D0                           426  
000013D0  4EB8 10DA                427  JMP_CX      JSR         INVALID     *Temp, remove once implemented
000013D4                           428  
000013D4  4EB8 10DA                429  JMP_DX      JSR         INVALID     *Temp, remove once implemented
000013D8                           430  
000013D8  4EB8 10DA                431  JMP_EX      JSR         INVALID     *Temp, remove once implemented
000013DC                           432  
000013DC                           433  
000013DC  4EB8 10DA                434  OPC_04XX    JSR         INVALID     *Temp, remove once implemented
000013E0                           435  
000013E0  4EB8 10DA                436  OPC_05XX    JSR         INVALID     *Temp, remove once implemented
000013E4                           437  
000013E4                           438  
000013E4  4EB8 10DA                439  J_MOVEL     JSR         INVALID     *added just for compiling, remove once implemented
000013E8                           440  
000013E8  4EB8 10DA                441  J_MOVEAL    JSR         INVALID     *added just for compiling, remove once implemented
000013EC                           442  
000013EC                           443  
000013EC  18FC 004D                444  OPC_1XXX    MOVE.B      #'M',(A4)+
000013F0  18FC 004F                445              MOVE.B      #'O',(A4)+
000013F4  18FC 0056                446              MOVE.B      #'V',(A4)+
000013F8  18FC 0045                447              MOVE.B      #'E',(A4)+
000013FC  18FC 002E                448              MOVE.B      #'.',(A4)+
00001400  18FC 0042                449              MOVE.B      #'B',(A4)+
00001404  18FC 0020                450              MOVE.B      #' ',(A4)+
00001408  18FC 0020                451              MOVE.B      #' ',(A4)+
0000140C                           452              *JUMP to EACODE table
0000140C  4E75                     453              RTS
0000140E                           454  
0000140E  18FC 0041                455  OPC_5XXX    MOVE.B      #'A',(A4)+
00001412  18FC 0044                456              MOVE.B      #'D',(A4)+
00001416  18FC 0044                457              MOVE.B      #'D',(A4)+
0000141A  18FC 0051                458              MOVE.B      #'Q',(A4)+
0000141E  18FC 002E                459              MOVE.B      #'.',(A4)+
00001422                           460              *NEED to Determine sizes here
00001422                           461              *JUMP to EACODE table
00001422  4E75                     462              RTS
00001424                           463  
00001424  18FC 004D                464  OPC_7XXX    MOVE.B      #'M',(A4)+
00001428  18FC 004F                465              MOVE.B      #'O',(A4)+
0000142C  18FC 0056                466              MOVE.B      #'V',(A4)+
00001430  18FC 0045                467              MOVE.B      #'E',(A4)+
00001434  18FC 0051                468              MOVE.B      #'Q',(A4)+
00001438  18FC 002E                469              MOVE.B      #'.',(A4)+
0000143C  18FC 004C                470              MOVE.B      #'L',(A4)+
00001440                           471              *jump to EACODE table
00001440  4E75                     472              RTS
00001442                           473  
00001442  18FC 0053                474  OPC_9XXX    MOVE.B      #'S',(A4)+
00001446  18FC 0055                475              MOVE.B      #'U',(A4)+
0000144A  18FC 0042                476              MOVE.B      #'B',(A4)+
0000144E  18FC 002E                477              MOVE.B      #'.',(A4)+
00001452                           478              *NEED to Determine sizes here (opmode 3 bits)
00001452  4EB9 00001460            479              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001458  4EB9 00001496            480              JSR         ADD_SIZE    * This will add size characters and start operand decode sequence
0000145E                           481              *jump to EACODE table
0000145E  4E75                     482              RTS
00001460                           483  
00001460                           484  
00001460                           485  
00001460  4284                     486  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001462  3807                     487              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001464  EF4C                     488              LSL.W       #7,D4       *Clear more significant bits
00001466  4283                     489              CLR.L       D3          *Make sure D3 is clear for shifting
00001468  163C 000D                490              MOVE.B      #13,D3      *Shifting 13 times
0000146C  E66C                     491              LSR.W       D3,D4       *Move size bits to LSB position
0000146E  4E75                     492              RTS
00001470                           493  
00001470  4284                     494  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001472  3807                     495              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001474  E14C                     496              LSL.W       #8,D4       *Clear more significant bits
00001476  4283                     497              CLR.L       D3          *Make sure D3 is clear for shifting
00001478  163C 000E                498              MOVE.B      #14,D3      *Shifting 14 times
0000147C  E66C                     499              LSR.W       D3,D4       *Move size bits to LSB position
0000147E  4E75                     500              RTS
00001480                           501  
00001480  4284                     502  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001482  3807                     503              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001484  4283                     504              CLR.L       D3          *Make sure D3 is clear for shifting
00001486  163C 0009                505              MOVE.B      #9,D3       *Shift 9 times to the left
0000148A  E76C                     506              LSL.W       D3,D4       *Clear more significant bits
0000148C  4283                     507              CLR.L       D3          *Make sure D3 is clear for shifting
0000148E  163C 000F                508              MOVE.B      #15,D3      *Shifting 15 times
00001492  E66C                     509              LSR.W       D3,D4       *Move size bits to LSB position
00001494  4E75                     510              RTS
00001496                           511  
00001496  B83C 0000                512  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn
0000149A  6700 002E                513              BEQ         B_EA
0000149E  B83C 0001                514              CMP.B       #1,D4       *Is it a W, <ea>,dn
000014A2  6700 003A                515              BEQ         W_EA
000014A6  B83C 0002                516              CMP.B       #2,D4       *Is it a L, <ea>,dn
000014AA  6700 0046                517              BEQ         L_EA
000014AE                           518  
000014AE  B83C 0004                519              CMP.B       #4,D4       *Is it a B, dn,<ea>
000014B2  6700 0052                520              BEQ         B_DN
000014B6  B83C 0005                521              CMP.B       #5,D4       *Is it a W, dn,<ea>
000014BA  6700 005E                522              BEQ         W_DN
000014BE  B83C 0006                523              CMP.B       #6,D4       *Is it a L, dn,<ea>
000014C2  6700 006A                524              BEQ         L_DN        
000014C6  6000 FC12                525              BRA         INVALID     *Got here, must be invalid data.
000014CA                           526              
000014CA  18FC 0042                527  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
000014CE  18FC 0020                528              MOVE.B      #' ',(A4)+
000014D2  18FC 0020                529              MOVE.B      #' ',(A4)+
000014D6  4EB9 00001542            530              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
000014DC  4E75                     531              RTS
000014DE                           532  
000014DE  18FC 0057                533  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
000014E2  18FC 0020                534              MOVE.B      #' ',(A4)+
000014E6  18FC 0020                535              MOVE.B      #' ',(A4)+
000014EA  4EB9 00001542            536              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
000014F0  4E75                     537              RTS
000014F2                           538  
000014F2  18FC 004C                539  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
000014F6  18FC 0020                540              MOVE.B      #' ',(A4)+
000014FA  18FC 0020                541              MOVE.B      #' ',(A4)+
000014FE  4EB9 00001542            542              JSR         EA_SRC      *Move to EA_SRC to start parameter decode sequence
00001504  4E75                     543              RTS
00001506                           544  
00001506  18FC 0042                545  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
0000150A  18FC 0020                546              MOVE.B      #' ',(A4)+
0000150E  18FC 0020                547              MOVE.B      #' ',(A4)+
00001512  4EB9 00001558            548              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001518  4E75                     549              RTS
0000151A                           550  
0000151A  18FC 0057                551  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
0000151E  18FC 0020                552              MOVE.B      #' ',(A4)+
00001522  18FC 0020                553              MOVE.B      #' ',(A4)+
00001526  4EB9 00001558            554              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
0000152C  4E75                     555              RTS
0000152E                           556  
0000152E  18FC 004C                557  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001532  18FC 0020                558              MOVE.B      #' ',(A4)+
00001536  18FC 0020                559              MOVE.B      #' ',(A4)+
0000153A  4EB9 00001558            560              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001540  4E75                     561              RTS            
00001542                           562              
00001542                           563              
00001542                           564              
00001542                           565              
00001542                           566              
00001542                           567              
00001542                           568              
00001542                           569  
00001542                           570  -------------------- end include --------------------
00001542                           571              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001542                           572  
00001542                           573  
00001542  4EB9 00001574            574  EA_SRC      JSR         GEN_EA_CODE *Deal with EA code First
00001548  18FC 002C                575              MOVE.B      #',',(A4)+
0000154C  18FC 0044                576              MOVE.B      #'D',(A4)+
00001550  4EB9 00001598            577              JSR         DN_CODE     *Decode Dn and add number to string
00001556  4E75                     578              RTS
00001558                           579  
00001558  18FC 0044                580  DN_SRC      MOVE.B      #'D',(A4)+
0000155C  4EB9 00001598            581              JSR         DN_CODE     *Decode Dn and add number to string
00001562  18FC 002C                582              MOVE.B      #',',(A4)+
00001566  4EB9 00001574            583              JSR         GEN_EA_CODE *Deal with EA code Second
0000156C  4E75                     584              RTS
0000156E                           585  
0000156E                           586  MM_OP_ORD 
0000156E  4E75                     587              RTS
00001570                           588  
00001570                           589  MM_EA_SRC   *Deal with EA code first
00001570                           590              *Deal with list second
00001570  4E75                     591              RTS
00001572                           592  
00001572                           593  MM_LS_SRC   *Deal with list first
00001572                           594              *Deal with EA code second
00001572  4E75                     595              RTS
00001574                           596  
00001574                           597  
00001574                           598  
00001574  4283                     599  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001576  4284                     600              CLR.L       D4          *Make sure D4 is clear
00001578  4281                     601              CLR.L       D1          *Make sure D1 is clear for shifting
0000157A                           602              
0000157A  3607                     603              MOVE.W      D7,D3       *Move untouched opcode into D3
0000157C  3807                     604              MOVE.W      D7,D4       *Move untouched opcode into D4
0000157E                           605              
0000157E  123C 000A                606              MOVE.B      #10,D1      *Shifting to isolate MODE
00001582  E36C                     607              LSL.W       D1,D4       
00001584  123C 000D                608              MOVE.B      #13,D1
00001588  E26C                     609              LSR.W       D1,D4       *Move MODE bits to LSB position
0000158A                           610              
0000158A  E36B                     611              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
0000158C  E26B                     612              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
0000158E                           613              
0000158E  4EB9 000015AE            614              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001594  4E75                     615              RTS
00001596                           616              
00001596                           617  MOV_EA_CODE
00001596  4E75                     618              RTS
00001598                           619              
00001598                           620              
00001598  4283                     621  DN_CODE     CLR.L       D3          *Make sure D4 is empty to isolate Dn register
0000159A  3607                     622              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
0000159C  E94B                     623              LSL.W       #4,D3       *Isolate bits and move to LSB position
0000159E  4282                     624              CLR.L       D2
000015A0  143C 000D                625              MOVE.B      #13,D2
000015A4  E46B                     626              LSR.W       D2,D3
000015A6  4EB9 00001644            627              JSR         REG_TBL     *Jump to register table.
000015AC  4E75                     628              RTS
000015AE                           629  
000015AE                           630  
000015AE  B83C 0000                631  EA_TBL      CMP.B       #0,D4       *Select correct <EA> mode
000015B2  6700 002E                632              BEQ         DRD
000015B6  B83C 0001                633              CMP.B       #1,D4
000015BA  6700 0032                634              BEQ         ARD
000015BE  B83C 0002                635              CMP.B       #2,D4
000015C2  6700 0036                636              BEQ         ARI
000015C6  B83C 0003                637              CMP.B       #3,D4
000015CA  6700 0042                638              BEQ         ARI_INC
000015CE  B83C 0004                639              CMP.B       #4,D4
000015D2  6700 0052                640              BEQ         ARI_DEC
000015D6  B83C 0007                641              CMP.B       #7,D4
000015DA  6700 0060                642              BEQ         ABS_ADDR
000015DE  4EF8 10DA                643              JMP         INVALID     *Got here? Must be bad data.
000015E2                           644  
000015E2  18FC 0044                645  DRD         MOVE.B      #'D',(A4)+
000015E6  4EB9 00001644            646              JSR         REG_TBL     *Reg num should be in D3
000015EC  4E75                     647              RTS
000015EE                           648  
000015EE  18FC 0041                649  ARD         MOVE.B      #'A',(A4)+
000015F2  4EB9 00001644            650              JSR         REG_TBL     *Reg num should be in D3
000015F8  4E75                     651              RTS
000015FA                           652  
000015FA  18FC 0028                653  ARI         MOVE.B      #'(',(A4)+
000015FE  18FC 0041                654              MOVE.B      #'A',(A4)+
00001602  4EB9 00001644            655              JSR         REG_TBL     *Reg num should be in D3
00001608  18FC 0029                656              MOVE.B      #')',(A4)+
0000160C  4E75                     657              RTS
0000160E                           658  
0000160E  18FC 0028                659  ARI_INC     MOVE.B      #'(',(A4)+
00001612  18FC 0041                660              MOVE.B      #'A',(A4)+
00001616  4EB9 00001644            661              JSR         REG_TBL     *Reg num should be in D3
0000161C  18FC 0029                662              MOVE.B      #')',(A4)+
00001620  18FC 002B                663              MOVE.B      #'+',(A4)+
00001624  4E75                     664              RTS
00001626                           665  
00001626  18FC 002D                666  ARI_DEC     MOVE.B      #'-',(A4)+
0000162A  18FC 0028                667              MOVE.B      #'(',(A4)+
0000162E  18FC 0041                668              MOVE.B      #'A',(A4)+
00001632  4EB9 00001644            669              JSR         REG_TBL     *Reg num should be in D3
00001638  18FC 0029                670              MOVE.B      #')',(A4)+
0000163C                           671  
0000163C  4EB9 000016B8            672  ABS_ADDR    JSR         ABS_TBL
00001642  4E75                     673              RTS
00001644                           674              
00001644  B63C 0000                675  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
00001648  6700 003E                676              BEQ         NUM_0
0000164C  B63C 0001                677              CMP.B       #1,D3
00001650  6700 003C                678              BEQ         NUM_1
00001654  B63C 0002                679              CMP.B       #2,D3
00001658  6700 003A                680              BEQ         NUM_2
0000165C  B63C 0003                681              CMP.B       #3,D3
00001660  6700 0038                682              BEQ         NUM_3
00001664  B63C 0004                683              CMP.B       #4,D3
00001668  6700 0036                684              BEQ         NUM_4
0000166C  B63C 0005                685              CMP.B       #5,D3
00001670  6700 0034                686              BEQ         NUM_5
00001674  B63C 0006                687              CMP.B       #6,D3
00001678  6700 0032                688              BEQ         NUM_6
0000167C  B63C 0007                689              CMP.B       #7,D3
00001680  6700 0030                690              BEQ         NUM_7
00001684  4EF8 10DA                691              JMP         INVALID     *Got here? Must be bad data.
00001688                           692              
00001688  18FC 0030                693  NUM_0       MOVE.B      #'0',(A4)+
0000168C  4E75                     694              RTS              
0000168E  18FC 0031                695  NUM_1       MOVE.B      #'1',(A4)+
00001692  4E75                     696              RTS
00001694  18FC 0032                697  NUM_2       MOVE.B      #'2',(A4)+
00001698  4E75                     698              RTS
0000169A  18FC 0033                699  NUM_3       MOVE.B      #'3',(A4)+
0000169E  4E75                     700              RTS
000016A0  18FC 0034                701  NUM_4       MOVE.B      #'4',(A4)+
000016A4  4E75                     702              RTS
000016A6  18FC 0035                703  NUM_5       MOVE.B      #'5',(A4)+
000016AA  4E75                     704              RTS
000016AC  18FC 0036                705  NUM_6       MOVE.B      #'6',(A4)+
000016B0  4E75                     706              RTS
000016B2  18FC 0037                707  NUM_7       MOVE.B      #'7',(A4)+
000016B6  4E75                     708              RTS
000016B8                           709  
000016B8  B63C 0000                710  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
000016BC  6700 0016                711              BEQ         ABW
000016C0  B63C 0001                712              CMP.B       #1,D3
000016C4  6700 0018                713              BEQ         ABL
000016C8  B63C 0004                714              CMP.B       #4,D3
000016CC  6700 001A                715              BEQ         IDATA
000016D0  4EF8 10DA                716              JMP         INVALID     *Got here? Must be bad data.
000016D4                           717              
000016D4  18FC 0024                718  ABW         MOVE.B      #'$',(A4)+
000016D8  4284                     719              CLR.L       D4          *Make sure D4 is clear
000016DA  381D                     720              MOVE.W      (A5)+, D4   *Increment counter by WORD (grab word data)
000016DC                           721              *Need to implement D4 -> ASCII -> GOOD string (or modify HEX_ASCII_G
000016DC  4E75                     722              RTS
000016DE                           723  
000016DE  18FC 0024                724  ABL         MOVE.B      #'$',(A4)+
000016E2  4284                     725              CLR.L       D4          *Make sure D4 is clear
000016E4  281D                     726              MOVE.L      (A5)+, D4   *Increment counter by WORD (grab word data)
000016E6                           727              *Need to implement D4 -> ASCII -> GOOD string (or modify HEX_ASCII_G 
000016E6  4E75                     728              RTS
000016E8                           729              
000016E8  18FC 0023                730  IDATA       MOVE.B      #'#',(A4)+
000016EC  4284                     731              CLR.L       D4          *Make sure D4 is clear
000016EE  381D                     732              MOVE.W      (A5)+, D4   *Increment counter by WORD (grab word data)
000016F0                           733              *Need to implement D4 -> ASCII -> GOOD string (or modify HEX_ASCII_G
000016F0                           734              *Need to implement
000016F0  4E75                     735              RTS
000016F2                           736  
000016F2                           737  
000016F2                           738  
000016F2                           739  
000016F2                           740  
000016F2                           741  
000016F2                           742  
000016F2                           743  
000016F2                           744  -------------------- end include --------------------
000016F2                           745  
000016F2  =0000000D                746  CR          EQU         $0D
000016F2  =0000000A                747  LF          EQU         $0A
000016F2                           748  
000016F2= 2D 2D 2D 2D 2D 2D ...    749  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
0000171C= 48 65 6E 72 79 20 ...    750              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00001745= 43 53 53 20 34 32 ...    751              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
0000176E= 2D 2D 2D 2D 2D 2D ...    752              DC.B        '----------------------------------------',CR,LF,0
00001799                           753              
00001799= 45 6E 74 65 72 20 ...    754  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
000017BC= 45 6E 74 65 72 20 ...    755  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000017DD= 50 72 65 73 73 20 ...    756  NXT_PG      DC.B        'Press enter key to contiune reading',CR,LF,0
00001803                           757  
00001803                           758  STA_ADDR    DS.B        40
0000182B                           759  END_ADDR    DS.B        40
00001853                           760  
00001854= 00000001                 761  GOOD_STR    DC.L        1
00001858                           762  
00001858= 00000050                 763  SPACER1     DC.L        80
0000185C= 00000050                 764  SPACER2     DC.L        80
00001860= 00000050                 765  SPACER3     DC.L        80
00001864= 00000050                 766  SPACER4     DC.L        80
00001868= 00000050                 767  SPACER5     DC.L        80
0000186C= 00000050                 768  SPACER6     DC.L        80
00001870= 00000050                 769  SPACER7     DC.L        80
00001874= 00000050                 770  SPACER8     DC.L        80
00001878= 00000050                 771  SPACER9     DC.L        80
0000187C= 00000050                 772  SPACERA     DC.L        80
00001880= 00000050                 773  SPACERB     DC.L        80
00001884= 00000050                 774  SPACERC     DC.L        80
00001888= 00000050                 775  SPACERD     DC.L        80
0000188C= 00000050                 776  SPACERE     DC.L        80
00001890= 00000064                 777  SPACERF     DC.L        100
00001894                           778  
00001894                           779  
00001894= 00000001                 780  BAD_STR     DC.L        1
00001898                           781  
00001898= 00000050                 782  SPACER11    DC.L        80
0000189C= 00000050                 783  SPACER22    DC.L        80
000018A0= 00000050                 784  SPACER33    DC.L        80
000018A4= 00000050                 785  SPACER44    DC.L        80
000018A8= 00000050                 786  SPACER55    DC.L        80
000018AC= 00000050                 787  SPACER66    DC.L        80
000018B0= 00000050                 788  SPACER77    DC.L        80
000018B4= 00000050                 789  SPACER88    DC.L        80
000018B8= 00000050                 790  SPACER99    DC.L        80
000018BC= 00000050                 791  SPACERAA    DC.L        80
000018C0= 00000050                 792  SPACERBB    DC.L        80
000018C4= 00000050                 793  SPACERCC    DC.L        80
000018C8= 00000050                 794  SPACERDD    DC.L        80
000018CC= 00000050                 795  SPACEREE    DC.L        80
000018D0= 00000064                 796  SPACERFF    DC.L        100
000018D4                           797  
000018D4                           798              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 16DE
ABS_ADDR            163C
ABS_TBL             16B8
ABW                 16D4
ADD_CHAR_B          11D6
ADD_CHAR_G          121E
ADD_SIZE            1496
AH_DONE             1092
ARD                 15EE
ARI                 15FA
ARI_DEC             1626
ARI_INC             160E
ASCII_HEX           107A
BAD_STR             1894
B_DN                1506
B_EA                14CA
CONTINUE            10E4
CR                  D
DECODE_LOOP         10B6
DN_CODE             1598
DN_SRC              1558
DONE                125C
DRD                 15E2
EA_SRC              1542
EA_TBL              15AE
END_ADDR            182B
END_MSG             17BC
END_OPT             1256
FORMAT              10A8
GEN_EA_CODE         1574
GET_INPUT           1020
GET_SIZE_1          1480
GET_SIZE_2          1470
GET_SIZE_3          1460
GOOD_STR            1854
HEX_ASCII_B         119C
HEX_ASCII_G         11E2
IDATA               16E8
INIT_BAD            1164
INIT_GOOD           112C
INIT_STRS           111E
INTRO               1012
INVALID             10DA
ISO_DIG_B           11AE
ISO_DIG_G           11F6
JMP_0               126E
JMP_0X              138A
JMP_1               127E
JMP_2               128E
JMP_2X              13B4
JMP_3               129E
JMP_3X              13C0
JMP_4               12AE
JMP_4X              13C4
JMP_5               12BE
JMP_6               12CE
JMP_6X              13C8
JMP_7               12DE
JMP_8               12EE
JMP_8X              13CC
JMP_9               12FE
JMP_A               130E
JMP_B               131C
JMP_C               132A
JMP_CX              13D0
JMP_D               133A
JMP_DX              13D4
JMP_E               134A
JMP_EX              13D8
JMP_TBL             1262
J_ADDI              13AC
J_CLR3              136A
J_CLR4              135A
J_CLR_DM            137A
J_MOVEAL            13E8
J_MOVEL             13E4
J_SUBI              13A4
LET                 109E
LET_B               11CE
LET_G               1216
LF                  A
L_DN                152E
L_EA                14F2
MM_EA_SRC           1570
MM_LS_SRC           1572
MM_OP_ORD           156E
MOV_EA_CODE         1596
NEXT_PAGE           10F8
NL_INTRO            16F2
NUM                 1094
NUM_0               1688
NUM_1               168E
NUM_2               1694
NUM_3               169A
NUM_4               16A0
NUM_5               16A6
NUM_6               16AC
NUM_7               16B2
NUM_B               11C6
NUM_G               120E
NXT_PG              17DD
OPC_04XX            13DC
OPC_05XX            13E0
OPC_1XXX            13EC
OPC_5XXX            140E
OPC_7XXX            1424
OPC_9XXX            1442
PRINT_B             1240
PRINT_G             122A
PRINT_GOOD          10D0
PROC_END            106E
PROC_STA            1062
REG_TBL             1644
SPACER1             1858
SPACER11            1898
SPACER2             185C
SPACER22            189C
SPACER3             1860
SPACER33            18A0
SPACER4             1864
SPACER44            18A4
SPACER5             1868
SPACER55            18A8
SPACER6             186C
SPACER66            18AC
SPACER7             1870
SPACER77            18B0
SPACER8             1874
SPACER88            18B4
SPACER9             1878
SPACER99            18B8
SPACERA             187C
SPACERAA            18BC
SPACERB             1880
SPACERBB            18C0
SPACERC             1884
SPACERCC            18C4
SPACERD             1888
SPACERDD            18C8
SPACERE             188C
SPACEREE            18CC
SPACERF             1890
SPACERFF            18D0
START               1000
STA_ADDR            1803
STA_MSG             1799
W_DN                151A
W_EA                14DE
