00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/1/2017 8:09:21 AM

00000000                             1  ************************************************************
00000000                             2  * Title      : Never Lucky Disassembler
00000000                             3  * Written by : Henry Hong, Ryan Palm, Joshua Plantilla
00000000                             4  * Date       : April 23, 2017
00000000                             5  * Description: Final Project for CSS 422. This program
00000000                             6  *              translates machine code into assembly (68k)
00000000                             7  *              language.
00000000                             8  ************************************************************
00000000                             9  
00001000                            10  START       ORG         $1000       *Start program
00001000  4EB9 00001012             11              JSR         INTRO       *Display Intro Message
00001006  4EB9 00001020             12              JSR         GET_INPUT   *Prompt user for input, convert input from ascii to hex and assign to sta_addr and end_addr
0000100C  4EB9 000010C2             13              JSR         DECODE_LOOP *Enters maine decode loop
00001012                            14              
00001012                            15                 
00001012                            16  *-----------------------INTRO-------------------------------
00001012  43F9 00002330             17  INTRO       LEA         NL_INTRO,A1 *Load INTRO1 message into A1
00001018  103C 000E                 18              MOVE.B      #14,D0      *Trap task 14, display intro
0000101C  4E4F                      19              TRAP        #15         
0000101E  4E75                      20              RTS         
00001020                            21  
00001020                            22  *--------------------GET_INPUT------------------------------
00001020  43F9 000023D7             23  GET_INPUT   LEA         IN_WARN,A1 *Load INTRO1 message into A1
00001026  103C 000E                 24              MOVE.B      #14,D0      *Trap task 14, display intro
0000102A  4E4F                      25              TRAP        #15 
0000102C                            26  
0000102C  43F9 0000269E             27              LEA         STA_MSG,A1  *Load STA_MSG into A1
00001032  103C 000E                 28              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001036  4E4F                      29              TRAP        #15         
00001038                            30              
00001038  43F9 00002753             31              LEA         STA_ADDR,A1 *Store input in STA_ADDR variable
0000103E  103C 0002                 32              MOVE.B      #2,D0       *Trap task 2, collect start address from input, length in D1
00001042  4E4F                      33              TRAP        #15         
00001044                            34              
00001044  4EB9 0000106E             35              JSR         PROC_STA    *Process Start address, check for errrors and convert to HEX
0000104A  4281                      36              CLR.L       D1          *Clear input length from D1
0000104C                            37              
0000104C  43F9 000026C1             38              LEA         END_MSG,A1  *Load END_MSG into A1
00001052  103C 000E                 39              MOVE.B      #14,D0      *Trap task 14, display end address msg
00001056  4E4F                      40              TRAP        #15
00001058                            41              
00001058  43F9 0000277B             42              LEA         END_ADDR,A1 *Store input in END_ADDR variable
0000105E  103C 0002                 43              MOVE.B      #2,D0       *Trap task 2, collect end address from input, length in d1
00001062  4E4F                      44              TRAP        #15         
00001064                            45              
00001064  4EB9 0000107A             46              JSR         PROC_END    *Process End Address, check for errors and convert to HEX
0000106A  4281                      47              CLR.L       D1          *Clear input length from D1
0000106C                            48              
0000106C  4E75                      49              RTS
0000106E                            50              
0000106E                            51  *--------------------PROC_STA-------------------------------
0000106E                            52  PROC_STA    *TODO: Check for Null, bad length, ODD address, range, convert to hex
0000106E  4EB9 00001086             53              JSR         ASCII_HEX   *Convert input into Hex
00001074                            54              
00001074                            55              *assuming all error checking is done before the next instruction (not yet implemented)
00001074                            56              
00001074  2A43                      57              MOVEA.L     D3,A5       *Move hex to STA_ADDR
00001076  4283                      58              CLR.L       D3          *Clear D3
00001078  4E75                      59              RTS                     
0000107A                            60  
0000107A                            61  *--------------------PROC_END-------------------------------
0000107A                            62  PROC_END    *TODO: Check for Null, bad length, odd address, range, convert to hex
0000107A                            63              *      does not fall before start
0000107A  4EB9 00001086             64              JSR         ASCII_HEX   *Convert input into Hex
00001080                            65              
00001080                            66              *assuming all error checking is done before the next instruction (not yet implemented)
00001080                            67              
00001080  2C43                      68              MOVE.L      D3,A6       *Move hex to END_ADDR
00001082  4283                      69              CLR.L       D3          *Clear D3
00001084  4E75                      70              RTS
00001086                            71  
00001086                            72  *-------------------ASCII_HEX-------------------------------
00001086  0C01 0000                 73  ASCII_HEX   CMPI.B      #$0,D1      *See if all characters are converted
0000108A  6700 0012                 74              BEQ         AH_DONE     *End subroutine if all converted
0000108E  1419                      75              MOVE.B      (A1)+,D2    *Move first ASCII hex value into D2
00001090  183C 0039                 76              MOVE.B      #$39,D4     *Number to compare input to to select num or letter 
00001094  B404                      77              CMP.B       D4,D2       *Check if ascii code is for a number or letter
00001096  6F00 0008                 78              BLE         NUM         *Codes less than $39 imply a number, so branch
0000109A  6000 000E                 79              BRA         LET         *If not a number, must be a letter.            
0000109E  4E75                      80  AH_DONE     RTS
000010A0                            81  
000010A0  183C 0030                 82  NUM         MOVE.B      #$30,D4     *move $30 into D4 (ammount to sub from value if number)
000010A4  9404                      83              SUB.B       D4,D2       *convert to hexadecimal number
000010A6  6000 000C                 84              BRA         FORMAT      *branch to subroutine to store converted hex number
000010AA                            85              
000010AA  183C 0037                 86  LET         MOVE.B      #$37,D4     *move $37 into D4 (ammount to sub from value if letter)
000010AE  9404                      87              SUB.B       D4,D2       *convert to hexadecimal letter
000010B0  6000 0002                 88              BRA         FORMAT      *branch to subroutine to store converted hex letter
000010B4                            89  
000010B4  5301                      90  FORMAT      SUBI.B      #$1,D1      *Decrement D2 counter, one character has been converted
000010B6  D602                      91              ADD.B       D2,D3       *Store converted number in D3
000010B8  0C01 0000                 92              CMPI.B      #$0,D1      *Check if we're all done converting
000010BC  67C8                      93              BEQ         ASCII_HEX   *If not continue conversion
000010BE  E983                      94              ASL.L       #4,D3       *Shift bits to the left to correct position
000010C0  60C4                      95              BRA         ASCII_HEX   *Branch back to label
000010C2                            96              
000010C2                            97  *-------------------DECODE_LOOP-----------------------------
000010C2  3E1D                      98  DECODE_LOOP MOVE.W      (A5)+,D7    *Move the instruction into D7        
000010C4  47F9 000027A4             99              LEA         BAD_STR,A3  *Move Bad string constant into A3
000010CA  49F9 000027E4            100              LEA         GOOD_STR,A4 *Move Good string constant into A4
000010D0                           101              
000010D0  4EB9 00001140            102              JSR         INIT_STRS   *Initialize Bad and Good Str
000010D6                           103              
000010D6  4EB9 00001310            104              JSR         JMP_TBL     *Start opcode identification waterfall
000010DC                           105              
000010DC  4EB9 0000112A            106              JSR         CLEAN_GS    *end of output string.
000010E2                           107              
000010E2  4EB9 0000126A            108  PRINT_GOOD  JSR         PRINT_G     *Jump to Print good string
000010E8  6000 000C                109              BRA         CONTINUE    *Continue the loop
000010EC  4EB9 00001280            110  INVALID     JSR         PRINT_B     *Jump to Pring bad string
000010F2  6000 0002                111              BRA         CONTINUE    *Continue the loop            
000010F6                           112              
000010F6  220D                     113  CONTINUE    MOVE.L      A5,D1
000010F8  240E                     114              MOVE.L      A6,D2
000010FA  B481                     115              CMP.L       D1,D2
000010FC  6F00 01E8                116              BLE         END_OPT     *if we're done, move to end options (ask user what to do)
00001100                           117              
00001100                           118                          
00001100  5205                     119              ADDQ.B      #1,D5       *Increment line counter
00001102  BA3C 001D                120              CMP.B       #29,D5      *See if page is full
00001106  6700 0004                121              BEQ         NEXT_PAGE   *Jump to next page prompt
0000110A                           122              
0000110A  60B6                     123              BRA         DECODE_LOOP * Continue loop
0000110C                           124  
0000110C                           125  *-------------------NEXT_PAGE-----------------------------
0000110C  43F9 000026E2            126  NEXT_PAGE   LEA         NXT_PG,A1   *Load STA_MSG into A1
00001112  4280                     127              CLR.L       D0          *Make sure D0 is empty
00001114  103C 000E                128              MOVE.B      #14,D0      *Trap task 14, display start address msg
00001118  4E4F                     129              TRAP        #15            
0000111A                           130              
0000111A  103C 0005                131              MOVE.B      #5,D0       *Single char trap task
0000111E  4E4F                     132              TRAP        #15         
00001120                           133              
00001120  B23C 000D                134              CMP.B       #$D,D1      *Check if ENTER key was pressed
00001124  66E6                     135              BNE         NEXT_PAGE   *Force user to hit enter, or prompt again
00001126                           136              
00001126  4285                     137              CLR.L       D5          *Reset page counter
00001128                           138              
00001128  6098                     139              BRA         DECODE_LOOP *Continue the loop
0000112A                           140              
0000112A                           141  *-------------------GS_CLEAN--------------------------------
0000112A                           142  * This subroutine "cleans" the end of the good string.
0000112A                           143  * Prevents the previous string from showing content in the
0000112A                           144  * current string.
0000112A                           145  *-----------------------------------------------------------
0000112A  4280                     146  CLEAN_GS    CLR.L       D0
0000112C  103C 000F                147              MOVE.B      #15,D0      *Max 15 chars to clean
00001130                           148  
00001130  0C00 0000                149  GS_LOOP     CMPI.B      #0,D0       *Add spaces to the end of string to push out old chars
00001134  6700 0008                150              BEQ         D_CLEAN
00001138  421C                     151              CLR.B       (A4)+
0000113A  5300                     152              SUBI.B      #$1,D0
0000113C  60F2                     153              BRA         GS_LOOP
0000113E  4E75                     154  D_CLEAN     RTS
00001140                           155              
00001140                           156  *-------------------INIT_STRS-----------------------------
00001140  4EB9 0000114E            157  INIT_STRS   JSR         INIT_GOOD   *Initialize the good string
00001146  4EB9 00001162            158              JSR         INIT_BAD    *Initialize the bad string
0000114C  4E75                     159              RTS
0000114E                           160              
0000114E                           161  *-------------------INIT_GOOD-----------------------------
0000114E  18FC 0024                162  INIT_GOOD   MOVE.B      #'$',(A4)+ 
00001152  4EB9 00001194            163              JSR         H2A_G_ADDR *Now convert address to ASCII
00001158                           164              
00001158  18FC 0020                165              MOVE.B      #' ',(A4)+  *Add spaces after addr
0000115C  18FC 0020                166              MOVE.B      #' ',(A4)+
00001160                           167              
00001160  4E75                     168              RTS
00001162                           169  
00001162                           170  *-------------------INIT_BAD------------------------------            
00001162  16FC 0024                171  INIT_BAD    MOVE.B      #'$',(A3)+
00001166  4EB9 000011DC            172              JSR         H2A_B_ADDR  *Add the address to the bad string
0000116C  16FC 0020                173              MOVE.B      #' ',(A3)+    
00001170  16FC 0020                174              MOVE.B      #' ',(A3)+
00001174                           175              
00001174  16FC 0044                176              MOVE.B      #'D',(A3)+  
00001178  16FC 0041                177              MOVE.B      #'A',(A3)+ 
0000117C  16FC 0054                178              MOVE.B      #'T',(A3)+    
00001180  16FC 0041                179              MOVE.B      #'A',(A3)+ 
00001184                           180              
00001184  16FC 0020                181              MOVE.B      #' ',(A3)+  *Add spaces after bad code added
00001188  16FC 0020                182              MOVE.B      #' ',(A3)+
0000118C  4EB9 00001224            183              JSR         H2A_B_OP    *Add the opcode to the bad string
00001192                           184              
00001192  4E75                     185              RTS
00001194                           186              
00001194                           187  *-------------------H2A_G_ADDR-------------------------------            
00001194  4280                     188  H2A_G_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
00001196  4281                     189              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001198  4282                     190              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000119A  4283                     191              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000119C  220D                     192              MOVE.L      A5,D1       *Copy address into D1
0000119E  5581                     193              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011A0  103C 0008                194              MOVE.B      #$8,D0      *Counter
000011A4  6000 0002                195              BRA         ISO_DIG_G   *Begin isolating chars
000011A8                           196              
000011A8  E999                     197  ISO_DIG_G   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011AA                           198              
000011AA  2401                     199              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011AC                           200              
000011AC  163C 001C                201              MOVE.B      #28,D3      *Shift left 28 times
000011B0  E7AA                     202              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011B2  E99A                     203              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011B4                           204              
000011B4  0C02 0009                205              CMPI.B      #$9,D2      *Is it a number?
000011B8  6F00 0006                206              BLE         NUM_G       *If it is, process number
000011BC  6000 000A                207              BRA         LET_G       *If not, process letter
000011C0                           208              
000011C0  0602 0030                209  NUM_G       ADDI.B      #$30,D2     *Make it an ascii number
000011C4  6000 000A                210              BRA         ADD_CHAR_G  *add to strings and continue
000011C8                           211              
000011C8  0602 0037                212  LET_G       ADDI.B      #$37,D2     *Make it an ascii letter
000011CC  6000 0002                213              BRA         ADD_CHAR_G  *add to strings and continue
000011D0                           214  
000011D0  18C2                     215  ADD_CHAR_G  MOVE.B      D2,(A4)+    *Add to the good data string
000011D2  5300                     216              SUBI.B      #$1,D0      *decrement counter
000011D4  0C00 0000                217              CMPI.B      #$0,D0      *Check if we're done            
000011D8  6ECE                     218              BGT         ISO_DIG_G   *If not, continue tranlation   
000011DA                           219              
000011DA  4E75                     220              RTS
000011DC                           221              
000011DC                           222  *-------------------H2A_B_ADDR-------------------------------            
000011DC  4280                     223  H2A_B_ADDR  CLR.L       D0          *Make sure D0 is empty (Counter)
000011DE  4281                     224              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
000011E0  4282                     225              CLR.L       D2          *Make sure D2 is empty (each individual char)
000011E2  4283                     226              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000011E4  220D                     227              MOVE.L      A5,D1       *Copy address into D1
000011E6  5581                     228              SUBI.L      #2,D1       *Move addres back one byte (for post increment)
000011E8  103C 0008                229              MOVE.B      #$8,D0      *Counter
000011EC  6000 0002                230              BRA         ISO_DIG_B   *Begin isolating chars
000011F0                           231              
000011F0  E999                     232  ISO_DIG_B   ROL.L       #4,D1       *Move first significant hex char to least sig position
000011F2                           233              
000011F2  2401                     234              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
000011F4                           235              
000011F4  163C 001C                236              MOVE.B      #28,D3      *Shift left 28 times
000011F8  E7AA                     237              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
000011FA  E99A                     238              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
000011FC                           239              
000011FC  0C02 0009                240              CMPI.B      #$9,D2      *Is it a number?
00001200  6F00 0006                241              BLE         NUM_B       *If it is, process number
00001204  6000 000A                242              BRA         LET_B       *If not, process letter
00001208                           243              
00001208  0602 0030                244  NUM_B       ADDI.B      #$30,D2     *Make it an ascii number
0000120C  6000 000A                245              BRA         ADD_CHAR_B  *add to strings and continue
00001210                           246              
00001210  0602 0037                247  LET_B       ADDI.B      #$37,D2     *Make it an ascii letter
00001214  6000 0002                248              BRA         ADD_CHAR_B  *add to strings and continue
00001218                           249  
00001218  16C2                     250  ADD_CHAR_B  MOVE.B      D2,(A3)+    *Add to the good data string
0000121A  5300                     251              SUBI.B      #$1,D0      *decrement counter
0000121C  0C00 0000                252              CMPI.B      #$0,D0      *Check if we're done            
00001220  6ECE                     253              BGT         ISO_DIG_B    *If not, continue tranlation   
00001222                           254              
00001222  4E75                     255              RTS
00001224                           256              
00001224                           257  *-------------------H2A_B_OP--------------------------------
00001224  4280                     258  H2A_B_OP    CLR.L       D0          *Make sure D0 is empty (Counter)
00001226  4281                     259              CLR.L       D1          *Make sure D1 is empty (For shifting/Rotations)
00001228  4282                     260              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000122A  4283                     261              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
0000122C  3207                     262              MOVE.W      D7,D1       *Copy opcode into D0 for working with
0000122E  103C 0004                263              MOVE.B      #$4,D0      *Counter
00001232  6000 0002                264              BRA         ISODIG_BO   *Begin isolating chars
00001236                           265              
00001236  E959                     266  ISODIG_BO   ROL.W       #4,D1       *Move first significant hex char to least sig position
00001238                           267              
00001238  2401                     268              MOVE.L      D1,D2       *Move to D2 to isolate least sig hex char
0000123A                           269              
0000123A  163C 001C                270              MOVE.B      #28,D3      *Shift left 28 times
0000123E  E7AA                     271              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00001240  E99A                     272              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00001242                           273              
00001242  0C02 0009                274              CMPI.B      #$9,D2      *Is it a number?
00001246  6F00 0006                275              BLE         NUM_BO      *If it is, process number
0000124A  6000 000A                276              BRA         LET_BO      *If not, process letter
0000124E                           277  
0000124E  0602 0030                278  NUM_BO      ADDI.B      #$30,D2     *Make it an ascii number
00001252  6000 000A                279              BRA         ADD_CHAR_BO *add to strings and continue
00001256                           280              
00001256  0602 0037                281  LET_BO      ADDI.B      #$37,D2     *Make it an ascii letter
0000125A  6000 0002                282              BRA         ADD_CHAR_BO *add to strings and continue
0000125E                           283              
0000125E  16C2                     284  ADD_CHAR_BO MOVE.B      D2,(A3)+    *Add to bad data string
00001260  5300                     285              SUBI.B      #$1,D0      *decrement counter
00001262  0C00 0000                286              CMPI.B      #$0,D0      *Check if we're done            
00001266  6ECE                     287              BGT         ISODIG_BO  *If not, continue tranlation   
00001268                           288              
00001268  4E75                     289              RTS
0000126A                           290              
0000126A                           291  *-------------------PRINT_G---------------------------------
0000126A  18FC 0020                292  PRINT_G     MOVE.B      #' ',(A4)+
0000126E  16FC 0000                293              MOVE.B      #$00,(A3)+  *Move null to end of string for printing
00001272  43F9 000027E4            294              LEA         GOOD_STR,A1 *Load good data for printing
00001278  103C 000D                295              MOVE.B      #13,D0      *Trap task 13, display null terminated string
0000127C  4E4F                     296              TRAP        #15         *Display string
0000127E                           297            
0000127E  4E75                     298              RTS 
00001280                           299  
00001280                           300  *-------------------PRINT_B---------------------------------
00001280  18FC 0020                301  PRINT_B     MOVE.B      #' ',(A4)+
00001284  18FC 0000                302              MOVE.B      #$00,(A4)+  *Move null to end of string for printing
00001288  43F9 000027A4            303              LEA         BAD_STR,A1  *Load good data for printing
0000128E  103C 000D                304              MOVE.B      #13,D0      *Trap task 13, display null terminated string
00001292  4E4F                     305              TRAP        #15         *Display string
00001294                           306              
00001294  4E75                     307              RTS 
00001296                           308              
00001296                           309  *-------------------PRG_RESET-------------------------------
00001296  2E7C 01000000            310  PRG_RESET   MOVEA.L     #$01000000,A7   *Reset the stack pointer
0000129C                           311              
0000129C  207C 00000000            312              MOVEA.L     #$00000000,A0   *Clear Address Registers
000012A2  227C 00000000            313              MOVEA.L     #$00000000,A1
000012A8  247C 00000000            314              MOVEA.L     #$00000000,A2
000012AE  267C 00000000            315              MOVEA.L     #$00000000,A3
000012B4  287C 00000000            316              MOVEA.L     #$00000000,A4
000012BA  2A7C 00000000            317              MOVEA.L     #$00000000,A5
000012C0  2C7C 00000000            318              MOVEA.L     #$00000000,A6
000012C6                           319              
000012C6  4280                     320              CLR.L       D0              *Reset Data registers
000012C8  4281                     321              CLR.L       D1
000012CA  4282                     322              CLR.L       D2
000012CC  4283                     323              CLR.L       D3
000012CE  4284                     324              CLR.L       D4
000012D0  4285                     325              CLR.L       D5
000012D2  4286                     326              CLR.L       D6
000012D4  4287                     327              CLR.L       D7
000012D6                           328  
000012D6  103C 000B                329              MOVE.B      #11,D0          *Clear Screen
000012DA  323C FF00                330              MOVE.W      #$FF00,D1
000012DE  4E4F                     331              TRAP        #15
000012E0                           332              
000012E0  4281                     333              CLR.L       D1
000012E2                           334              
000012E2  4EF8 1000                335              JMP         START           *Restart the program
000012E6                           336  
000012E6                           337  *-------------------END_OPT---------------------------------
000012E6  43F9 0000270B            338  END_OPT     LEA         END_PGR,A1  *Display Ending messages
000012EC  4280                     339              CLR.L       D0          
000012EE  103C 000E                340              MOVE.B      #14,D0      
000012F2  4E4F                     341              TRAP        #15             
000012F4                           342              
000012F4  103C 0005                343              MOVE.B      #5,D0       *Single char trap task
000012F8  4E4F                     344              TRAP        #15         
000012FA                           345              
000012FA  B23C 0020                346              CMP.B       #$20,D1     *Check if SPACE key was pressed
000012FE  6796                     347              BEQ         PRG_RESET   *Decode another memory image if enter is pressed
00001300                           348              
00001300  B23C 001B                349              CMP.B       #$1B,D1     *Check if ESC key was pressed
00001304  6700 0004                350              BEQ         DONE        *End program
00001308                           351              
00001308  60DC                     352              BRA         END_OPT     *Else, loop (force space or esc)
0000130A                           353              
0000130A                           354  *-----------------------DONE--------------------------------
0000130A  103C 0009                355  DONE        MOVE.B      #9,D0       *Load 9 into D0 (trap task)
0000130E  4E4F                     356              TRAP        #15         *Halt program, Trap#15 task 9
00001310                           357   
00001310                           358             
00001310                           359  *---------------Variables and Constants---------------------
00001310                           360              INCLUDE     'Never_Lucky_Jump_Tables.x68'   *Include jump tables file
00001310                           361  
00001310                           362  
00001310                           363  
00001310  4282                     364  JMP_TBL     CLR.L       D2
00001312  3407                     365              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001314  4281                     366              CLR.L       D1
00001316  123C 000C                367              MOVE.B      #12,D1      *Moves 12 into D1
0000131A  E26A                     368              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000131C                           369                          
0000131C  B43C 0000                370  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00001320  6600 000A                371              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00001324  4EB9 00001490            372              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000132A  4E75                     373              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000132C                           374              
0000132C  B43C 0001                375  JMP_1       CMP.B       #$1,D2
00001330  6600 000A                376              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00001334  4EB9 00001748            377              JSR         OPC_MOVEB   *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_MOVEB in OPCODE table.
0000133A  4E75                     378              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000133C                           379             
0000133C  B43C 0002                380  JMP_2       CMP.B       #$2,D2
00001340  6600 000A                381              BNE         JMP_3 
00001344  4EB9 000014BA            382              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000134A  4E75                     383              RTS
0000134C                           384              
0000134C  B43C 0003                385  JMP_3       CMP.B       #$3,D2
00001350  6600 000A                386              BNE         JMP_4
00001354  4EB9 000014DE            387              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
0000135A  4E75                     388              RTS
0000135C                           389           
0000135C  B43C 0004                390  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
00001360  6600 000A                391              BNE         JMP_5
00001364  4EB9 00001502            392              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
0000136A  4E75                     393              RTS
0000136C                           394              
0000136C  B43C 0005                395  JMP_5       CMP.B       #$5,D2
00001370  6600 000A                396              BNE         JMP_6
00001374  4EB9 0000176C            397              JSR         OPC_ADDQ    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_ADDQ in OPCODE table.
0000137A  4E75                     398              RTS
0000137C                           399              
0000137C  B43C 0006                400  JMP_6       CMP.B       #$6,D2
00001380  6600 000A                401              BNE         JMP_7
00001384  4EB9 00001548            402              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
0000138A  4E75                     403              RTS
0000138C                           404              
0000138C  B43C 0007                405  JMP_7       CMP.B       #$7,D2
00001390  6600 000A                406              BNE         JMP_8
00001394  4EB9 00001794            407              JSR         OPC_MOVEQ    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_MOVEQ in OPCODE table.
0000139A  4E75                     408              RTS
0000139C                           409              
0000139C  B43C 0008                410  JMP_8       CMP.B       #$8,D2
000013A0  6600 000A                411              BNE         JMP_9
000013A4  4EB9 0000156C            412              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
000013AA  4E75                     413              RTS
000013AC                           414              
000013AC  B43C 0009                415  JMP_9       CMP.B       #$9,D2
000013B0  6600 000A                416              BNE         JMP_A
000013B4  4EB9 000017B0            417              JSR         OPC_SUB    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000013BA  4E75                     418              RTS
000013BC                           419              
000013BC  B43C 000A                420  JMP_A       CMP.B       #$A,D2
000013C0  6600 0008                421              BNE         JMP_B
000013C4  4EB8 10EC                422              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
000013C8  4E75                     423              RTS
000013CA                           424              
000013CA  B43C 000B                425  JMP_B       CMP.B       #$B,D2
000013CE  6600 0008                426              BNE         JMP_C
000013D2  4EB8 10EC                427              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000013D6  4E75                     428              RTS
000013D8                           429              
000013D8  B43C 000C                430  JMP_C       CMP.B       #$C,D2
000013DC  6600 000A                431              BNE         JMP_D
000013E0  4EB9 00001590            432              JSR         JMP_CX
000013E6                           433        *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000013E6  4E75                     434              RTS
000013E8                           435              
000013E8  B43C 000D                436  JMP_D       CMP.B       #$D,D2
000013EC  6600 000A                437              BNE         JMP_E   
000013F0  4EB9 000015B4            438              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000013F6  4E75                     439              RTS
000013F8                           440              
000013F8  B43C 000F                441  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
000013FC  6700 000A                442              BEQ         INV_OP      *If first hex value is F, jump to INVALID
00001400  4EB9 00001618            443              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
00001406  4E75                     444              RTS
00001408                           445              
00001408  4EF8 10EC                446  INV_OP      JMP         INVALID     *Got here? Must be invalid.
0000140C  4E75                     447              RTS
0000140E                           448   
0000140E  4282                     449  J_CLR4      CLR.L       D2                                
00001410  3407                     450              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001412  4281                     451              CLR.L       D1
00001414  E94A                     452              LSL.W       #4,D2       *Clear the most sig hex digit
00001416  123C 000C                453              MOVE.B      #12,D1      *Moves 12 into D1
0000141A  E26A                     454              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
0000141C  4E75                     455              RTS                     *Return back to JMP_Xn    
0000141E                           456              
0000141E  4282                     457  J_CLR3      CLR.L       D2          
00001420  3407                     458              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001422  4281                     459              CLR.L       D1
00001424  E94A                     460              LSL.W       #4,D2       *Clear the most sig hex digit
00001426  123C 000D                461              MOVE.B      #13,D1      *Moves 13 into D1
0000142A  E26A                     462              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000142C  4E75                     463              RTS                     *Return back to JMP_Xn  
0000142E                           464  
0000142E  4282                     465  J_CLR2      CLR.L       D2          
00001430  3407                     466              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001432  4281                     467              CLR.L       D1
00001434  E14A                     468              LSL.W       #8,D2       *Clear the most sig 7 bits
00001436  123C 000E                469              MOVE.B      #14,D1      *Moves 16 into D1
0000143A  E26A                     470              LSR.W       D1,D2       *Shifts 16 right to isolate the bit we're working with 
0000143C  4E75                     471              RTS     
0000143E                           472  
0000143E  4282                     473  J_CLR1      CLR.L       D2          
00001440  3407                     474              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001442  4281                     475              CLR.L       D1
00001444  EF4A                     476              LSL.W       #7,D2       *Clear the most sig 7 bits
00001446  123C 000F                477              MOVE.B      #15,D1      *Moves 16 into D1
0000144A  E26A                     478              LSR.W       D1,D2       *Shifts 16 right to isolate the bit we're working with 
0000144C  4E75                     479              RTS                     *Return back to JMP_Xn
0000144E                           480          
0000144E  4282                     481  J_CLR_LEA   CLR.L       D2          
00001450  3407                     482              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001452  4281                     483              CLR.L       D1
00001454  EF4A                     484              LSL.W       #7,D2       *Clear the most sig 7 bits
00001456  123C 000D                485              MOVE.B      #13,D1      *Moves 13 into D1
0000145A  E26A                     486              LSR.W       D1,D2       *Shifts 13 right to isolate the bit we're working with 
0000145C  4E75                     487              RTS    
0000145E                           488              
0000145E  4282                     489  J_CLR_MM    CLR.L       D2          
00001460  3407                     490              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001462  4281                     491              CLR.L       D1   
00001464  123C 000B                492              MOVE.B      #11,D1      *Moves 11 into D1
00001468  E26A                     493              LSR.W       D1,D2       *Shifts 11 right to isolate the bit we're working with 
0000146A  4E75                     494              RTS  
0000146C                           495       
0000146C  4282                     496  J_CLR_DM    CLR.L       D2          
0000146E  3407                     497              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001470  4281                     498              CLR.L       D1
00001472  EF4A                     499              LSL.W       #7,D2       *Clear the most sig 7 bits
00001474  123C 000D                500              MOVE.B      #13,D1      *Moves 13 into D1
00001478  E26A                     501              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000147A  4E75                     502              RTS                     *Return back to JMP_Xn     
0000147C                           503  
0000147C  4282                     504  J_CLR_SHFT  CLR.L       D2
0000147E  3407                     505              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001480  4281                     506              CLR.L       D1
00001482  183C 000B                507              MOVE.B      #11,D4      *Moves 11 into D4
00001486  E96A                     508              LSL.W       D4,D2      *Clear the most sig 11 bits
00001488  123C 000E                509              MOVE.B      #14,D1      *Moves 14 into D1
0000148C  E26A                     510              LSR.W       D1,D2       *Shifts 14 right to isolate the bits we're working with 
0000148E  4E75                     511              RTS                     *Return back to JMP_Xn 
00001490                           512              
00001490                           513   
00001490                           514  
00001490                           515          
00001490  4EB8 140E                516  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
00001494  B43C 0004                517              CMP.B       #$4,D2      *Is the next hex digit 4?
00001498  6700 0010                518              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
0000149C  B43C 0006                519              CMP.B       #$6,D2      *Is the next hex digit 5?
000014A0  6700 0010                520              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
000014A4  4EB8 10EC                521              JSR         INVALID     *If neither, OPCODE is invalid
000014A8  4E75                     522              RTS
000014AA                           523  
000014AA  4EB9 000016F8            524  J_SUBI      JSR         OPC_SUBI    *Jump to OPC_SUBI in OPCODE table
000014B0  4E75                     525              RTS
000014B2                           526              
000014B2  4EB9 00001720            527  J_ADDI      JSR         OPC_ADDI    *Jump to OPC_ADDI in OPCODE table
000014B8  4E75                     528              RTS              
000014BA                           529  
000014BA                           530  
000014BA  4EB8 146C                531  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014BE  B43C 0001                532              CMP.B       #$1,D2      *is the DEST MODE 1?
000014C2  6700 000A                533              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
000014C6  4EB9 000014D6            534              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
000014CC  4E75                     535              RTS
000014CE                           536  
000014CE  4EB9 00001838            537  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
000014D4  4E75                     538              RTS
000014D6                           539  
000014D6  4EB9 00001864            540  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
000014DC  4E75                     541              RTS                           
000014DE                           542              
000014DE  4EB8 146C                543  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
000014E2  B43C 0001                544              CMP.B       #$1,D2      *is the DEST MODE 1?
000014E6  6700 000A                545              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
000014EA  4EB9 000014FA            546              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
000014F0  4E75                     547              RTS
000014F2                           548  
000014F2  4EB9 0000188C            549  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000014F8  4E75                     550              RTS
000014FA                           551  
000014FA  4EB9 000018B8            552  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
00001500  4E75                     553              RTS
00001502  4EB8 140E                554  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
00001506  B43C 000E                555              CMP.B       #$E,D2      *Is the next hex digit E?
0000150A  6700 0024                556              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
0000150E  4EB8 143E                557              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
00001512  4EB8 144E                558              JSR         J_CLR_LEA
00001516  B43C 0007                559              CMP.B       #7,D2       *Is the last bit 7?
0000151A  6700 001C                560              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
0000151E  4EB8 145E                561              JSR         J_CLR_MM
00001522  B43C 0009                562              CMP.B       #9,D2       *Is the last bit 0?
00001526  6700 0018                563              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
0000152A  4EB8 10EC                564              JSR         INVALID     *If none of the above, OPCODE is invalid
0000152E  4E75                     565              RTS                                         
00001530                           566              
00001530  4EB9 000016C0            567  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
00001536  4E75                     568              RTS
00001538                           569              
00001538  4EB9 000017CE            570  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
0000153E  4E75                     571              RTS
00001540                           572              
00001540  4EB9 000017F0            573  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
00001546  4E75                     574              RTS
00001548                           575              
00001548  4EB8 140E                576  JMP_6X      JSR         J_CLR4       *Isolate next hex digit 
0000154C  B43C 0000                577              CMP.B       #0,D2        *Is the next hex digit 0?
00001550  6700 000A                578              BEQ         J_BRA        *Instruction is determined to be BRA. Jump to intermediate OPCODE table jump
00001554  4EB9 00001564            579              JSR         J_Bcc        *Otherwise, Instruction is determined to be some form of Bcc. Jump to intermediate OPCODE table jump
0000155A  4E75                     580              RTS
0000155C                           581              
0000155C  4EB9 000018E0            582  J_BRA       JSR         OPC_BRA      *Jump to OPC_BRA in the OPCODE table  
00001562                           583  
00001562  4E75                     584              RTS
00001564                           585  
00001564  4EB9 000018FC            586  J_Bcc       JSR         OPC_Bcc      *Jump to OPC_Bcc in the OPCODE table  
0000156A                           587  
0000156A  4E75                     588              RTS
0000156C                           589              
0000156C  4EB8 146C                590  JMP_8X      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
00001570  B43C 0003                591              CMP.B       #3,D2       *Are the bits equivalent to $3?
00001574  6700 000A                592              BEQ         J_DIVU      *Instruction is determined to be DIVU. Jump to intermediate OPCODE table jump
00001578  4EB9 00001588            593              JSR         J_OR        *Otherwise, Instruction is determined to be OR. Jump to intermediate OPCODE table jump
0000157E  4E75                     594              RTS
00001580                           595  
00001580  4EB9 00001908            596  J_DIVU      JSR         OPC_DIVU    *Jump to OPC_DIVU in the OPCODE table  
00001586  4E75                     597              RTS
00001588                           598              
00001588  4EB9 0000192E            599  J_OR        JSR         OPC_OR      *Jump to OPC_OR in the OPCODE table  
0000158E  4E75                     600              RTS
00001590                           601  
00001590  4EB8 146C                602  JMP_CX      JSR         J_CLR_DM    *Isolate the OPMODE bits %0000 000X XX00 0000 0000
00001594  B43C 0007                603              CMP.B       #7,D2       *Are the bits equivalent to $7?
00001598  6700 000A                604              BEQ         J_MULS      *Instruction is determined to be MULS. Jump to intermediate OPCODE table jump
0000159C  4EB9 000015AC            605              JSR         J_AND       *Otherwise, Instruction is determined to be AND. Jump to intermediate OPCODE table jump
000015A2  4E75                     606              RTS
000015A4                           607  
000015A4  4EB9 00001948            608  J_MULS      JSR         OPC_MULS    *Jump to OPC_MULS in the OPCODE table  
000015AA  4E75                     609              RTS
000015AC                           610              
000015AC  4EB9 0000196E            611  J_AND       JSR         OPC_AND     *Jump to OPC_AND in the OPCODE table  
000015B2  4E75                     612              RTS
000015B4                           613  
000015B4  4EB8 146C                614  JMP_DX      JSR         J_CLR_DM    *Isolate OPMODE bits to determine if ADD or ADDA
000015B8  4284                     615              CLR.L       D4          *For adding size (easy to do it here).
000015BA  183C 0001                616              MOVE.B      #1,D4       *Set size to WORD
000015BE  B43C 0003                617              CMP.B       #3,D2       *Is it Word ADDA?
000015C2  6700 0044                618              BEQ         OP_ADDA
000015C6  183C 0002                619              MOVE.B      #2,D4       *set size to LONG
000015CA  B43C 0007                620              CMP.B       #7,D2       *is it Long ADDA?
000015CE  6700 0038                621              BEQ         OP_ADDA
000015D2                           622              
000015D2  4284                     623              CLR.L       D4          *Not ADDA? Clear the manual size sets
000015D4                           624              
000015D4  B83C 0000                625              CMP.B       #0,D4       Is it ADD?
000015D8  6700 0036                626              BEQ         OP_ADD
000015DC  B83C 0001                627              CMP.B       #1,D4       
000015E0  6700 002E                628              BEQ         OP_ADD
000015E4  B83C 0002                629              CMP.B       #2,D4       
000015E8  6700 0026                630              BEQ         OP_ADD
000015EC  B83C 0004                631              CMP.B       #4,D4 
000015F0  6700 001E                632              BEQ         OP_ADD
000015F4  B83C 0005                633              CMP.B       #5,D4     
000015F8  6700 0016                634              BEQ         OP_ADD
000015FC  B83C 0006                635              CMP.B       #6,D4     
00001600  6700 000E                636              BEQ         OP_ADD       
00001604                           637           
00001604  6000 FAE6                638              BRA         INVALID     *Got here, must be invalid data.    
00001608                           639              
00001608  4EB9 0000198C            640  OP_ADDA     JSR         OPC_ADDA
0000160E  4E75                     641              RTS
00001610                           642              
00001610  4EB9 000019AE            643  OP_ADD      JSR         OPC_ADD
00001616  4E75                     644              RTS
00001618                           645              
00001618                           646  
00001618  4EB8 142E                647  JMP_EX      JSR         J_CLR2
0000161C  B43C 0003                648              CMP.B       #3,D2       *Is it a memory variant?
00001620  6700 001E                649              BEQ         SR_MEM_VAR  
00001624  B43C 0000                650              CMP.B       #0,D2
00001628  6700 001E                651              BEQ         SR_REG_VAR  *Is it a reg variant
0000162C  B43C 0001                652              CMP.B       #1,D2
00001630  6700 0016                653              BEQ         SR_REG_VAR
00001634  B43C 0002                654              CMP.B       #2,D2
00001638  6700 000E                655              BEQ         SR_REG_VAR
0000163C  4EF8 10EC                656              JMP         INVALID     *Got here? Mus be invalid.
00001640                           657              
00001640  4EB9 00001650            658  SR_MEM_VAR  JSR         SRMEM_VAR
00001646  4E75                     659              RTS
00001648                           660  
00001648  4EB9 00001688            661  SR_REG_VAR  JSR         SRREG_VAR
0000164E  4E75                     662              RTS
00001650                           663              
00001650  4EB8 141E                664  SRMEM_VAR   JSR         J_CLR3      *Isolate unique hardcoded mem section
00001654  B43C 0000                665              CMP.B       #0,D2
00001658  6700 0016                666              BEQ         OP_AS_MEM  *Is it as AS?
0000165C  B43C 0001                667              CMP.B       #1,D2
00001660  6700 0016                668              BEQ         OP_LS_MEM  *Is it a LS
00001664  B43C 0003                669              CMP.B       #3,D2
00001668  6700 0016                670              BEQ         OP_RO_MEM  *Is it a RO
0000166C  6000 FA7E                671              BRA         INVALID     *Got here? Must be invalid
00001670                           672              
00001670  4EB9 00001A04            673  OP_AS_MEM   JSR         OPC_AS_MEM
00001676  4E75                     674              RTS
00001678                           675  
00001678  4EB9 00001A1E            676  OP_LS_MEM   JSR         OPC_LS_MEM
0000167E  4E75                     677              RTS
00001680                           678  
00001680  4EB9 00001A38            679  OP_RO_MEM   JSR         OPC_RO_MEM
00001686  4E75                     680              RTS
00001688                           681              
00001688  4EB8 147C                682  SRREG_VAR   JSR         J_CLR_SHFT *Isolate hardoced unique
0000168C  B43C 0000                683              CMP.B       #0,D2       *Is it a AS?
00001690  6700 0016                684              BEQ         OP_AS_REG
00001694  B43C 0001                685              CMP.B       #1,D2       *Is it a LS?
00001698  6700 0016                686              BEQ         OP_LS_REG
0000169C  B43C 0003                687              CMP.B       #3,D2       *is it a RO?
000016A0  6700 0016                688              BEQ         OP_RO_REG
000016A4  6000 FA46                689              BRA         INVALID     *Got here? Must be invalid.
000016A8                           690  
000016A8  4EB9 00001A52            691  OP_AS_REG   JSR         OPC_AS_REG
000016AE  4E75                     692              RTS   
000016B0                           693  
000016B0  4EB9 00001A78            694  OP_LS_REG   JSR         OPC_LS_REG
000016B6  4E75                     695              RTS
000016B8                           696  
000016B8  4EB9 00001A9E            697  OP_RO_REG   JSR         OPC_RO_REG
000016BE  4E75                     698              RTS
000016C0                           699  
000016C0                           700     
000016C0  BE7C 4E71                701  JMP_47X     CMP.W       #$4E71,D7    *Is it NOP?
000016C4  6700 001A                702              BEQ         O_NOP
000016C8  BE7C 4E75                703              CMP.W       #$4E75,D7       *Is it RTS?
000016CC  6700 001A                704              BEQ         O_RTS
000016D0  4EB8 142E                705              JSR         J_CLR2       *Isolate the 6th and 7th bit
000016D4  B43C 0002                706              CMP.B       #2,D2        *Is it JSR?
000016D8  6700 0016                707              BEQ         O_JSR
000016DC  4EF8 10EC                708              JMP         INVALID      *Got here? Must be invalid data.
000016E0                           709  
000016E0  4EB9 000019E8            710  O_NOP       JSR         OPC_NOP
000016E6  4E75                     711              RTS
000016E8                           712  
000016E8  4EB9 000019F6            713  O_RTS       JSR         OPC_RTS
000016EE  4E75                     714              RTS
000016F0                           715  
000016F0  4EB9 000019CC            716  O_JSR       JSR         OPC_JSR
000016F6  4E75                     717              RTS
000016F8                           718           
000016F8                           719  
000016F8                           720  
000016F8  18FC 0053                721  OPC_SUBI    MOVE.B      #'S',(A4)+
000016FC  18FC 0055                722              MOVE.B      #'U',(A4)+
00001700  18FC 0042                723              MOVE.B      #'B',(A4)+
00001704  18FC 0049                724              MOVE.B      #'I',(A4)+
00001708  18FC 002E                725              MOVE.B      #'.',(A4)+
0000170C                           726              
0000170C  4EB9 00001D16            727              JSR         GET_SIZE_2  *Get 2 bit size code
00001712  4EB9 00001CC4            728              JSR         ADD_SIZE    *Add the size character based on size code
00001718                           729              
00001718  4EB9 00001E2A            730              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
0000171E                           731              
0000171E  4E75                     732              RTS
00001720                           733  
00001720  18FC 0041                734  OPC_ADDI    MOVE.B      #'A',(A4)+
00001724  18FC 0044                735              MOVE.B      #'D',(A4)+
00001728  18FC 0044                736              MOVE.B      #'D',(A4)+
0000172C  18FC 0049                737              MOVE.B      #'I',(A4)+
00001730  18FC 002E                738              MOVE.B      #'.',(A4)+
00001734                           739              
00001734  4EB9 00001D16            740              JSR         GET_SIZE_2  *Get 2 bit size code
0000173A  4EB9 00001CC4            741              JSR         ADD_SIZE    *Add the size character based on size code
00001740                           742              
00001740  4EB9 00001E2A            743              JSR         IDATASRC_EA *Jump to #<data>,<ea> operand flow.
00001746                           744              
00001746  4E75                     745              RTS
00001748                           746  
00001748  18FC 004D                747  OPC_MOVEB   MOVE.B      #'M',(A4)+
0000174C  18FC 004F                748              MOVE.B      #'O',(A4)+
00001750  18FC 0056                749              MOVE.B      #'V',(A4)+
00001754  18FC 0045                750              MOVE.B      #'E',(A4)+
00001758  18FC 002E                751              MOVE.B      #'.',(A4)+
0000175C                           752  
0000175C                           753  
0000175C  4284                     754              CLR.L       D4          *Manually set size to byte (D4 = 0)
0000175E  4EB9 00001CC4            755              JSR         ADD_SIZE    *Add size characters
00001764                           756              
00001764  4EB9 00001FB0            757              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
0000176A                           758              
0000176A  4E75                     759              RTS
0000176C                           760  
0000176C  18FC 0041                761  OPC_ADDQ    MOVE.B      #'A',(A4)+
00001770  18FC 0044                762              MOVE.B      #'D',(A4)+
00001774  18FC 0044                763              MOVE.B      #'D',(A4)+
00001778  18FC 0051                764              MOVE.B      #'Q',(A4)+
0000177C  18FC 002E                765              MOVE.B      #'.',(A4)+
00001780                           766  
00001780  4EB9 00001D16            767              JSR         GET_SIZE_2   *Get size code (placed in D4)
00001786  4EB9 00001CC4            768              JSR         ADD_SIZE     *Add size character to string (B/W/L)
0000178C                           769              
0000178C  4EB9 00001ECA            770              JSR         ADDQ_EA      *Start the EA/operand decode logic
00001792                           771   
00001792  4E75                     772              RTS
00001794                           773  
00001794  18FC 004D                774  OPC_MOVEQ   MOVE.B      #'M',(A4)+
00001798  18FC 004F                775              MOVE.B      #'O',(A4)+
0000179C  18FC 0056                776              MOVE.B      #'V',(A4)+
000017A0  18FC 0045                777              MOVE.B      #'E',(A4)+
000017A4  18FC 0051                778              MOVE.B      #'Q',(A4)+
000017A8                           779              
000017A8  4EB9 00001E96            780              JSR         MOVEQ_EA     *Start the EA/opderand decode logic for moveq
000017AE                           781            
000017AE  4E75                     782              RTS
000017B0                           783  
000017B0  18FC 0053                784  OPC_SUB     MOVE.B      #'S',(A4)+
000017B4  18FC 0055                785              MOVE.B      #'U',(A4)+
000017B8  18FC 0042                786              MOVE.B      #'B',(A4)+
000017BC  18FC 002E                787              MOVE.B      #'.',(A4)+
000017C0                           788  
000017C0  4EB9 00001D06            789              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000017C6                           790              
000017C6  4EB9 00001D3C            791              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
000017CC                           792  
000017CC  4E75                     793              RTS
000017CE                           794  
000017CE  18FC 004C                795  OPC_LEA     MOVE.B      #'L',(A4)+
000017D2  18FC 0045                796              MOVE.B      #'E',(A4)+
000017D6  18FC 0041                797              MOVE.B      #'A',(A4)+
000017DA  18FC 0020                798              MOVE.B      #' ',(A4)+
000017DE  18FC 0020                799              MOVE.B      #' ',(A4)+
000017E2                           800              
000017E2  4284                     801              CLR.L       D4          *Manually set size to byte (D4 = 0)
000017E4  183C 0002                802              MOVE.B      #2,D4       *Manually set size to long.
000017E8                           803              
000017E8  4EB9 00001DFE            804              JSR         EASRC_ADES
000017EE                           805              
000017EE  4E75                     806              RTS
000017F0                           807              
000017F0  18FC 004D                808  OPC_MOVEM   MOVE.B      #'M',(A4)+
000017F4  18FC 004F                809              MOVE.B      #'O',(A4)+
000017F8  18FC 0056                810              MOVE.B      #'V',(A4)+
000017FC  18FC 0045                811              MOVE.B      #'E',(A4)+
00001800  18FC 004D                812              MOVE.B      #'M',(A4)+
00001804  18FC 002E                813              MOVE.B      #'.',(A4)+
00001808                           814              
00001808  4EB9 00001D26            815              JSR         GET_SIZE_1
0000180E                           816              
0000180E  B83C 0000                817              CMP.B       #0,D4       *Change size code so it matches standard formatting
00001812  6700 000A                818              BEQ         MM_WORD
00001816  B83C 0001                819              CMP.B       #1,D4
0000181A  6700 000A                820              BEQ         MM_LONG
0000181E                           821  
0000181E  183C 0001                822  MM_WORD     MOVE.B      #1,D4
00001822  6000 0006                823              BRA         MM_ADD_S
00001826                           824  
00001826  183C 0002                825  MM_LONG     MOVE.B      #2,D4
0000182A                           826         
0000182A  4EB9 00001CC4            827  MM_ADD_S    JSR         ADD_SIZE
00001830  4EB9 00001E3C            828              JSR         MM_OP_ORD
00001836                           829              
00001836  4E75                     830              RTS
00001838                           831  
00001838                           832  
00001838  18FC 004D                833  OPC_MOVEAL  MOVE.B      #'M',(A4)+
0000183C  18FC 004F                834              MOVE.B      #'O',(A4)+
00001840  18FC 0056                835              MOVE.B      #'V',(A4)+
00001844  18FC 0045                836              MOVE.B      #'E',(A4)+
00001848  18FC 0041                837              MOVE.B      #'A',(A4)+
0000184C  18FC 002E                838              MOVE.B      #'.',(A4)+
00001850                           839  
00001850  4284                     840              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001852  183C 0002                841              MOVE.B      #2,D4       *Set size code to long
00001856  4EB9 00001CC4            842              JSR         ADD_SIZE    *Add size characters
0000185C                           843              
0000185C  4EB9 00001FB0            844              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00001862  4E75                     845              RTS
00001864                           846  
00001864                           847  
00001864  18FC 004D                848  OPC_MOVEL   MOVE.B      #'M',(A4)+
00001868  18FC 004F                849              MOVE.B      #'O',(A4)+
0000186C  18FC 0056                850              MOVE.B      #'V',(A4)+
00001870  18FC 0045                851              MOVE.B      #'E',(A4)+
00001874  18FC 002E                852              MOVE.B      #'.',(A4)+
00001878                           853  
00001878  4284                     854              CLR.L       D4          *Manually set size to byte (D4 = 0)
0000187A  183C 0002                855              MOVE.B      #2,D4       *Set size code to long
0000187E  4EB9 00001CC4            856              JSR         ADD_SIZE    *Add size characters
00001884                           857              
00001884  4EB9 00001FB0            858              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
0000188A  4E75                     859              RTS
0000188C                           860  
0000188C  18FC 004D                861  OPC_MOVEAW  MOVE.B      #'M',(A4)+
00001890  18FC 004F                862              MOVE.B      #'O',(A4)+
00001894  18FC 0056                863              MOVE.B      #'V',(A4)+
00001898  18FC 0045                864              MOVE.B      #'E',(A4)+
0000189C  18FC 0041                865              MOVE.B      #'A',(A4)+
000018A0  18FC 002E                866              MOVE.B      #'.',(A4)+
000018A4                           867  
000018A4  4284                     868              CLR.L       D4          *Manually set size to byte (D4 = 0)
000018A6  183C 0001                869              MOVE.B      #1,D4       *Set size code to word
000018AA  4EB9 00001CC4            870              JSR         ADD_SIZE    *Add size characters
000018B0                           871              
000018B0  4EB9 00001FB0            872              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000018B6  4E75                     873              RTS
000018B8                           874  
000018B8                           875  
000018B8  18FC 004D                876  OPC_MOVEW   MOVE.B      #'M',(A4)+
000018BC  18FC 004F                877              MOVE.B      #'O',(A4)+
000018C0  18FC 0056                878              MOVE.B      #'V',(A4)+
000018C4  18FC 0045                879              MOVE.B      #'E',(A4)+
000018C8  18FC 002E                880              MOVE.B      #'.',(A4)+
000018CC                           881  
000018CC  4284                     882              CLR.L       D4          *Manually set size to byte (D4 = 0)
000018CE  183C 0001                883              MOVE.B      #1,D4       *Set size code to word
000018D2  4EB9 00001CC4            884              JSR         ADD_SIZE    *Add size characters
000018D8                           885              
000018D8  4EB9 00001FB0            886              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
000018DE  4E75                     887              RTS
000018E0                           888  
000018E0                           889  
000018E0  18FC 0042                890  OPC_BRA     MOVE.B      #'B',(A4)+
000018E4  18FC 0052                891              MOVE.B      #'R',(A4)+
000018E8  18FC 0041                892              MOVE.B      #'A',(A4)+
000018EC  18FC 0020                893              MOVE.B      #' ',(A4)+
000018F0  18FC 0020                894              MOVE.B      #' ',(A4)+
000018F4                           895              
000018F4  4EB9 00002134            896              JSR         ABW       *Grab the next word value (BRA bug)
000018FA                           897                          
000018FA  4E75                     898              RTS
000018FC                           899  
000018FC  18FC 0042                900  OPC_Bcc     MOVE.B      #'B',(A4)+
00001900                           901              *BCC bug, does not use 8bit displacment, but is next word value (ABSW)
00001900  4EB9 00001AEA            902              JSR         BCC_CODE    *Get condition code and start decoding
00001906                           903              
00001906  4E75                     904              RTS
00001908                           905  
00001908  18FC 0044                906  OPC_DIVU    MOVE.B      #'D',(A4)+
0000190C  18FC 0049                907              MOVE.B      #'I',(A4)+
00001910  18FC 0056                908              MOVE.B      #'V',(A4)+
00001914  18FC 0055                909              MOVE.B      #'U',(A4)+
00001918  18FC 0020                910              MOVE.B      #' ',(A4)+
0000191C  18FC 0020                911              MOVE.B      #' ',(A4)+
00001920                           912              
00001920  4284                     913              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001922  183C 0001                914              MOVE.B      #1,D4       *Set size code to word
00001926                           915              
00001926  4EB9 00001DE8            916              JSR         EASRC_DDES  *Start operand <ea>,Dn
0000192C                           917              
0000192C                           918              
0000192C  4E75                     919              RTS
0000192E                           920  
0000192E  18FC 004F                921  OPC_OR      MOVE.B      #'O',(A4)+
00001932  18FC 0052                922              MOVE.B      #'R',(A4)+
00001936  18FC 002E                923              MOVE.B      #'.',(A4)+
0000193A                           924  
0000193A  4EB9 00001D06            925              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001940                           926              
00001940  4EB9 00001D3C            927              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
00001946                           928  
00001946  4E75                     929              RTS
00001948                           930  
00001948  18FC 004D                931  OPC_MULS    MOVE.B      #'M',(A4)+
0000194C  18FC 0055                932              MOVE.B      #'U',(A4)+
00001950  18FC 004C                933              MOVE.B      #'L',(A4)+
00001954  18FC 0053                934              MOVE.B      #'S',(A4)+
00001958  18FC 0020                935              MOVE.B      #' ',(A4)+
0000195C  18FC 0020                936              MOVE.B      #' ',(A4)+
00001960                           937              
00001960  4284                     938              CLR.L       D4          *Manually set size to byte (D4 = 0)
00001962  183C 0001                939              MOVE.B      #1,D4       *Set size code to word
00001966                           940              
00001966  4EB9 00001DE8            941              JSR         EASRC_DDES  *Jump to <ea>,Dn
0000196C                           942              
0000196C  4E75                     943              RTS
0000196E                           944  
0000196E  18FC 0041                945  OPC_AND     MOVE.B      #'A',(A4)+
00001972  18FC 004E                946              MOVE.B      #'N',(A4)+
00001976  18FC 0044                947              MOVE.B      #'D',(A4)+
0000197A  18FC 002E                948              MOVE.B      #'.',(A4)+
0000197E                           949  
0000197E  4EB9 00001D06            950              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
00001984                           951              
00001984  4EB9 00001D3C            952              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
0000198A                           953  
0000198A  4E75                     954              RTS
0000198C                           955              
0000198C  18FC 0041                956  OPC_ADDA    MOVE.B      #'A',(A4)+
00001990  18FC 0044                957              MOVE.B      #'D',(A4)+
00001994  18FC 0044                958              MOVE.B      #'D',(A4)+
00001998  18FC 0041                959              MOVE.B      #'A',(A4)+
0000199C  18FC 002E                960              MOVE.B      #'.',(A4)+
000019A0                           961              
000019A0  4EB9 00001CC4            962              JSR         ADD_SIZE    *Size should already be in D4 (special case for ADDA)
000019A6                           963              
000019A6  4EB9 00001DFE            964              JSR         EASRC_ADES  *Start operand decode for <ea>,An format
000019AC                           965              
000019AC  4E75                     966              RTS
000019AE                           967  
000019AE  18FC 0041                968  OPC_ADD     MOVE.B      #'A',(A4)+
000019B2  18FC 0044                969              MOVE.B      #'D',(A4)+
000019B6  18FC 0044                970              MOVE.B      #'D',(A4)+
000019BA  18FC 002E                971              MOVE.B      #'.',(A4)+
000019BE                           972  
000019BE  4EB9 00001D06            973              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000019C4                           974              
000019C4  4EB9 00001D3C            975              JSR         OR_ADD_SIZE *This will add size characters and start operand decode sequence
000019CA                           976  
000019CA  4E75                     977              RTS
000019CC                           978  
000019CC  18FC 004A                979  OPC_JSR     MOVE.B      #'J',(A4)+
000019D0  18FC 0053                980              MOVE.B      #'S',(A4)+
000019D4  18FC 0052                981              MOVE.B      #'R',(A4)+
000019D8  18FC 0020                982              MOVE.B      #' ',(A4)+
000019DC  18FC 0020                983              MOVE.B      #' ',(A4)+
000019E0  4EB9 00001F8E            984              JSR         GEN_EA_CODE *Get EA code
000019E6                           985              
000019E6  4E75                     986              RTS
000019E8                           987  
000019E8  18FC 004E                988  OPC_NOP     MOVE.B      #'N',(A4)+
000019EC  18FC 004F                989              MOVE.B      #'O',(A4)+
000019F0  18FC 0050                990              MOVE.B      #'P',(A4)+
000019F4                           991              
000019F4  4E75                     992              RTS
000019F6                           993  
000019F6  18FC 0052                994  OPC_RTS     MOVE.B      #'R',(A4)+
000019FA  18FC 0054                995              MOVE.B      #'T',(A4)+
000019FE  18FC 0053                996              MOVE.B      #'S',(A4)+
00001A02                           997              
00001A02  4E75                     998              RTS
00001A04                           999              
00001A04  18FC 0041               1000  OPC_AS_MEM  MOVE.B      #'A',(A4)+
00001A08  18FC 0053               1001              MOVE.B      #'S',(A4)+
00001A0C  4EB9 00001AC4           1002              JSR         SHFT_DECODE
00001A12  18FC 002E               1003              MOVE.B      #'.',(A4)+
00001A16                          1004                         
00001A16  4EB9 00001EF2           1005              JSR         SR_MEM
00001A1C  4E75                    1006              RTS
00001A1E                          1007  
00001A1E  18FC 004C               1008  OPC_LS_MEM  MOVE.B      #'L',(A4)+
00001A22  18FC 0053               1009              MOVE.B      #'S',(A4)+
00001A26  4EB9 00001AC4           1010              JSR         SHFT_DECODE
00001A2C  18FC 002E               1011              MOVE.B      #'.',(A4)+
00001A30                          1012                          
00001A30  4EB9 00001EF2           1013              JSR         SR_MEM
00001A36  4E75                    1014              RTS
00001A38                          1015  
00001A38  18FC 0052               1016  OPC_RO_MEM  MOVE.B      #'R',(A4)+
00001A3C  18FC 004F               1017              MOVE.B      #'O',(A4)+
00001A40  4EB9 00001AC4           1018              JSR         SHFT_DECODE
00001A46  18FC 002E               1019              MOVE.B      #'.',(A4)+
00001A4A                          1020                         
00001A4A  4EB9 00001EF2           1021              JSR         SR_MEM
00001A50  4E75                    1022              RTS   
00001A52                          1023  
00001A52  18FC 0041               1024  OPC_AS_REG  MOVE.B      #'A',(A4)+
00001A56  18FC 0053               1025              MOVE.B      #'S',(A4)+
00001A5A  4EB9 00001AC4           1026              JSR         SHFT_DECODE
00001A60  18FC 002E               1027              MOVE.B      #'.',(A4)+
00001A64                          1028              
00001A64  4EB9 00001D16           1029              JSR         GET_SIZE_2
00001A6A  4EB9 00001CC4           1030              JSR         ADD_SIZE
00001A70  4EB9 00001F00           1031              JSR         SR_REG
00001A76                          1032              
00001A76  4E75                    1033              RTS
00001A78                          1034  
00001A78  18FC 004C               1035  OPC_LS_REG  MOVE.B      #'L',(A4)+
00001A7C  18FC 0053               1036              MOVE.B      #'S',(A4)+
00001A80  4EB9 00001AC4           1037              JSR         SHFT_DECODE
00001A86  18FC 002E               1038              MOVE.B      #'.',(A4)+
00001A8A                          1039              
00001A8A  4EB9 00001D16           1040              JSR         GET_SIZE_2
00001A90  4EB9 00001CC4           1041              JSR         ADD_SIZE
00001A96  4EB9 00001F00           1042              JSR         SR_REG
00001A9C  4E75                    1043              RTS
00001A9E                          1044  
00001A9E  18FC 0052               1045  OPC_RO_REG  MOVE.B      #'R',(A4)+
00001AA2  18FC 004F               1046              MOVE.B      #'O',(A4)+
00001AA6  4EB9 00001AC4           1047              JSR         SHFT_DECODE
00001AAC  18FC 002E               1048              MOVE.B      #'.',(A4)+
00001AB0                          1049  
00001AB0  4EB9 00001D16           1050              JSR         GET_SIZE_2
00001AB6  4EB9 00001CC4           1051              JSR         ADD_SIZE
00001ABC  4EB9 00001F00           1052              JSR         SR_REG
00001AC2  4E75                    1053              RTS          
00001AC4                          1054  
00001AC4                          1055  
00001AC4  4282                    1056  SHFT_DECODE CLR.L       D2
00001AC6  3407                    1057              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00001AC8  4281                    1058              CLR.L       D1
00001ACA  EF4A                    1059              LSL.W       #7,D2       *Clear the most sig 7 bits
00001ACC  123C 000F               1060              MOVE.B      #15,D1      *Moves 15 into D1
00001AD0  E26A                    1061              LSR.W       D1,D2       *Shifts 15 right to isolate the bits we're working with 
00001AD2  B43C 0000               1062              CMP.B       #0,D2       *If 0, direction is determined to be R       
00001AD6  6700 0006               1063              BEQ         DECODE_R
00001ADA  6000 0008               1064              BRA         DECODE_L
00001ADE                          1065              
00001ADE  18FC 0052               1066  DECODE_R    MOVE.B      #'R',(A4)+  *Adds R to the output
00001AE2  4E75                    1067              RTS
00001AE4                          1068  
00001AE4  18FC 004C               1069  DECODE_L    MOVE.B      #'L',(A4)+  *Adds L to the output
00001AE8  4E75                    1070              RTS
00001AEA                          1071                      
00001AEA                          1072  
00001AEA  4283                    1073  BCC_CODE    CLR.L       D3          *Make sure D3 is empty to hold condition code
00001AEC  3607                    1074              MOVE.W      D7,D3       *Move in original address to be shifted
00001AEE  E94B                    1075              LSL.W       #4,D3
00001AF0  4282                    1076              CLR.L       D2
00001AF2  143C 000C               1077              MOVE.B      #12,D2
00001AF6  E46B                    1078              LSR.W       D2,D3
00001AF8  4EB9 00001B00           1079              JSR         BCC_TABLE   *Jump to BCC table now that condition code is in D3
00001AFE  4E75                    1080              RTS
00001B00                          1081  
00001B00  B63C 0002               1082  BCC_TABLE   CMP.B       #$2,D3      *Is it BHI?
00001B04  6700 006E               1083              BEQ         BCC_HI
00001B08  B63C 0003               1084              CMP.B       #$3,D3      *Is it BLS?
00001B0C  6700 007E               1085              BEQ         BCC_LS      
00001B10  B63C 0004               1086              CMP.B       #$4,D3      *Is it BCC?
00001B14  6700 008E               1087              BEQ         BCC_CC
00001B18  B63C 0005               1088              CMP.B       #$5,D3      *Is it BCS?
00001B1C  6700 009E               1089              BEQ         BCC_CS
00001B20  B63C 0006               1090              CMP.B       #$6,D3      *Is it BNE?
00001B24  6700 00AE               1091              BEQ         BCC_NE
00001B28  B63C 0007               1092              CMP.B       #$7,D3      *Is it BEQ?
00001B2C  6700 00BE               1093              BEQ         BCC_EQ
00001B30  B63C 0008               1094              CMP.B       #$8,D3      *Is it BVC?
00001B34  6700 00CE               1095              BEQ         BCC_VC      
00001B38  B63C 0009               1096              CMP.B       #$9,D3      *Is it BVS?
00001B3C  6700 00DE               1097              BEQ         BCC_VS
00001B40  B63C 000A               1098              CMP.B       #$A,D3      *Is it BPL?
00001B44  6700 00EE               1099              BEQ         BCC_PL
00001B48  B63C 000B               1100              CMP.B       #$B,D3      *Is it BMI?
00001B4C  6700 00FE               1101              BEQ         BCC_MI
00001B50  B63C 000C               1102              CMP.B       #$C,D3      *Is it BGE?
00001B54  6700 010E               1103              BEQ         BCC_GE
00001B58  B63C 000D               1104              CMP.B       #$D,D3      *Is it BLT?
00001B5C  6700 011E               1105              BEQ         BCC_LT
00001B60  B63C 000E               1106              CMP.B       #$E,D3      *Is it BGT?
00001B64  6700 012E               1107              BEQ         BCC_GT      
00001B68  B63C 000F               1108              CMP.B       #$F,D3      *Is it BLE?
00001B6C  6700 013E               1109              BEQ         BCC_LE
00001B70  4EF8 10EC               1110              JMP         INVALID     *Got here? Something is wrong.
00001B74                          1111  
00001B74  18FC 0048               1112  BCC_HI      MOVE.B      #'H',(A4)+
00001B78  18FC 0049               1113              MOVE.B      #'I',(A4)+
00001B7C  18FC 0020               1114              MOVE.B      #' ',(A4)+
00001B80  18FC 0020               1115              MOVE.B      #' ',(A4)+
00001B84  4EB9 00002134           1116              JSR         ABW         *Add absolute word in next word address.
00001B8A  4E75                    1117              RTS
00001B8C                          1118  
00001B8C  18FC 004C               1119  BCC_LS      MOVE.B      #'L',(A4)+
00001B90  18FC 0053               1120              MOVE.B      #'S',(A4)+
00001B94  18FC 0020               1121              MOVE.B      #' ',(A4)+
00001B98  18FC 0020               1122              MOVE.B      #' ',(A4)+
00001B9C  4EB9 00002134           1123              JSR         ABW         *Add absolute word in next word address.
00001BA2  4E75                    1124              RTS
00001BA4                          1125  
00001BA4  18FC 0043               1126  BCC_CC      MOVE.B      #'C',(A4)+
00001BA8  18FC 0043               1127              MOVE.B      #'C',(A4)+
00001BAC  18FC 0020               1128              MOVE.B      #' ',(A4)+
00001BB0  18FC 0020               1129              MOVE.B      #' ',(A4)+
00001BB4  4EB9 00002134           1130              JSR         ABW         *Add absolute word in next word address.
00001BBA  4E75                    1131              RTS
00001BBC                          1132              
00001BBC  18FC 0043               1133  BCC_CS      MOVE.B      #'C',(A4)+
00001BC0  18FC 0053               1134              MOVE.B      #'S',(A4)+
00001BC4  18FC 0020               1135              MOVE.B      #' ',(A4)+
00001BC8  18FC 0020               1136              MOVE.B      #' ',(A4)+
00001BCC  4EB9 00002134           1137              JSR         ABW         *Add absolute word in next word address.
00001BD2  4E75                    1138              RTS
00001BD4                          1139              
00001BD4  18FC 004E               1140  BCC_NE      MOVE.B      #'N',(A4)+
00001BD8  18FC 0045               1141              MOVE.B      #'E',(A4)+
00001BDC  18FC 0020               1142              MOVE.B      #' ',(A4)+
00001BE0  18FC 0020               1143              MOVE.B      #' ',(A4)+
00001BE4  4EB9 00002134           1144              JSR         ABW         *Add absolute word in next word address.
00001BEA  4E75                    1145              RTS
00001BEC                          1146              
00001BEC  18FC 0045               1147  BCC_EQ      MOVE.B      #'E',(A4)+
00001BF0  18FC 0051               1148              MOVE.B      #'Q',(A4)+
00001BF4  18FC 0020               1149              MOVE.B      #' ',(A4)+
00001BF8  18FC 0020               1150              MOVE.B      #' ',(A4)+
00001BFC  4EB9 00002134           1151              JSR         ABW         *Add absolute word in next word address.
00001C02  4E75                    1152              RTS
00001C04                          1153              
00001C04  18FC 0056               1154  BCC_VC      MOVE.B      #'V',(A4)+
00001C08  18FC 0043               1155              MOVE.B      #'C',(A4)+
00001C0C  18FC 0020               1156              MOVE.B      #' ',(A4)+
00001C10  18FC 0020               1157              MOVE.B      #' ',(A4)+
00001C14  4EB9 00002134           1158              JSR         ABW         *Add absolute word in next word address.
00001C1A  4E75                    1159              RTS
00001C1C                          1160  
00001C1C  18FC 0056               1161  BCC_VS      MOVE.B      #'V',(A4)+
00001C20  18FC 0053               1162              MOVE.B      #'S',(A4)+
00001C24  18FC 0020               1163              MOVE.B      #' ',(A4)+
00001C28  18FC 0020               1164              MOVE.B      #' ',(A4)+
00001C2C  4EB9 00002134           1165              JSR         ABW         *Add absolute word in next word address.
00001C32  4E75                    1166              RTS
00001C34                          1167              
00001C34  18FC 0050               1168  BCC_PL      MOVE.B      #'P',(A4)+
00001C38  18FC 004C               1169              MOVE.B      #'L',(A4)+
00001C3C  18FC 0020               1170              MOVE.B      #' ',(A4)+
00001C40  18FC 0020               1171              MOVE.B      #' ',(A4)+
00001C44  4EB9 00002134           1172              JSR         ABW         *Add absolute word in next word address.
00001C4A  4E75                    1173              RTS
00001C4C                          1174              
00001C4C  18FC 004D               1175  BCC_MI      MOVE.B      #'M',(A4)+
00001C50  18FC 0049               1176              MOVE.B      #'I',(A4)+
00001C54  18FC 0020               1177              MOVE.B      #' ',(A4)+
00001C58  18FC 0020               1178              MOVE.B      #' ',(A4)+
00001C5C  4EB9 00002134           1179              JSR         ABW         *Add absolute word in next word address.
00001C62  4E75                    1180              RTS
00001C64                          1181              
00001C64  18FC 0047               1182  BCC_GE      MOVE.B      #'G',(A4)+
00001C68  18FC 0045               1183              MOVE.B      #'E',(A4)+
00001C6C  18FC 0020               1184              MOVE.B      #' ',(A4)+
00001C70  18FC 0020               1185              MOVE.B      #' ',(A4)+
00001C74  4EB9 00002134           1186              JSR         ABW         *Add absolute word in next word address.
00001C7A  4E75                    1187              RTS
00001C7C                          1188              
00001C7C  18FC 004C               1189  BCC_LT      MOVE.B      #'L',(A4)+
00001C80  18FC 0054               1190              MOVE.B      #'T',(A4)+
00001C84  18FC 0020               1191              MOVE.B      #' ',(A4)+
00001C88  18FC 0020               1192              MOVE.B      #' ',(A4)+
00001C8C  4EB9 00002134           1193              JSR         ABW         *Add absolute word in next word address.
00001C92  4E75                    1194              RTS
00001C94                          1195              
00001C94  18FC 0047               1196  BCC_GT      MOVE.B      #'G',(A4)+
00001C98  18FC 0054               1197              MOVE.B      #'T',(A4)+
00001C9C  18FC 0020               1198              MOVE.B      #' ',(A4)+
00001CA0  18FC 0020               1199              MOVE.B      #' ',(A4)+
00001CA4  4EB9 00002134           1200              JSR         ABW         *Add absolute word in next word address.
00001CAA  4E75                    1201              RTS
00001CAC                          1202              
00001CAC  18FC 004C               1203  BCC_LE      MOVE.B      #'L',(A4)+
00001CB0  18FC 0045               1204              MOVE.B      #'E',(A4)+
00001CB4  18FC 0020               1205              MOVE.B      #' ',(A4)+
00001CB8  18FC 0020               1206              MOVE.B      #' ',(A4)+
00001CBC  4EB9 00002134           1207              JSR         ABW         *Add absolute word in next word address.
00001CC2  4E75                    1208              RTS
00001CC4                          1209  
00001CC4                          1210  
00001CC4  B83C 0000               1211  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn/an
00001CC8  6700 0012               1212              BEQ         B_SIZE
00001CCC  B83C 0001               1213              CMP.B       #1,D4       *Is it a W, <ea>,dn/an
00001CD0  6700 0018               1214              BEQ         W_SIZE
00001CD4  B83C 0002               1215              CMP.B       #2,D4       *Is it a L, <ea>,dn/an
00001CD8  6700 001E               1216              BEQ         L_SIZE 
00001CDC                          1217              
00001CDC  18FC 0042               1218  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
00001CE0  18FC 0020               1219              MOVE.B      #' ',(A4)+
00001CE4  18FC 0020               1220              MOVE.B      #' ',(A4)+
00001CE8  4E75                    1221              RTS
00001CEA                          1222  
00001CEA  18FC 0057               1223  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
00001CEE  18FC 0020               1224              MOVE.B      #' ',(A4)+
00001CF2  18FC 0020               1225              MOVE.B      #' ',(A4)+
00001CF6  4E75                    1226              RTS
00001CF8                          1227  
00001CF8  18FC 004C               1228  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
00001CFC  18FC 0020               1229              MOVE.B      #' ',(A4)+
00001D00  18FC 0020               1230              MOVE.B      #' ',(A4)+
00001D04  4E75                    1231              RTS
00001D06                          1232  
00001D06  4284                    1233  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001D08  3807                    1234              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001D0A  EF4C                    1235              LSL.W       #7,D4       *Clear more significant bits
00001D0C  4283                    1236              CLR.L       D3          *Make sure D3 is clear for shifting
00001D0E  163C 000D               1237              MOVE.B      #13,D3      *Shifting 13 times
00001D12  E66C                    1238              LSR.W       D3,D4       *Move size bits to LSB position
00001D14  4E75                    1239              RTS
00001D16                          1240  
00001D16  4284                    1241  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001D18  3807                    1242              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001D1A  E14C                    1243              LSL.W       #8,D4       *Clear more significant bits
00001D1C  4283                    1244              CLR.L       D3          *Make sure D3 is clear for shifting
00001D1E  163C 000E               1245              MOVE.B      #14,D3      *Shifting 14 times
00001D22  E66C                    1246              LSR.W       D3,D4       *Move size bits to LSB position
00001D24  4E75                    1247              RTS
00001D26                          1248  
00001D26  4284                    1249  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
00001D28  3807                    1250              MOVE.W      D7,D4       *Copy untouched opcode into D4
00001D2A  4283                    1251              CLR.L       D3          *Make sure D3 is clear for shifting
00001D2C  163C 0009               1252              MOVE.B      #9,D3       *Shift 9 times to the left
00001D30  E76C                    1253              LSL.W       D3,D4       *Clear more significant bits
00001D32  4283                    1254              CLR.L       D3          *Make sure D3 is clear for shifting
00001D34  163C 000F               1255              MOVE.B      #15,D3      *Shifting 15 times
00001D38  E66C                    1256              LSR.W       D3,D4       *Move size bits to LSB position
00001D3A  4E75                    1257              RTS
00001D3C                          1258  
00001D3C  B83C 0000               1259  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00001D40  6700 002E               1260              BEQ         B_EA
00001D44  B83C 0001               1261              CMP.B       #1,D4       *Is it a W, <ea>,dn
00001D48  6700 003A               1262              BEQ         W_EA
00001D4C  B83C 0002               1263              CMP.B       #2,D4       *Is it a L, <ea>,dn
00001D50  6700 0046               1264              BEQ         L_EA
00001D54                          1265  
00001D54  B83C 0004               1266              CMP.B       #4,D4       *Is it a B, dn,<ea>
00001D58  6700 0052               1267              BEQ         B_DN
00001D5C  B83C 0005               1268              CMP.B       #5,D4       *Is it a W, dn,<ea>
00001D60  6700 005E               1269              BEQ         W_DN
00001D64  B83C 0006               1270              CMP.B       #6,D4       *Is it a L, dn,<ea>
00001D68  6700 006A               1271              BEQ         L_DN        
00001D6C  6000 F37E               1272              BRA         INVALID     *Got here, must be invalid data.
00001D70                          1273              
00001D70  18FC 0042               1274  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
00001D74  18FC 0020               1275              MOVE.B      #' ',(A4)+
00001D78  18FC 0020               1276              MOVE.B      #' ',(A4)+
00001D7C  4EB9 00001DE8           1277              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001D82  4E75                    1278              RTS
00001D84                          1279  
00001D84  18FC 0057               1280  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
00001D88  18FC 0020               1281              MOVE.B      #' ',(A4)+
00001D8C  18FC 0020               1282              MOVE.B      #' ',(A4)+
00001D90  4EB9 00001DE8           1283              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001D96  4E75                    1284              RTS
00001D98                          1285  
00001D98  18FC 004C               1286  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00001D9C  18FC 0020               1287              MOVE.B      #' ',(A4)+
00001DA0  18FC 0020               1288              MOVE.B      #' ',(A4)+
00001DA4  4EB9 00001DE8           1289              JSR         EASRC_DDES *Move to EA_SRC to start parameter decode sequence
00001DAA  4E75                    1290              RTS
00001DAC                          1291  
00001DAC  18FC 0042               1292  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
00001DB0  18FC 0020               1293              MOVE.B      #' ',(A4)+
00001DB4  18FC 0020               1294              MOVE.B      #' ',(A4)+
00001DB8  4EB9 00001E14           1295              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001DBE  4E75                    1296              RTS
00001DC0                          1297  
00001DC0  18FC 0057               1298  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
00001DC4  18FC 0020               1299              MOVE.B      #' ',(A4)+
00001DC8  18FC 0020               1300              MOVE.B      #' ',(A4)+
00001DCC  4EB9 00001E14           1301              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001DD2  4E75                    1302              RTS
00001DD4                          1303  
00001DD4  18FC 004C               1304  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
00001DD8  18FC 0020               1305              MOVE.B      #' ',(A4)+
00001DDC  18FC 0020               1306              MOVE.B      #' ',(A4)+
00001DE0  4EB9 00001E14           1307              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
00001DE6  4E75                    1308              RTS            
00001DE8                          1309              
00001DE8                          1310              
00001DE8                          1311              
00001DE8                          1312              
00001DE8                          1313              
00001DE8                          1314              
00001DE8                          1315              
00001DE8                          1316  
00001DE8                          1317  
00001DE8                          1318  
00001DE8                          1319  
00001DE8                          1320  
00001DE8                          1321  
00001DE8                          1322  
00001DE8                          1323  
00001DE8                          1324  
00001DE8                          1325  
00001DE8                          1326  
00001DE8                          1327  
00001DE8                          1328  
00001DE8                          1329  -------------------- end include --------------------
00001DE8                          1330              INCLUDE     'Never_Lucky_EA_Codes.x68'      *Include ea code (tables)
00001DE8                          1331  
00001DE8                          1332  
00001DE8                          1333  
00001DE8                          1334  
00001DE8  4EB9 00001F8E           1335  EASRC_DDES  JSR         GEN_EA_CODE *Deal with EA code First
00001DEE  18FC 002C               1336              MOVE.B      #',',(A4)+
00001DF2  18FC 0044               1337              MOVE.B      #'D',(A4)+
00001DF6  4EB9 00001FF6           1338              JSR         REG_CODE    *Decode Dn and add number to string
00001DFC  4E75                    1339              RTS
00001DFE                          1340  
00001DFE  4EB9 00001F8E           1341  EASRC_ADES  JSR         GEN_EA_CODE *Deal with EA code first
00001E04  18FC 002C               1342              MOVE.B      #',',(A4)+
00001E08  18FC 0041               1343              MOVE.B      #'A',(A4)+
00001E0C  4EB9 00001FF6           1344              JSR         REG_CODE    *Decode Dn and add number to string
00001E12  4E75                    1345              RTS        
00001E14                          1346  
00001E14  18FC 0044               1347  DN_SRC      MOVE.B      #'D',(A4)+
00001E18  4EB9 00001FF6           1348              JSR         REG_CODE    *Decode Dn and add number to string
00001E1E  18FC 002C               1349              MOVE.B      #',',(A4)+
00001E22  4EB9 00001F8E           1350              JSR         GEN_EA_CODE *Deal with EA code Second
00001E28  4E75                    1351              RTS
00001E2A                          1352  
00001E2A  4EB9 00002154           1353  IDATASRC_EA JSR     IDATA       *Add immediate data
00001E30  18FC 002C               1354              MOVE.B  #',',(A4)+  
00001E34  4EB9 00001F8E           1355              JSR     GEN_EA_CODE *Add ea code
00001E3A  4E75                    1356              RTS
00001E3C                          1357  
00001E3C                          1358  
00001E3C  4EB9 00001F7E           1359  MM_OP_ORD   JSR         MM_DR       *Isolate DR bit into D2
00001E42                          1360  
00001E42  B43C 0000               1361              CMP.B       #0,D2       *Is it Register to Memory
00001E46  6700 000A               1362              BEQ         MM_R2M
00001E4A  B43C 0001               1363              CMP.B       #1,D2       *Is it Memory to Register
00001E4E  6700 000A               1364              BEQ         MM_M2R
00001E52                          1365              
00001E52  4EB9 00001E7C           1366  MM_R2M      JSR         MM_LS_SRC
00001E58  4E75                    1367              RTS
00001E5A                          1368  
00001E5A  4EB9 00001E62           1369  MM_M2R      JSR         MM_EA_SRC
00001E60  4E75                    1370              RTS
00001E62                          1371  
00001E62  4EB9 00001F8E           1372  MM_EA_SRC   JSR         GEN_EA_CODE *Add EA code
00001E68  18FC 002C               1373              MOVE.B      #',',(A4)+
00001E6C                          1374              *JSR         ISO_MASK    *Isolate the Mask
00001E6C                          1375              
00001E6C                          1376              *Bandaid, instead of decoding list, just display hex value
00001E6C  18FC 0023               1377              MOVE.B      #'#',(A4)+
00001E70  18FC 0024               1378              MOVE.B      #'$',(A4)+
00001E74  4EB9 000021A4           1379              JSR         W_IMD
00001E7A                          1380                      
00001E7A                          1381              *deal with list
00001E7A  4E75                    1382              RTS
00001E7C                          1383  
00001E7C                          1384  MM_LS_SRC   *Bandaid, instead of decoding list, just display hex value
00001E7C  18FC 0023               1385              MOVE.B      #'#',(A4)+
00001E80  18FC 0024               1386              MOVE.B      #'$',(A4)+
00001E84  4EB9 000021A4           1387              JSR         W_IMD
00001E8A                          1388              
00001E8A                          1389              *Deal with list first
00001E8A  18FC 002C               1390              MOVE.B      #',',(A4)+
00001E8E  4EB9 00001F8E           1391              JSR         GEN_EA_CODE *Add EA code
00001E94  4E75                    1392              RTS
00001E96                          1393  
00001E96  4281                    1394  MOVEQ_EA    CLR.L       D1          *Make sure D1 is clear
00001E98  3207                    1395              MOVE.W      D7,D1       *copy original opcode
00001E9A  18FC 0020               1396              MOVE.B      #' ',(A4)+
00001E9E  18FC 0020               1397              MOVE.B      #' ',(A4)+
00001EA2  18FC 0023               1398              MOVE.B      #'#',(A4)+
00001EA6  18FC 0024               1399              MOVE.B      #'$',(A4)+
00001EAA  4EB9 0000226A           1400              JSR         B_H2A       *Add data in 8 least sig bits (byte)
00001EB0  18FC 002C               1401              MOVE.B      #',',(A4)+
00001EB4  18FC 0044               1402              MOVE.B      #'D',(A4)+
00001EB8                          1403              
00001EB8  4281                    1404              CLR.L       D1
00001EBA  123C 000D               1405              MOVE.B      #13,D1
00001EBE  E94B                    1406              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001EC0  E26B                    1407              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001EC2                          1408              
00001EC2  4EB9 00001FF6           1409              JSR         REG_CODE    *Decode Dn and add number to string            
00001EC8                          1410  
00001EC8  4E75                    1411              RTS
00001ECA                          1412              
00001ECA  4281                    1413  ADDQ_EA     CLR.L       D1          *Make sure D1 is clear
00001ECC  3207                    1414              MOVE.W      D7,D1       *Move untoched opcode into D1 for Manipulation
00001ECE                          1415              
00001ECE  E949                    1416              LSL.W       #4,D1       *Clear more sig bits
00001ED0  4282                    1417              CLR.L       D2          * for shifting
00001ED2  143C 000D               1418              MOVE.B      #13,D2      *To move data bits into lsb
00001ED6  E469                    1419              LSR.W       D2,D1       *Data now in lsb
00001ED8                          1420              
00001ED8  18FC 0023               1421              MOVE.B      #'#',(A4)+
00001EDC  18FC 0024               1422              MOVE.B      #'$',(A4)+
00001EE0  4EB9 000021BC           1423              JSR         ADDQ_ID     *Jump to ADDQ_ID (immeidate data selector)
00001EE6  18FC 002C               1424              MOVE.B      #',',(A4)+  *Add seperator
00001EEA  4EB9 00001F8E           1425              JSR         GEN_EA_CODE *Add the ea code
00001EF0                          1426              
00001EF0  4E75                    1427              RTS
00001EF2                          1428  
00001EF2  4EB9 00002230           1429  SR_MEM      JSR         SR_MEM_ADDS     *Add Size characters
00001EF8  4EB9 00001F8E           1430              JSR         GEN_EA_CODE
00001EFE  4E75                    1431              RTS
00001F00                          1432  
00001F00                          1433  
00001F00  4EB9 00001F5A           1434  SR_REG      JSR         ISO_IR      *Place in D3
00001F06  4EB9 00001F6E           1435              JSR         ISO_RCOUNT  *Place in D2
00001F0C  B63C 0000               1436              CMP.B       #0, D3      *Is it an immediate data shift?
00001F10  6700 000A               1437              BEQ         IMD_SR
00001F14  B63C 0001               1438              CMP.B       #1, D3      *Is it an Dn shift?
00001F18  6700 0016               1439              BEQ         DN_SR
00001F1C                          1440              
00001F1C                          1441              
00001F1C  18FC 0023               1442  IMD_SR      MOVE.B      #'#',(A4)+
00001F20  18FC 0024               1443              MOVE.B      #'$',(A4)+
00001F24  4281                    1444              CLR.L       D1
00001F26  3202                    1445              MOVE.W      D2,D1
00001F28  4EB9 000021BC           1446              JSR         ADDQ_ID     *Same number sequence as ADDQ (add number of shifts)
00001F2E  4E75                    1447              RTS
00001F30                          1448  
00001F30                          1449  
00001F30  1602                    1450  DN_SR       MOVE.B      D2,D3
00001F32  18FC 0044               1451              MOVE.B      #'D',(A4)+
00001F36  4EB9 000020A4           1452              JSR         REG_TBL
00001F3C  18FC 002C               1453              MOVE.B      #',',(A4)+
00001F40  18FC 0044               1454              MOVE.B      #'D',(A4)+
00001F44                          1455              
00001F44  4281                    1456              CLR.L       D1
00001F46  123C 000D               1457              MOVE.B      #13,D1
00001F4A  4283                    1458              CLR.L       D3
00001F4C  3607                    1459              MOVE.W      D7,D3
00001F4E  E36B                    1460              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001F50  E26B                    1461              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001F52  4EB9 000020A4           1462              JSR         REG_TBL
00001F58                          1463              
00001F58  4E75                    1464              RTS         
00001F5A                          1465  
00001F5A                          1466  
00001F5A  4281                    1467  ISO_IR      CLR.L       D1
00001F5C  4283                    1468              CLR.L       D3
00001F5E                          1469              
00001F5E  3607                    1470              MOVE.W      D7,D3
00001F60                          1471              
00001F60  123C 000A               1472              MOVE.B      #10,D1
00001F64  E36B                    1473              LSL.W       D1,D3
00001F66  123C 000F               1474              MOVE.B      #15,D1
00001F6A  E26B                    1475              LSR.W       D1,D3
00001F6C                          1476                
00001F6C  4E75                    1477              RTS
00001F6E                          1478  
00001F6E  4281                    1479  ISO_RCOUNT  CLR.L       D1
00001F70  4282                    1480              CLR.L       D2
00001F72                          1481               
00001F72  3407                    1482              MOVE.W      D7,D2
00001F74                          1483              
00001F74  E94A                    1484              LSL.W       #4,D2
00001F76  123C 000D               1485              MOVE.B      #13,D1
00001F7A  E26A                    1486              LSR.W       D1,D2
00001F7C                          1487              
00001F7C  4E75                    1488              RTS
00001F7E                          1489  
00001F7E  4281                    1490  MM_DR       CLR.L       D1
00001F80  4282                    1491              CLR.L       D2
00001F82  3407                    1492              MOVE.W      D7,D2
00001F84  EB4A                    1493              LSL.W       #5,D2
00001F86  123C 000F               1494              MOVE.B      #15,D1
00001F8A  E26A                    1495              LSR.W       D1,D2
00001F8C  4E75                    1496              RTS
00001F8E                          1497  
00001F8E  4283                    1498  GEN_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001F90  4286                    1499              CLR.L       D6          *Make sure D6 is clear
00001F92  4281                    1500              CLR.L       D1          *Make sure D1 is clear for shifting
00001F94                          1501              
00001F94  3607                    1502              MOVE.W      D7,D3       *Move untouched opcode into D3
00001F96  3C07                    1503              MOVE.W      D7,D6       *Move untouched opcode into D6
00001F98                          1504              
00001F98  123C 000A               1505              MOVE.B      #10,D1      *Shifting to isolate MODE
00001F9C  E36E                    1506              LSL.W       D1,D6       
00001F9E  123C 000D               1507              MOVE.B      #13,D1
00001FA2  E26E                    1508              LSR.W       D1,D6       *Move MODE bits to LSB position
00001FA4                          1509              
00001FA4  E36B                    1510              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001FA6  E26B                    1511              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001FA8                          1512              
00001FA8  4EB9 0000200C           1513              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001FAE  4E75                    1514              RTS
00001FB0                          1515              
00001FB0  4283                    1516  MOV_EA_CODE CLR.L       D3          *Make sure D3 is clear
00001FB2  4286                    1517              CLR.L       D6          *Make sure D6 is clear
00001FB4  4281                    1518              CLR.L       D1          *Make sure D1 is clear for shifting
00001FB6                          1519              
00001FB6  3607                    1520              MOVE.W      D7,D3       *Move untouched opcode into D3
00001FB8  3C07                    1521              MOVE.W      D7,D6       *Move untouched opcode into D6
00001FBA                          1522              
00001FBA  123C 000A               1523              MOVE.B      #10,D1      *Shifting to isolate MODE
00001FBE  E36E                    1524              LSL.W       D1,D6       
00001FC0  123C 000D               1525              MOVE.B      #13,D1
00001FC4  E26E                    1526              LSR.W       D1,D6       *Move MODE bits to LSB position
00001FC6                          1527              
00001FC6  E36B                    1528              LSL.W       D1,D3       *Shifting to isolate REGISTER (#13 already in D1)
00001FC8  E26B                    1529              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001FCA                          1530              
00001FCA  4EB9 0000200C           1531              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001FD0                          1532              
00001FD0  18FC 002C               1533              MOVE.B      #',',(A4)+  *SEPERATOR
00001FD4                          1534              
00001FD4  4283                    1535              CLR.L       D3          *Make sure D3 is clear
00001FD6  4286                    1536              CLR.L       D6          *Make sure D6 is clear
00001FD8  4281                    1537              CLR.L       D1          *Make sure D1 is clear for shifting
00001FDA                          1538              
00001FDA  3607                    1539              MOVE.W      D7,D3       *Move untouched opcode into D3
00001FDC  3C07                    1540              MOVE.W      D7,D6       *Move untouched opcode into D6
00001FDE                          1541              
00001FDE  123C 0007               1542              MOVE.B      #7,D1      *Shifting to isolate MODE
00001FE2  E36E                    1543              LSL.W       D1,D6       
00001FE4  123C 000D               1544              MOVE.B      #13,D1
00001FE8  E26E                    1545              LSR.W       D1,D6       *Move MODE bits to LSB position
00001FEA                          1546              
00001FEA  E94B                    1547              LSL.W       #4,D3       *Shifting to isolate Dest REGISTER
00001FEC  E26B                    1548              LSR.W       D1,D3       *Move REG bits to LSB position (#13 already in D1)
00001FEE                          1549              
00001FEE  4EB9 0000200C           1550              JSR         EA_TBL      *Decode MODE to select correct <EA>
00001FF4                          1551              
00001FF4  4E75                    1552              RTS
00001FF6                          1553              
00001FF6                          1554              
00001FF6  4283                    1555  REG_CODE    CLR.L       D3          *Make sure D3 is empty to isolate Dn register
00001FF8  3607                    1556              MOVE.W      D7,D3       *Copy untoched opcode into D3 for manipulation
00001FFA  E94B                    1557              LSL.W       #4,D3       *Isolate bits and move to LSB position
00001FFC  4282                    1558              CLR.L       D2
00001FFE  143C 000D               1559              MOVE.B      #13,D2
00002002  E46B                    1560              LSR.W       D2,D3
00002004  4EB9 000020A4           1561              JSR         REG_TBL     *Jump to register table.
0000200A  4E75                    1562              RTS
0000200C                          1563              
0000200C                          1564  
0000200C                          1565  
0000200C                          1566  
0000200C  BC3C 0000               1567  EA_TBL      CMP.B       #0,D6       *Select correct <EA> mode
00002010  6700 002E               1568              BEQ         DRD
00002014  BC3C 0001               1569              CMP.B       #1,D6
00002018  6700 0032               1570              BEQ         ARD
0000201C  BC3C 0002               1571              CMP.B       #2,D6
00002020  6700 0036               1572              BEQ         ARI
00002024  BC3C 0003               1573              CMP.B       #3,D6
00002028  6700 0042               1574              BEQ         ARI_INC
0000202C  BC3C 0004               1575              CMP.B       #4,D6
00002030  6700 0052               1576              BEQ         ARI_DEC
00002034  BC3C 0007               1577              CMP.B       #7,D6
00002038  6700 0062               1578              BEQ         ABS_ADDR
0000203C  4EF8 10EC               1579              JMP         INVALID     *Got here? Must be bad data.
00002040                          1580  
00002040  18FC 0044               1581  DRD         MOVE.B      #'D',(A4)+
00002044  4EB9 000020A4           1582              JSR         REG_TBL     *Reg num should be in D3
0000204A  4E75                    1583              RTS
0000204C                          1584  
0000204C  18FC 0041               1585  ARD         MOVE.B      #'A',(A4)+
00002050  4EB9 000020A4           1586              JSR         REG_TBL     *Reg num should be in D3
00002056  4E75                    1587              RTS
00002058                          1588  
00002058  18FC 0028               1589  ARI         MOVE.B      #'(',(A4)+
0000205C  18FC 0041               1590              MOVE.B      #'A',(A4)+
00002060  4EB9 000020A4           1591              JSR         REG_TBL     *Reg num should be in D3
00002066  18FC 0029               1592              MOVE.B      #')',(A4)+
0000206A  4E75                    1593              RTS
0000206C                          1594  
0000206C  18FC 0028               1595  ARI_INC     MOVE.B      #'(',(A4)+
00002070  18FC 0041               1596              MOVE.B      #'A',(A4)+
00002074  4EB9 000020A4           1597              JSR         REG_TBL     *Reg num should be in D3
0000207A  18FC 0029               1598              MOVE.B      #')',(A4)+
0000207E  18FC 002B               1599              MOVE.B      #'+',(A4)+
00002082  4E75                    1600              RTS
00002084                          1601  
00002084  18FC 002D               1602  ARI_DEC     MOVE.B      #'-',(A4)+
00002088  18FC 0028               1603              MOVE.B      #'(',(A4)+
0000208C  18FC 0041               1604              MOVE.B      #'A',(A4)+
00002090  4EB9 000020A4           1605              JSR         REG_TBL     *Reg num should be in D3
00002096  18FC 0029               1606              MOVE.B      #')',(A4)+
0000209A  4E75                    1607              RTS
0000209C                          1608  
0000209C  4EB9 00002118           1609  ABS_ADDR    JSR         ABS_TBL
000020A2  4E75                    1610              RTS
000020A4                          1611              
000020A4  B63C 0000               1612  REG_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
000020A8  6700 003E               1613              BEQ         NUM_0
000020AC  B63C 0001               1614              CMP.B       #1,D3
000020B0  6700 003C               1615              BEQ         NUM_1
000020B4  B63C 0002               1616              CMP.B       #2,D3
000020B8  6700 003A               1617              BEQ         NUM_2
000020BC  B63C 0003               1618              CMP.B       #3,D3
000020C0  6700 0038               1619              BEQ         NUM_3
000020C4  B63C 0004               1620              CMP.B       #4,D3
000020C8  6700 0036               1621              BEQ         NUM_4
000020CC  B63C 0005               1622              CMP.B       #5,D3
000020D0  6700 0034               1623              BEQ         NUM_5
000020D4  B63C 0006               1624              CMP.B       #6,D3
000020D8  6700 0032               1625              BEQ         NUM_6
000020DC  B63C 0007               1626              CMP.B       #7,D3
000020E0  6700 0030               1627              BEQ         NUM_7
000020E4  4EF8 10EC               1628              JMP         INVALID     *Got here? Must be bad data.
000020E8                          1629              
000020E8  18FC 0030               1630  NUM_0       MOVE.B      #'0',(A4)+
000020EC  4E75                    1631              RTS              
000020EE  18FC 0031               1632  NUM_1       MOVE.B      #'1',(A4)+
000020F2  4E75                    1633              RTS
000020F4  18FC 0032               1634  NUM_2       MOVE.B      #'2',(A4)+
000020F8  4E75                    1635              RTS
000020FA  18FC 0033               1636  NUM_3       MOVE.B      #'3',(A4)+
000020FE  4E75                    1637              RTS
00002100  18FC 0034               1638  NUM_4       MOVE.B      #'4',(A4)+
00002104  4E75                    1639              RTS
00002106  18FC 0035               1640  NUM_5       MOVE.B      #'5',(A4)+
0000210A  4E75                    1641              RTS
0000210C  18FC 0036               1642  NUM_6       MOVE.B      #'6',(A4)+
00002110  4E75                    1643              RTS
00002112  18FC 0037               1644  NUM_7       MOVE.B      #'7',(A4)+
00002116  4E75                    1645              RTS
00002118                          1646  
00002118  B63C 0000               1647  ABS_TBL     CMP.B       #0,D3       *Select correct number to add to output strings
0000211C  6700 0016               1648              BEQ         ABW
00002120  B63C 0001               1649              CMP.B       #1,D3
00002124  6700 001E               1650              BEQ         ABL
00002128  B63C 0004               1651              CMP.B       #4,D3
0000212C  6700 0026               1652              BEQ         IDATA
00002130  4EF8 10EC               1653              JMP         INVALID     *Got here? Must be bad data.
00002134                          1654              
00002134  18FC 0024               1655  ABW         MOVE.B      #'$',(A4)+
00002138  4281                    1656              CLR.L       D1          *Make sure D1 is clear
0000213A  321D                    1657              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
0000213C  4EB9 000022AC           1658              JSR         W_H2A       *convert absolute value to ascii and add to good string
00002142  4E75                    1659              RTS
00002144                          1660  
00002144  18FC 0024               1661  ABL         MOVE.B      #'$',(A4)+
00002148  4281                    1662              CLR.L       D1          *Make sure D1 is clear
0000214A  221D                    1663              MOVE.L      (A5)+, D1   *Increment counter by WORD (grab word data)
0000214C  4EB9 000022EE           1664              JSR         L_H2A
00002152  4E75                    1665              RTS
00002154                          1666              
00002154  18FC 0023               1667  IDATA       MOVE.B      #'#',(A4)+
00002158  18FC 0024               1668              MOVE.B      #'$',(A4)+  *Immediate value will be in Hex
0000215C  4EB9 00002164           1669              JSR         IMD_TBL
00002162  4E75                    1670              RTS
00002164                          1671              
00002164  B83C 0000               1672  IMD_TBL     CMP.B       #0,D4       *Is it byte size code?
00002168  6700 002E               1673              BEQ         B_IMD       
0000216C  B83C 0004               1674              CMP.B       #4,D4
00002170  6700 0026               1675              BEQ         B_IMD
00002174                          1676  
00002174  B83C 0001               1677              CMP.B       #1,D4       *Is it a word size code?
00002178  6700 002A               1678              BEQ         W_IMD
0000217C  B83C 0005               1679              CMP.B       #5,D4
00002180  6700 0022               1680              BEQ         W_IMD
00002184                          1681              
00002184  B83C 0002               1682              CMP.B       #2,D4       *Is it a long word size code?
00002188  6700 0026               1683              BEQ         L_IMD
0000218C  B83C 0006               1684              CMP.B       #6,D4
00002190  6700 001E               1685              BEQ         L_IMD
00002194                          1686              
00002194  6000 EF56               1687              BRA         INVALID     *Got here? Must be bad data.
00002198                          1688              
00002198  4281                    1689  B_IMD       CLR.L       D1
0000219A  321D                    1690              MOVE.W      (A5)+,D1    *Make sure D1 is clear
0000219C  4EB9 0000226A           1691              JSR         B_H2A       *Incremeint by WORD (but translate byte only)
000021A2  4E75                    1692              RTS
000021A4                          1693  
000021A4  4281                    1694  W_IMD       CLR.L       D1          *Make sure D1 is clear
000021A6  321D                    1695              MOVE.W      (A5)+, D1   *Increment counter by WORD (grab word data)
000021A8  4EB9 000022AC           1696              JSR         W_H2A
000021AE  4E75                    1697              RTS
000021B0                          1698  
000021B0  4281                    1699  L_IMD       CLR.L       D1          *Make sure D1 is clear
000021B2  221D                    1700              MOVE.L      (A5)+, D1   *Increment counter by LONGWORD (grab LONGWORD data)
000021B4  4EB9 000022EE           1701              JSR         L_H2A
000021BA  4E75                    1702              RTS
000021BC                          1703  
000021BC  B23C 0000               1704  ADDQ_ID     CMP.B       #0,D1       *Select correct number to add to output strings
000021C0  6700 003E               1705              BEQ         AQ_0
000021C4  B23C 0001               1706              CMP.B       #1,D1
000021C8  6700 003C               1707              BEQ         AQ_1
000021CC  B23C 0002               1708              CMP.B       #2,D1
000021D0  6700 003A               1709              BEQ         AQ_2
000021D4  B23C 0003               1710              CMP.B       #3,D1
000021D8  6700 0038               1711              BEQ         AQ_3
000021DC  B23C 0004               1712              CMP.B       #4,D1
000021E0  6700 0036               1713              BEQ         AQ_4
000021E4  B23C 0005               1714              CMP.B       #5,D1
000021E8  6700 0034               1715              BEQ         AQ_5
000021EC  B23C 0006               1716              CMP.B       #6,D1
000021F0  6700 0032               1717              BEQ         AQ_6
000021F4  B23C 0007               1718              CMP.B       #7,D1
000021F8  6700 0030               1719              BEQ         AQ_7
000021FC  4EF8 10EC               1720              JMP         INVALID     *Got here? Something is wrong.
00002200                          1721              
00002200  18FC 0038               1722  AQ_0        MOVE.B      #'8',(A4)+
00002204  4E75                    1723              RTS              
00002206  18FC 0031               1724  AQ_1        MOVE.B      #'1',(A4)+
0000220A  4E75                    1725              RTS
0000220C  18FC 0032               1726  AQ_2        MOVE.B      #'2',(A4)+
00002210  4E75                    1727              RTS
00002212  18FC 0033               1728  AQ_3        MOVE.B      #'3',(A4)+
00002216  4E75                    1729              RTS
00002218  18FC 0034               1730  AQ_4        MOVE.B      #'4',(A4)+
0000221C  4E75                    1731              RTS
0000221E  18FC 0035               1732  AQ_5        MOVE.B      #'5',(A4)+
00002222  4E75                    1733              RTS
00002224  18FC 0036               1734  AQ_6        MOVE.B      #'6',(A4)+
00002228  4E75                    1735              RTS
0000222A  18FC 0037               1736  AQ_7        MOVE.B      #'7',(A4)+
0000222E  4E75                    1737              RTS          
00002230                          1738  
00002230                          1739              
00002230                          1740  
00002230                          1741  
00002230  4282                    1742  SR_MEM_ADDS CLR.L       D2
00002232  3407                    1743              MOVE.W      D7,D2
00002234                          1744              
00002234  4281                    1745              CLR.L       D1
00002236  123C 000D               1746              MOVE.B      #13,D1
0000223A  E36A                    1747              LSL.W       D1,D2       *Shifting to isolate REGISTER (#13 already in D1)
0000223C  E26A                    1748              LSR.W       D1,D2
0000223E                          1749              
0000223E  B43C 0000               1750              CMP.B       #0,D2       *is it a word?
00002242  6700 000A               1751              BEQ         SR_MEM_W
00002246  B43C 0001               1752              CMP.B       #1,D2       *is it a word?
0000224A  6700 0010               1753              BEQ         SR_MEM_L
0000224E                          1754              
0000224E  18FC 0057               1755  SR_MEM_W    MOVE.B      #'W',(A4)+
00002252  18FC 0020               1756              MOVE.B      #' ',(A4)+
00002256  18FC 0020               1757              MOVE.B      #' ',(A4)+
0000225A  4E75                    1758              RTS
0000225C                          1759  
0000225C  18FC 0057               1760  SR_MEM_L    MOVE.B      #'W',(A4)+
00002260  18FC 0020               1761              MOVE.B      #' ',(A4)+
00002264  18FC 0020               1762              MOVE.B      #' ',(A4)+
00002268  4E75                    1763              RTS
0000226A                          1764  
0000226A  4280                    1765  B_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
0000226C  4282                    1766              CLR.L       D2          *Make sure D2 is empty (each individual char)
0000226E  4283                    1767              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
00002270  103C 0002               1768              MOVE.B      #$2,D0      *Counter
00002274  6000 0002               1769              BRA         B_ISO_DIG   *Begin isolating chars
00002278                          1770              
00002278  E919                    1771  B_ISO_DIG   ROL.B       #4,D1       *Move first significant hex char to least sig position
0000227A                          1772              
0000227A  1401                    1773              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
0000227C                          1774              
0000227C  163C 0004               1775              MOVE.B      #4,D3      *Shift left 28 times
00002280  E72A                    1776              LSL.B       D3,D2       *Isolated hex digit now is $X0000000
00002282  E91A                    1777              ROL.B       #4,D2       *Isolated hex digit is now $0000000X
00002284                          1778              
00002284  0C02 0009               1779              CMPI.B      #$9,D2      *Is it a number?
00002288  6F00 0006               1780              BLE         B_NUM       *If it is, process number
0000228C  6000 000A               1781              BRA         B_LET       *If not, process letter
00002290                          1782              
00002290  0602 0030               1783  B_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002294  6000 000A               1784              BRA         B_ADD_CHAR  *add to strings and continue
00002298                          1785              
00002298  0602 0037               1786  B_LET       ADDI.B      #$37,D2     *Make it an ascii letter
0000229C  6000 0002               1787              BRA         B_ADD_CHAR  *add to strings and continue
000022A0                          1788  
000022A0  18C2                    1789  B_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000022A2  5300                    1790              SUBI.B      #$1,D0      *decrement counter
000022A4  0C00 0000               1791              CMPI.B      #$0,D0      *Check if we're done            
000022A8  6ECE                    1792              BGT         B_ISO_DIG   *If not, continue tranlation   
000022AA                          1793              
000022AA  4E75                    1794              RTS
000022AC                          1795  
000022AC  4280                    1796  W_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000022AE  4282                    1797              CLR.L       D2          *Make sure D2 is empty (each individual char)
000022B0  4283                    1798              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000022B2  103C 0004               1799              MOVE.B      #$4,D0      *Counter
000022B6  6000 0002               1800              BRA         W_ISO_DIG   *Begin isolating chars
000022BA                          1801              
000022BA  E959                    1802  W_ISO_DIG   ROL.W       #4,D1       *Move first significant hex char to least sig position
000022BC                          1803              
000022BC  1401                    1804              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
000022BE                          1805              
000022BE  163C 000C               1806              MOVE.B      #12,D3      *Shift left 28 times
000022C2  E76A                    1807              LSL.W       D3,D2       *Isolated hex digit now is $X0000000
000022C4  E95A                    1808              ROL.W       #4,D2       *Isolated hex digit is now $0000000X
000022C6                          1809              
000022C6  0C02 0009               1810              CMPI.B      #$9,D2      *Is it a number?
000022CA  6F00 0006               1811              BLE         W_NUM       *If it is, process number
000022CE  6000 000A               1812              BRA         W_LET       *If not, process letter
000022D2                          1813              
000022D2  0602 0030               1814  W_NUM       ADDI.B      #$30,D2     *Make it an ascii number
000022D6  6000 000A               1815              BRA         W_ADD_CHAR  *add to strings and continue
000022DA                          1816              
000022DA  0602 0037               1817  W_LET       ADDI.B      #$37,D2     *Make it an ascii letter
000022DE  6000 0002               1818              BRA         W_ADD_CHAR  *add to strings and continue
000022E2                          1819  
000022E2  18C2                    1820  W_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
000022E4  5300                    1821              SUBI.B      #$1,D0      *decrement counter
000022E6  0C00 0000               1822              CMPI.B      #$0,D0      *Check if we're done            
000022EA  6ECE                    1823              BGT         W_ISO_DIG   *If not, continue tranlation   
000022EC                          1824              
000022EC  4E75                    1825              RTS
000022EE  4280                    1826  L_H2A       CLR.L       D0          *Make sure D0 is clear (for counting)
000022F0  4282                    1827              CLR.L       D2          *Make sure D2 is empty (each individual char)
000022F2  4283                    1828              CLR.L       D3          *Make sure D3 is empty (for shifting source operand)
000022F4  103C 0008               1829              MOVE.B      #$8,D0      *Counter
000022F8  6000 0002               1830              BRA         L_ISO_DIG   *Begin isolating chars
000022FC                          1831              
000022FC  E999                    1832  L_ISO_DIG   ROL.L       #4,D1       *Move first significant hex char to least sig position
000022FE                          1833              
000022FE  1401                    1834              MOVE.B      D1,D2       *Move to D2 to isolate least sig hex char
00002300                          1835              
00002300  163C 001C               1836              MOVE.B      #28,D3      *Shift left 28 times
00002304  E7AA                    1837              LSL.L       D3,D2       *Isolated hex digit now is $X0000000
00002306  E99A                    1838              ROL.L       #4,D2       *Isolated hex digit is now $0000000X
00002308                          1839              
00002308  0C02 0009               1840              CMPI.B      #$9,D2      *Is it a number?
0000230C  6F00 0006               1841              BLE         L_NUM       *If it is, process number
00002310  6000 000A               1842              BRA         L_LET       *If not, process letter
00002314                          1843              
00002314  0602 0030               1844  L_NUM       ADDI.B      #$30,D2     *Make it an ascii number
00002318  6000 000A               1845              BRA         L_ADD_CHAR  *add to strings and continue
0000231C                          1846              
0000231C  0602 0037               1847  L_LET       ADDI.B      #$37,D2     *Make it an ascii letter
00002320  6000 0002               1848              BRA         L_ADD_CHAR  *add to strings and continue
00002324                          1849  
00002324  18C2                    1850  L_ADD_CHAR  MOVE.B      D2,(A4)+    *Add to the good data string
00002326  5300                    1851              SUBI.B      #$1,D0      *decrement counter
00002328  0C00 0000               1852              CMPI.B      #$0,D0      *Check if we're done            
0000232C  6ECE                    1853              BGT         L_ISO_DIG   *If not, continue tranlation   
0000232E                          1854              
0000232E  4E75                    1855              RTS
00002330                          1856  
00002330                          1857  
00002330                          1858  
00002330                          1859  
00002330                          1860  
00002330                          1861  
00002330                          1862  
00002330                          1863  
00002330                          1864  
00002330                          1865  -------------------- end include --------------------
00002330                          1866  
00002330  =0000000D               1867  CR          EQU         $0D
00002330  =0000000A               1868  LF          EQU         $0A
00002330                          1869  
00002330= 2D 2D 2D 2D 2D 2D ...   1870  NL_INTRO    DC.B        '------------TEAM NEVER LUCKY------------',CR,LF
0000235A= 48 65 6E 72 79 20 ...   1871              DC.B        'Henry Hong, Ryan Palm, Joshua Plantilla',CR,LF
00002383= 43 53 53 20 34 32 ...   1872              DC.B        'CSS 422 Final Project: 68k Disassembler',CR,LF
000023AC= 2D 2D 2D 2D 2D 2D ...   1873              DC.B        '----------------------------------------',CR,LF,0
000023D7                          1874  
000023D7= 59 6F 75 20 4D 55 ...   1875  IN_WARN     DC.B        'You MUST follow the following input rules:',CR,LF
00002403= 31 2E 20 59 6F 75 ...   1876              DC.B        '1. Your starting address must be greater than or equal to $3000',CR,LF
00002444= 20 20 20 28 74 68 ...   1877              DC.B        '   (this means your data file must be orged at $3000 or greater)',CR,LF
00002486= 32 2E 20 59 6F 75 ...   1878              DC.B        '2. Your ending address must be greater than your starting address',CR,LF
000024C9= 33 2E 20 59 6F 75 ...   1879              DC.B        '3. You must enter something for both starting and ending (no NULL inputs)',CR,LF
00002514= 34 2E 20 42 6F 74 ...   1880              DC.B        '4. Both your starting and ending address must be in the range of:',CR,LF
00002557= 20 20 20 5B 24 33 ...   1881              DC.B        '   [$3000,$FFFFFFFF) (interval notation)',CR,LF
00002581= 35 2E 20 59 6F 75 ...   1882              DC.B        '5. Your inputs for both addresses may NOT be ODD values.',CR,LF
000025BB= 36 2E 20 59 6F 75 ...   1883              DC.B        '6. Your inputs for both must ONLY contain standard hexidecimal characters:',CR,LF
00002607= 20 20 20 30 20 31 ...   1884              DC.B        '   0 1 2 3 4 5 6 7 8 9 A B C D E F (Do NOT include spaces or $)',CR,LF
00002648= 46 61 69 6C 75 72 ...   1885              DC.B        'Failure to follow these instructions WILL result in crash or unexpected behavior.',CR,LF,CR,LF,0
0000269E                          1886   
0000269E                          1887              
0000269E= 45 6E 74 65 72 20 ...   1888  STA_MSG     DC.B        'Enter starting address (ALL CAPS):',0
000026C1= 45 6E 74 65 72 20 ...   1889  END_MSG     DC.B        'Enter ending address (ALL CAPS):',0
000026E2                          1890  
000026E2= 0D 0A 50 72 65 73 ...   1891  NXT_PG      DC.B        CR,LF,'Press ENTER key to contiune reading',CR,CR,LF,0
0000270B                          1892  
0000270B= 0D 0A 50 72 65 73 ...   1893  END_PGR     DC.B        CR,LF,'Prese SPACE to decode another memory image.',CR,LF
0000273A= 50 72 65 73 73 20 ...   1894              DC.B        'Press ESC key to QUIT.',CR,LF,0
00002753                          1895  
00002753                          1896  STA_ADDR    DS.B        40
0000277B                          1897  END_ADDR    DS.B        40
000027A3                          1898  
000027A3                          1899  
000027A4= 00000001                1900  BAD_STR     DC.L        1
000027A8                          1901  
000027A8= 00000050                1902  SPACER11    DC.L        80
000027AC= 00000050                1903  SPACER22    DC.L        80
000027B0= 00000050                1904  SPACER33    DC.L        80
000027B4= 00000050                1905  SPACER44    DC.L        80
000027B8= 00000050                1906  SPACER55    DC.L        80
000027BC= 00000050                1907  SPACER66    DC.L        80
000027C0= 00000050                1908  SPACER77    DC.L        80
000027C4= 00000050                1909  SPACER88    DC.L        80
000027C8= 00000050                1910  SPACER99    DC.L        80
000027CC= 00000050                1911  SPACERAA    DC.L        80
000027D0= 00000050                1912  SPACERBB    DC.L        80
000027D4= 00000050                1913  SPACERCC    DC.L        80
000027D8= 00000050                1914  SPACERDD    DC.L        80
000027DC= 00000050                1915  SPACEREE    DC.L        80
000027E0= 00000050                1916  SPACERFF    DC.L        80
000027E4                          1917  
000027E4= 00000001                1918  GOOD_STR    DC.L        1
000027E8                          1919  
000027E8= 00000050                1920  SPACER1     DC.L        80
000027EC= 00000050                1921  SPACER2     DC.L        80
000027F0= 00000050                1922  SPACER3     DC.L        80
000027F4= 00000050                1923  SPACER4     DC.L        80
000027F8= 00000050                1924  SPACER5     DC.L        80
000027FC= 00000050                1925  SPACER6     DC.L        80
00002800= 00000050                1926  SPACER7     DC.L        80
00002804= 00000050                1927  SPACER8     DC.L        80
00002808= 00000050                1928  SPACER9     DC.L        80
0000280C= 00000050                1929  SPACERA     DC.L        80
00002810= 00000050                1930  SPACERB     DC.L        80
00002814= 00000050                1931  SPACERC     DC.L        80
00002818= 00000050                1932  SPACERD     DC.L        80
0000281C= 00000050                1933  SPACERE     DC.L        80
00002820= 00000050                1934  SPACERF     DC.L        80
00002824                          1935  
00002824                          1936              END         START       *LAST LINE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABL                 2144
ABS_ADDR            209C
ABS_TBL             2118
ABW                 2134
ADDQ_EA             1ECA
ADDQ_ID             21BC
ADD_CHAR_B          1218
ADD_CHAR_BO         125E
ADD_CHAR_G          11D0
ADD_SIZE            1CC4
AH_DONE             109E
AQ_0                2200
AQ_1                2206
AQ_2                220C
AQ_3                2212
AQ_4                2218
AQ_5                221E
AQ_6                2224
AQ_7                222A
ARD                 204C
ARI                 2058
ARI_DEC             2084
ARI_INC             206C
ASCII_HEX           1086
BAD_STR             27A4
BCC_CC              1BA4
BCC_CODE            1AEA
BCC_CS              1BBC
BCC_EQ              1BEC
BCC_GE              1C64
BCC_GT              1C94
BCC_HI              1B74
BCC_LE              1CAC
BCC_LS              1B8C
BCC_LT              1C7C
BCC_MI              1C4C
BCC_NE              1BD4
BCC_PL              1C34
BCC_TABLE           1B00
BCC_VC              1C04
BCC_VS              1C1C
B_ADD_CHAR          22A0
B_DN                1DAC
B_EA                1D70
B_H2A               226A
B_IMD               2198
B_ISO_DIG           2278
B_LET               2298
B_NUM               2290
B_SIZE              1CDC
CLEAN_GS            112A
CONTINUE            10F6
CR                  D
DECODE_L            1AE4
DECODE_LOOP         10C2
DECODE_R            1ADE
DN_SR               1F30
DN_SRC              1E14
DONE                130A
DRD                 2040
D_CLEAN             113E
EASRC_ADES          1DFE
EASRC_DDES          1DE8
EA_TBL              200C
END_ADDR            277B
END_MSG             26C1
END_OPT             12E6
END_PGR             270B
FORMAT              10B4
GEN_EA_CODE         1F8E
GET_INPUT           1020
GET_SIZE_1          1D26
GET_SIZE_2          1D16
GET_SIZE_3          1D06
GOOD_STR            27E4
GS_LOOP             1130
H2A_B_ADDR          11DC
H2A_B_OP            1224
H2A_G_ADDR          1194
IDATA               2154
IDATASRC_EA         1E2A
IMD_SR              1F1C
IMD_TBL             2164
INIT_BAD            1162
INIT_GOOD           114E
INIT_STRS           1140
INTRO               1012
INVALID             10EC
INV_OP              1408
IN_WARN             23D7
ISODIG_BO           1236
ISO_DIG_B           11F0
ISO_DIG_G           11A8
ISO_IR              1F5A
ISO_RCOUNT          1F6E
JMP_0               131C
JMP_0X              1490
JMP_1               132C
JMP_2               133C
JMP_2X              14BA
JMP_3               134C
JMP_3X              14DE
JMP_4               135C
JMP_47X             16C0
JMP_4X              1502
JMP_5               136C
JMP_6               137C
JMP_6X              1548
JMP_7               138C
JMP_8               139C
JMP_8X              156C
JMP_9               13AC
JMP_A               13BC
JMP_B               13CA
JMP_C               13D8
JMP_CX              1590
JMP_D               13E8
JMP_DX              15B4
JMP_E               13F8
JMP_EX              1618
JMP_TBL             1310
J_47X               1530
J_ADDI              14B2
J_AND               15AC
J_BCC               1564
J_BRA               155C
J_CLR1              143E
J_CLR2              142E
J_CLR3              141E
J_CLR4              140E
J_CLR_DM            146C
J_CLR_LEA           144E
J_CLR_MM            145E
J_CLR_SHFT          147C
J_DIVU              1580
J_LEA               1538
J_MOVEAL            14CE
J_MOVEAW            14F2
J_MOVEL             14D6
J_MOVEM             1540
J_MOVEW             14FA
J_MULS              15A4
J_OR                1588
J_SUBI              14AA
LET                 10AA
LET_B               1210
LET_BO              1256
LET_G               11C8
LF                  A
L_ADD_CHAR          2324
L_DN                1DD4
L_EA                1D98
L_H2A               22EE
L_IMD               21B0
L_ISO_DIG           22FC
L_LET               231C
L_NUM               2314
L_SIZE              1CF8
MM_ADD_S            182A
MM_DR               1F7E
MM_EA_SRC           1E62
MM_LONG             1826
MM_LS_SRC           1E7C
MM_M2R              1E5A
MM_OP_ORD           1E3C
MM_R2M              1E52
MM_WORD             181E
MOVEQ_EA            1E96
MOV_EA_CODE         1FB0
NEXT_PAGE           110C
NL_INTRO            2330
NUM                 10A0
NUM_0               20E8
NUM_1               20EE
NUM_2               20F4
NUM_3               20FA
NUM_4               2100
NUM_5               2106
NUM_6               210C
NUM_7               2112
NUM_B               1208
NUM_BO              124E
NUM_G               11C0
NXT_PG              26E2
OPC_ADD             19AE
OPC_ADDA            198C
OPC_ADDI            1720
OPC_ADDQ            176C
OPC_AND             196E
OPC_AS_MEM          1A04
OPC_AS_REG          1A52
OPC_BCC             18FC
OPC_BRA             18E0
OPC_DIVU            1908
OPC_JSR             19CC
OPC_LEA             17CE
OPC_LS_MEM          1A1E
OPC_LS_REG          1A78
OPC_MOVEAL          1838
OPC_MOVEAW          188C
OPC_MOVEB           1748
OPC_MOVEL           1864
OPC_MOVEM           17F0
OPC_MOVEQ           1794
OPC_MOVEW           18B8
OPC_MULS            1948
OPC_NOP             19E8
OPC_OR              192E
OPC_RO_MEM          1A38
OPC_RO_REG          1A9E
OPC_RTS             19F6
OPC_SUB             17B0
OPC_SUBI            16F8
OP_ADD              1610
OP_ADDA             1608
OP_AS_MEM           1670
OP_AS_REG           16A8
OP_LS_MEM           1678
OP_LS_REG           16B0
OP_RO_MEM           1680
OP_RO_REG           16B8
OR_ADD_SIZE         1D3C
O_JSR               16F0
O_NOP               16E0
O_RTS               16E8
PRG_RESET           1296
PRINT_B             1280
PRINT_G             126A
PRINT_GOOD          10E2
PROC_END            107A
PROC_STA            106E
REG_CODE            1FF6
REG_TBL             20A4
SHFT_DECODE         1AC4
SPACER1             27E8
SPACER11            27A8
SPACER2             27EC
SPACER22            27AC
SPACER3             27F0
SPACER33            27B0
SPACER4             27F4
SPACER44            27B4
SPACER5             27F8
SPACER55            27B8
SPACER6             27FC
SPACER66            27BC
SPACER7             2800
SPACER77            27C0
SPACER8             2804
SPACER88            27C4
SPACER9             2808
SPACER99            27C8
SPACERA             280C
SPACERAA            27CC
SPACERB             2810
SPACERBB            27D0
SPACERC             2814
SPACERCC            27D4
SPACERD             2818
SPACERDD            27D8
SPACERE             281C
SPACEREE            27DC
SPACERF             2820
SPACERFF            27E0
SRMEM_VAR           1650
SRREG_VAR           1688
SR_MEM              1EF2
SR_MEM_ADDS         2230
SR_MEM_L            225C
SR_MEM_VAR          1640
SR_MEM_W            224E
SR_REG              1F00
SR_REG_VAR          1648
START               1000
STA_ADDR            2753
STA_MSG             269E
W_ADD_CHAR          22E2
W_DN                1DC0
W_EA                1D84
W_H2A               22AC
W_IMD               21A4
W_ISO_DIG           22BA
W_LET               22DA
W_NUM               22D2
W_SIZE              1CEA
