00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/16/2017 6:35:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------JMP_TBL------------------------------
00000000                             9  * Purpose: JMP_TBL takes a data register input (D7) and navigates to the correct OPCODE table
00000000                            10  *          entry.
00000000                            11  *          $FF is saved to D6 if OPCode is determined to be incorrect
00000000                            12  * Assumption: Whenever JMP_TBL is called, D7 contains the next new machine code instruction
00000000                            13  *------------------------------------------------------------
00000000                            14  *============================================================
00000000                            15  *===================ID FIRST OPCODE DIGIT====================
00000000                            16  *============================================================
00000000  4282                      17  JMP_TBL     CLR.L       D2
00000002  3407                      18              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000004  4281                      19              CLR.L       D1
00000006  123C 000C                 20              MOVE.B      #12,D1      *Moves 12 into D1
0000000A  E26A                      21              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000000C                            22                          
0000000C  B43C 0000                 23  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00000010  6600 000A                 24              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00000014  4EB9 0000012C             25              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000001A  4E75                      26              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000001C                            27              
0000001C  B43C 0001                 28  JMP_1       CMP.B       #$1,D2
00000020  6600 000A                 29              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00000024  4EB9 00000164             30              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
0000002A  4E75                      31              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000002C                            32             
0000002C  B43C 0002                 33  JMP_2       CMP.B       #$2,D2
00000030  6600 000A                 34              BNE         JMP_3 
00000034  4EB9 00000158             35              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000003A  4E75                      36              RTS
0000003C                            37              
0000003C  B43C 0003                 38  JMP_3       CMP.B       #$3,D2
00000040  6600 000A                 39              BNE         JMP_4
00000044  4EB9 00000164             40              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
0000004A  4E75                      41              RTS
0000004C                            42           
0000004C  B43C 0004                 43  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
00000050  6600 000A                 44              BNE         JMP_5
00000054  4EB9 00000164             45              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
0000005A  4E75                      46              RTS
0000005C                            47              
0000005C  B43C 0005                 48  JMP_5       CMP.B       #$5,D2
00000060  6600 000A                 49              BNE         JMP_6
Line 50 ERROR: Undefined symbol
00000064  4EB9 004DBB8E             50              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
0000006A  4E75                      51              RTS
0000006C                            52              
0000006C  B43C 0006                 53  JMP_6       CMP.B       #$6,D2
00000070  6600 000A                 54              BNE         JMP_7
00000074  4EB9 00000164             55              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
0000007A  4E75                      56              RTS
0000007C                            57              
0000007C  B43C 0007                 58  JMP_7       CMP.B       #$7,D2
00000080  6600 000A                 59              BNE         JMP_8
Line 60 ERROR: Undefined symbol
00000084  4EB9 004DBB8E             60              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
0000008A  4E75                      61              RTS
0000008C                            62              
0000008C  B43C 0008                 63  JMP_8       CMP.B       #$8,D2
00000090  6600 000A                 64              BNE         JMP_9
00000094  4EB9 00000164             65              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
0000009A  4E75                      66              RTS
0000009C                            67              
0000009C  B43C 0009                 68  JMP_9       CMP.B       #$9,D2
000000A0  6600 000A                 69              BNE         JMP_A
Line 70 ERROR: Undefined symbol
000000A4  4EB9 004DBB8E             70              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000000AA  4E75                      71              RTS
000000AC                            72              
000000AC  B43C 000A                 73  JMP_A       CMP.B       #$A,D2
000000B0  6600 000A                 74              BNE         JMP_B
000000B4  4EB9 00000186             75              JSR         INVALID     *0xA is an invalid first hex digit. Jump to INVALID
000000BA  4E75                      76              RTS
000000BC                            77              
000000BC  B43C 000B                 78  JMP_B       CMP.B       #$B,D2
000000C0  6600 000A                 79              BNE         JMP_C
000000C4  4EB9 00000186             80              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000000CA  4E75                      81              RTS
000000CC                            82              
000000CC  B43C 000C                 83  JMP_C       CMP.B       #$C,D2
000000D0  6600 000A                 84              BNE         JMP_D
000000D4  4EB9 00000164             85              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000000DA  4E75                      86              RTS
000000DC                            87              
000000DC  B43C 000D                 88  JMP_D       CMP.B       #$D,D2
000000E0  6600 000A                 89              BNE         JMP_E   
000000E4  4EB9 00000164             90              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000000EA  4E75                      91              RTS
000000EC                            92              
000000EC  B43C 000F                 93  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
000000F0  6700 0094                 94              BEQ         INVALID     *If first hex value is F, jump to INVALID
000000F4  4EB9 00000164             95              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
000000FA  4E75                      96              RTS
000000FC                            97   
000000FC                            98  *============================================================
000000FC                            99  *==================ID SECOND OPCODE DIGIT====================
000000FC                           100  *============================================================
000000FC                           101  
000000FC                           102  * J_CLR4 prepares the data registers for data manipulation on the second input hex digit by isolating the next 4 bits:
000000FC                           103  * %0000 XXXX 0000 0000 0000
000000FC  4282                     104  J_CLR4      CLR.L       D2                                
000000FE  3407                     105              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000100  4281                     106              CLR.L       D1
00000102  E94A                     107              LSL.W       #4,D2       *Clear the most sig hex digit
00000104  123C 000C                108              MOVE.B      #12,D1      *Moves 12 into D1
00000108  E26A                     109              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
0000010A  4E75                     110              RTS                     *Return back to JMP_Xn    
0000010C                           111              
0000010C                           112  * J_CLR3 prepares the data registers for data manipulation on the second input hex digit by isolating the next 3 bits:
0000010C                           113  * %0000 XXX0 0000 0000 0000          
0000010C  4282                     114  J_CLR3      CLR.L       D2          
0000010E  3407                     115              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000110  4281                     116              CLR.L       D1
00000112  E94A                     117              LSL.W       #4,D2       *Clear the most sig hex digit
00000114  123C 000D                118              MOVE.B      #13,D1      *Moves 13 into D1
00000118  E26A                     119              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000011A  4E75                     120              RTS                     *Return back to JMP_Xn  
0000011C                           121  
0000011C                           122  * J_CLR_DM prepares the data registers for data manipulation on the second input hex digit by isolating the DESTINATION MODE bits:
0000011C                           123  * %0000 000X XX00 0000 0000          
0000011C  4282                     124  J_CLR_DM    CLR.L       D2          
0000011E  3407                     125              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000120  4281                     126              CLR.L       D1
00000122  EF4A                     127              LSL.W       #7,D2       *Clear the most sig 7 bits
00000124  123C 0011                128              MOVE.B      #17,D1      *Moves 17 into D1
00000128  E26A                     129              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
0000012A  4E75                     130              RTS                     *Return back to JMP_Xn     
0000012C                           131           
0000012C                           132  *---------------------SUBI, ADDI-----------------------------
0000012C  4EB8 00FC                133  JMP_0X      JSR         J_CLR4      *Prepare data registers for data manipulation on the second input hex digit
00000130  B43C 0004                134              CMP.B       #$4,D2      *Is the next hex digit 4?
00000134  6700 0012                135              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00000138  B43C 0005                136              CMP.B       #$5,D2      *Is the next hex digit 5?
Line 137 ERROR: Undefined symbol
0000013C  6700 BA50                137              BEQ         J_OADDI     *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
00000140  4EB9 00000186            138              JSR         INVALID     *If neither, OPCODE is invalid
00000146  4E75                     139              RTS
00000148                           140  
Line 141 ERROR: Undefined symbol
00000148  4EB9 004DBB8E            141  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
0000014E  4E75                     142              RTS
00000150                           143              
Line 144 ERROR: Undefined symbol
00000150  4EB9 004DBB8E            144  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
00000156  4E75                     145              RTS              
00000158                           146  
00000158                           147  * Possible instructions at JMP_2X are: MOVE.L, MOVEA.L
00000158  4EB8 011C                148  JMP_2X      JSR         J_CLR_DM    *Prepare data registers for data manipulation on the DEST MODE digits
0000015C  B43C 0001                149              CMP.B       #$1,D2      *is the DEST MODE 1?
00000160  6700 0002                150              BEQ         J_MOVEAL    *Instruction is determiend to be MOVEA.L                                     ================= < stopped at this point
00000164                           151               
00000164                           152  JMP_3X
00000164                           153  
00000164                           154  JMP_4X
00000164                           155  
00000164                           156  JMP_6X
00000164                           157  
00000164                           158  JMP_8X
00000164                           159  
00000164                           160  JMP_CX
00000164                           161  
00000164                           162  JMP_DX
00000164                           163  
00000164                           164  JMP_EX
00000164                           165  
00000164                           166  
00000164                           167  
00000164                           168  *============================================================
00000164                           169  *==================OPCODE KNOWN, PRINTING====================
00000164                           170  *============================================================
00000164                           171  
00000164                           172  J_MOVEL     
00000164                           173  
00000164                           174  J_MOVEAL
00000164                           175  
00000164                           176  
00000164                           177  *--------------------MOVE.B OPCODE---------------------------
00000164  18FC 004D                178  OPC_1XXX    MOVE.B      #'M',(A4)+
00000168  18FC 004F                179              MOVE.B      #'O',(A4)+
0000016C  18FC 0056                180              MOVE.B      #'V',(A4)+
00000170  18FC 0045                181              MOVE.B      #'E',(A4)+
00000174  18FC 002E                182              MOVE.B      #'.',(A4)+
00000178  18FC 0042                183              MOVE.B      #'B',(A4)+
0000017C  18FC 0020                184              MOVE.B      #' ',(A4)+
00000180  18FC 0020                185              MOVE.B      #' ',(A4)+
00000184                           186              *JUMP to EACODE table
00000184  4E75                     187              RTS
00000186                           188  
00000186                           189  
00000186                           190  
00000186                           191  *-----------------------INVALID------------------------------
00000186                           192  * Invalid OPCODES jump here.
00000186                           193  * $FF is moved into Data Register 6, which indicates to the program that the input is invalid.
00000186                           194  *------------------------------------------------------------        
00000186  1C38 00FF                195  INVALID     MOVE.B      $FF,D6      *Invalid input flag
0000018A  4E75                     196              RTS
0000018C                           197  
Line 198 WARNING: END directive missing, starting address not set

6 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
INVALID             186
JMP_0               C
JMP_0X              12C
JMP_1               1C
JMP_2               2C
JMP_2X              158
JMP_3               3C
JMP_3X              164
JMP_4               4C
JMP_4X              164
JMP_5               5C
JMP_6               6C
JMP_6X              164
JMP_7               7C
JMP_8               8C
JMP_8X              164
JMP_9               9C
JMP_A               AC
JMP_B               BC
JMP_C               CC
JMP_CX              164
JMP_D               DC
JMP_DX              164
JMP_E               EC
JMP_EX              164
JMP_TBL             0
J_ADDI              150
J_CLR3              10C
J_CLR4              FC
J_CLR_DM            11C
J_MOVEAL            164
J_MOVEL             164
J_SUBI              148
OPC_1XXX            164
