00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/23/2017 6:19:28 PM

00000000                             1  ************************************************************
00000000                             2  * TEAM NEVERY LUCKY DISSASSEMBLER
00000000                             3  * This file includes OPCODE logic (OPCODE and size decoding)
00000000                             4  ************************************************************
00000000                             5  
00000000                             6  *============================================================
00000000                             7  *===================ID FIRST OPCODE DIGIT====================
00000000                             8  *============================================================
00000000                             9  
00000000                            10  *-----------------------JMP_TBL------------------------------
00000000                            11  * Purpose: JMP_TBL takes a data register input (D7) and navigates to the correct OPCODE table
00000000                            12  *          entry.
00000000                            13  *          $FF is saved to D6 if OPCode is determined to be incorrect
00000000                            14  * Assumption: Whenever JMP_TBL is called, D7 contains the next new machine code instruction
00000000                            15  *------------------------------------------------------------
00000000  4282                      16  JMP_TBL     CLR.L       D2
00000002  3407                      17              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000004  4281                      18              CLR.L       D1
00000006  123C 000C                 19              MOVE.B      #12,D1      *Moves 12 into D1
0000000A  E26A                      20              LSR.W       D1,D2       *Shifts 12 bits so the remaining contents = the left 4 bits of D7
0000000C                            21                          
0000000C  B43C 0000                 22  JMP_0       CMP.B       #$0,D2      *Following section determines what hex value the first 4 digits are
00000010  6600 000A                 23              BNE         JMP_1       *If the first hex value is not 0, branch and see if its 1
00000014  4EB9 0000013C             24              JSR         JMP_0X      *If the first hex value is 0, jump to JMP_0X to determine the next set of digits
0000001A  4E75                      25              RTS                     *Finished all jumping; whole instruction should be identified at this point
0000001C                            26              
0000001C  B43C 0001                 27  JMP_1       CMP.B       #$1,D2
00000020  6600 000A                 28              BNE         JMP_2       *If the first hex value is not 2, branch and see if its 3, and so on
00000024  4EB9 0000021A             29              JSR         OPC_1XXX    *If the first hex value is 1, the instruction is determined to be MOVE.B. Jump to OPC_1XXX in OPCODE table.
0000002A  4E75                      30              RTS                     *Finished all jumping; whole instruction should be identified at this point, and so on       
0000002C                            31             
0000002C  B43C 0002                 32  JMP_2       CMP.B       #$2,D2
00000030  6600 000A                 33              BNE         JMP_3 
00000034  4EB9 00000168             34              JSR         JMP_2X      *If the first hex value is 2, jump to JMP_2X to determine the next set of digits
0000003A  4E75                      35              RTS
0000003C                            36              
0000003C  B43C 0003                 37  JMP_3       CMP.B       #$3,D2
00000040  6600 000A                 38              BNE         JMP_4
00000044  4EB9 0000018C             39              JSR         JMP_3X      *If the first hex value is 3, jump to JMP_3X to determine the next set of digits
0000004A  4E75                      40              RTS
0000004C                            41           
0000004C  B43C 0004                 42  JMP_4       CMP.B       #$4,D2      *Where NOP SHOULD LAND
00000050  6600 000A                 43              BNE         JMP_5
00000054  4EB9 000001B0             44              JSR         JMP_4X      *If the first hex value is 4, jump to JMP_4X to determine the next set of digits
0000005A  4E75                      45              RTS
0000005C                            46              
0000005C  B43C 0005                 47  JMP_5       CMP.B       #$5,D2
00000060  6600 000A                 48              BNE         JMP_6
00000064  4EB9 00000244             49              JSR         OPC_5XXX    *If the first hex digit is 5, the instruction is determined to be ADDQ. Jump to OPC_5XXX in OPCODE table.
0000006A  4E75                      50              RTS
0000006C                            51              
0000006C  B43C 0006                 52  JMP_6       CMP.B       #$6,D2
00000070  6600 000A                 53              BNE         JMP_7
00000074  4EB9 000001F0             54              JSR         JMP_6X      *If the first hex value is 6, jump to JMP_6X to determine the next set of digits
0000007A  4E75                      55              RTS
0000007C                            56              
0000007C  B43C 0007                 57  JMP_7       CMP.B       #$7,D2
00000080  6600 000A                 58              BNE         JMP_8
00000084  4EB9 0000026C             59              JSR         OPC_7XXX    *If the first hex digit is 7, the instruction is determined to be MOVEQ. Jump to OPC_7XXX in OPCODE table.
0000008A  4E75                      60              RTS
0000008C                            61              
0000008C  B43C 0008                 62  JMP_8       CMP.B       #$8,D2
00000090  6600 000A                 63              BNE         JMP_9
00000094  4EB9 000001F6             64              JSR         JMP_8X      *If the first hex value is 8, jump to JMP_8X to determine the next set of digits
0000009A  4E75                      65              RTS
0000009C                            66              
0000009C  B43C 0009                 67  JMP_9       CMP.B       #$9,D2
000000A0  6600 000A                 68              BNE         JMP_A
000000A4  4EB9 00000290             69              JSR         OPC_9XXX    *If the first hex digit is 9, the instruction is determined to be SUB. Jump to OPC_9XXX in OPCODE table.
000000AA  4E75                      70              RTS
000000AC                            71              
000000AC  B43C 000A                 72  JMP_A       CMP.B       #$A,D2
000000B0  6600 000A                 73              BNE         JMP_B
Line 74 ERROR: Undefined symbol
000000B4  4EB9 004DBB8E             74              JSR         INVALID     *0x A is an invalid first hex digit. Jump to INVALID
000000BA  4E75                      75              RTS
000000BC                            76              
000000BC  B43C 000B                 77  JMP_B       CMP.B       #$B,D2
000000C0  6600 000A                 78              BNE         JMP_C
Line 79 ERROR: Undefined symbol
000000C4  4EB9 004DBB8E             79              JSR         INVALID     *0xB is an invalid first hex digit. Jump to INVALID
000000CA  4E75                      80              RTS
000000CC                            81              
000000CC  B43C 000C                 82  JMP_C       CMP.B       #$C,D2
000000D0  6600 000A                 83              BNE         JMP_D
000000D4  4EB9 000001FC             84              JSR         JMP_CX      *If the first hex value is C, jump to JMP_CX to determine the next set of digits
000000DA  4E75                      85              RTS
000000DC                            86              
000000DC  B43C 000D                 87  JMP_D       CMP.B       #$D,D2
000000E0  6600 000A                 88              BNE         JMP_E   
000000E4  4EB9 00000202             89              JSR         JMP_DX      *If the first hex value is D, jump to JMP_DX to determine the next set of digits
000000EA  4E75                      90              RTS
000000EC                            91              
000000EC  B43C 000F                 92  JMP_E       CMP.B       #$F,D2      *If first hex value is not 0-D, it must be E(valid) or F(invalid)
Line 93 ERROR: Undefined symbol
000000F0  6700 BA9C                 93              BEQ         INVALID     *If first hex value is F, jump to INVALID
000000F4  4EB9 00000208             94              JSR         JMP_EX      *If the first hex value is E, jump to JMP_EX to determine the next set of digits
000000FA  4E75                      95              RTS
000000FC                            96   
000000FC                            97  *============================================================
000000FC                            98  *==================ID SECOND OPCODE DIGIT====================
000000FC                            99  *============================================================
000000FC                           100  *------------------ Helper functions ------------------------
000000FC                           101  * J_CLR4 prepares the data registers for data manipulation on the second input hex digit by isolating the next 4 bits:
000000FC                           102  * %0000 XXXX 0000 0000
000000FC  4282                     103  J_CLR4      CLR.L       D2                                
000000FE  3407                     104              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000100  4281                     105              CLR.L       D1
00000102  E94A                     106              LSL.W       #4,D2       *Clear the most sig hex digit
00000104  123C 000C                107              MOVE.B      #12,D1      *Moves 12 into D1
00000108  E26A                     108              LSR.W       D1,D2       *Shifts 12 right to isolate the bits we're working with
0000010A  4E75                     109              RTS                     *Return back to JMP_Xn    
0000010C                           110              
0000010C                           111  * J_CLR3 prepares the data registers for data manipulation by isolating the next 3 bits:
0000010C                           112  * %0000 XXX0 0000 0000 0000          
0000010C  4282                     113  J_CLR3      CLR.L       D2          
0000010E  3407                     114              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000110  4281                     115              CLR.L       D1
00000112  E94A                     116              LSL.W       #4,D2       *Clear the most sig hex digit
00000114  123C 000D                117              MOVE.B      #13,D1      *Moves 13 into D1
00000118  E26A                     118              LSR.W       D1,D2       *Shifts 13 right to isolate the bits we're working with 
0000011A  4E75                     119              RTS                     *Return back to JMP_Xn  
0000011C                           120  
0000011C                           121  * J_CLR1 prepares the data registers for data manipulation by isolating the rightmost bit of the second hex dig:
0000011C                           122  * %0000 000X 0000 0000 0000                   
0000011C  4282                     123  J_CLR1  CLR.L       D2          
0000011E  3407                     124          MOVE.W      D7,D2           *Copies D7 contents to D2 for manipulation
00000120  4281                     125          CLR.L       D1
00000122  EF4A                     126          LSL.W       #7,D2           *Clear the most sig 7 bits
00000124  123C 0010                127          MOVE.B      #16,D1          *Moves 16 into D1
00000128  E26A                     128          LSR.W       D1,D2           *Shifts 16 right to isolate the bit we're working with 
0000012A  4E75                     129          RTS                         *Return back to JMP_Xn  
0000012C                           130       
0000012C                           131  * J_CLR_DM prepares the data registers for data manipulation by isolating the DESTINATION MODE bits:
0000012C                           132  * %0000 000X XX00 0000 0000          
0000012C  4282                     133  J_CLR_DM    CLR.L       D2          
0000012E  3407                     134              MOVE.W      D7,D2       *Copies D7 contents to D2 for manipulation
00000130  4281                     135              CLR.L       D1
00000132  EF4A                     136              LSL.W       #7,D2       *Clear the most sig 7 bits
00000134  123C 0011                137              MOVE.B      #17,D1      *Moves 17 into D1
00000138  E26A                     138              LSR.W       D1,D2       *Shifts 17 right to isolate the bits we're working with 
0000013A  4E75                     139              RTS                     *Return back to JMP_Xn     
0000013C                           140   
0000013C                           141  *---------------End Helper functions ------------------------
0000013C                           142  
0000013C                           143          
0000013C                           144  *---------------------SUBI, ADDI-----------------------------
0000013C  4EB8 00FC                145  JMP_0X      JSR         J_CLR4      *Isolate next hex digit
00000140  B43C 0004                146              CMP.B       #$4,D2      *Is the next hex digit 4?
00000144  6700 0012                147              BEQ         J_SUBI      *Instruction is determined to be SUBI. Jump to intermediate OPCODE table jump
00000148  B43C 0005                148              CMP.B       #$5,D2      *Is the next hex digit 5?
0000014C  6700 0012                149              BEQ         J_ADDI      *Instruction is determined to be ADDI. Jump to intermediate OPCODE table jump
Line 150 ERROR: Undefined symbol
00000150  4EB9 004DBB8E            150              JSR         INVALID     *If neither, OPCODE is invalid
00000156  4E75                     151              RTS
00000158                           152  
00000158  4EB9 0000020E            153  J_SUBI      JSR         OPC_04XX    *Jump to OPC_04XX in OPCODE table
0000015E  4E75                     154              RTS
00000160                           155              
00000160  4EB9 00000214            156  J_ADDI      JSR         OPC_05XX    *Jump to OPC_05XX in OPCODE table
00000166  4E75                     157              RTS              
00000168                           158  
00000168                           159  *---------------------MOVE.L, MOVEA.L----------------------------- NOTE - NO INVALID CASE. Probably correct tho-
00000168  4EB8 012C                160  JMP_2X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
0000016C  B43C 0001                161              CMP.B       #$1,D2      *is the DEST MODE 1?
00000170  6700 000A                162              BEQ         J_MOVEAL    *Instruction is determined to be MOVEA.L Jump to intermediate OPCODE table jump
00000174  4EB9 00000184            163              JSR         J_MOVEL     *Otherwise, Instruction is determined to be MOVE.L Jump to intermediate OPCODE table jump
0000017A  4E75                     164              RTS
0000017C                           165  
0000017C  4EB9 000002B2            166  J_MOVEAL    JSR         OPC_MOVEAL  *Jump to OPC_MOVEAL in OPCODE table
00000182  4E75                     167              RTS
00000184                           168  
00000184  4EB9 000002B4            169  J_MOVEL     JSR         OPC_MOVEL   *Jump to OPC_MOVEL in OPCODE table   
0000018A  4E75                     170              RTS                           
0000018C                           171  *---------------------MOVE.W, MOVEA.W----------------------------- NOTE - NO INVALID CASE. Probably correct tho-             
0000018C  4EB8 012C                172  JMP_3X      JSR         J_CLR_DM    *Isolate the destination mode bits %0000 000X XX00 0000 0000  
00000190  B43C 0001                173              CMP.B       #$1,D2      *is the DEST MODE 1?
00000194  6700 000A                174              BEQ         J_MOVEAW    *Instruction is determined to be MOVEA.W Jump to intermediate OPCODE table jump
00000198  4EB9 000001A8            175              JSR         J_MOVEW     *Otherwise, Instruction is determined to be MOVE.W Jump to intermediate OPCODE table jump
0000019E  4E75                     176              RTS
000001A0                           177  
000001A0  4EB9 000002B6            178  J_MOVEAW    JSR         OPC_MOVEAW  *Jump to OPC_MOVEAW in OPCODE table
000001A6  4E75                     179              RTS
000001A8                           180  
000001A8  4EB9 000002B8            181  J_MOVEW     JSR         OPC_MOVEW   *Jump to OPC_MOVEW in OPCODE table 
000001AE  4E75                     182              RTS
000001B0                           183  *-----------------NOP, MOVEM, LEA, JSR, RTS-----------------------
000001B0  4EB8 00FC                184  JMP_4X      JSR         J_CLR4      *Isolate next hex digit   
000001B4  B43C 0007                185              CMP.B       #7,D2       *Is the next hex digit 7?
000001B8  6700 001E                186              BEQ         J_47X       *Instruction is determined to be NOP, JSR, or RTS. Jump to JMP_47X to determine.
000001BC  4EB8 011C                187              JSR         J_CLR1      *Otherwise, isolate the %0000 000X 0000 0000 digit
000001C0  B43C 0001                188              CMP.B       #1,D2       *Is the last bit 1?
000001C4  6700 001A                189              BEQ         J_LEA       *Instruction is determined to be LEA. Jump to intermediate OPCODE table jump 
000001C8  B43C 0000                190              CMP.B       #0,D2       *Is the last bit 0?
000001CC  6700 001A                191              BEQ         J_MOVEM     *Instruction is determined to be MOVEM. Jump to intermediate OPCODE table jump 
Line 192 ERROR: Undefined symbol
000001D0  4EB9 004DBB8E            192              JSR         INVALID     *If none of the above, OPCODE is invalid
000001D6  4E75                     193              RTS
000001D8                           194                                           
000001D8                           195              
000001D8  4EB9 0000021A            196  J_47X       JSR         JMP_47X     *Instruction is NOP, JSR, or RTS. Jump to JMP_47X to determine.
000001DE  4E75                     197              RTS
000001E0                           198              
000001E0  4EB9 000002AE            199  J_LEA       JSR         OPC_LEA     *Jump to OPC_LEA in the OPCODE table    
000001E6  4E75                     200              RTS
000001E8                           201              
000001E8  4EB9 000002B0            202  J_MOVEM     JSR         OPC_MOVEM   *Jump to OPC_MOVEM in the OPCODE table
000001EE  4E75                     203              RTS
000001F0                           204              
000001F0                           205  
Line 206 ERROR: Undefined symbol
000001F0  4EB9 004DBB8E            206  JMP_6X      JSR         INVALID     *Temp, remove once implemented
000001F6                           207  
Line 208 ERROR: Undefined symbol
000001F6  4EB9 004DBB8E            208  JMP_8X      JSR         INVALID     *Temp, remove once implemented
000001FC                           209  
Line 210 ERROR: Undefined symbol
000001FC  4EB9 004DBB8E            210  JMP_CX      JSR         INVALID     *Temp, remove once implemented
00000202                           211  
Line 212 ERROR: Undefined symbol
00000202  4EB9 004DBB8E            212  JMP_DX      JSR         INVALID     *Temp, remove once implemented
00000208                           213  
Line 214 ERROR: Undefined symbol
00000208  4EB9 004DBB8E            214  JMP_EX      JSR         INVALID     *Temp, remove once implemented
0000020E                           215  
0000020E                           216  *============================================================
0000020E                           217  *==================ID THIRD OPCODE DIGIT=====================
0000020E                           218  *============================================================
0000020E                           219     
Line 220 ERROR: Undefined symbol
0000020E  4EB9 004DBB8E            220  OPC_04XX    JSR         INVALID     *Temp, remove once implemented
00000214                           221  
Line 222 ERROR: Undefined symbol
00000214  4EB9 004DBB8E            222  OPC_05XX    JSR         INVALID     *Temp, remove once implemented
0000021A                           223  
0000021A                           224  JMP_47X      
0000021A                           225  *============================================================
0000021A                           226  *==================OPCODE KNOWN, PRINTING====================
0000021A                           227  *============================================================
0000021A                           228  
0000021A                           229  
0000021A                           230  
0000021A                           231  *--------------------MOVE.B OPCODE---------------------------
0000021A  18FC 004D                232  OPC_1XXX    MOVE.B      #'M',(A4)+
0000021E  18FC 004F                233              MOVE.B      #'O',(A4)+
00000222  18FC 0056                234              MOVE.B      #'V',(A4)+
00000226  18FC 0045                235              MOVE.B      #'E',(A4)+
0000022A  18FC 002E                236              MOVE.B      #'.',(A4)+
0000022E  18FC 0042                237              MOVE.B      #'B',(A4)+
00000232  18FC 0020                238              MOVE.B      #' ',(A4)+
00000236  18FC 0020                239              MOVE.B      #' ',(A4)+
0000023A                           240              *YOU DO NOT NEED TO MANUALLY SET SIZE CODE IF YOU USE A
0000023A                           241              *GET SIZE SUBROUTINE CALL.
0000023A  4284                     242              CLR.L       D4          *Manually set size to byte (D4 = 0)
Line 243 ERROR: Undefined symbol
0000023C  4EB9 004DBB8E            243              JSR         MOV_EA_CODE *JUMP to EACODE table for MOVE/MOVEA
00000242  4E75                     244              RTS
00000244                           245  
00000244                           246  *--------------------ADDQ OPCODE----------------------------
00000244  18FC 0041                247  OPC_5XXX    MOVE.B      #'A',(A4)+
00000248  18FC 0044                248              MOVE.B      #'D',(A4)+
0000024C  18FC 0044                249              MOVE.B      #'D',(A4)+
00000250  18FC 0051                250              MOVE.B      #'Q',(A4)+
00000254  18FC 002E                251              MOVE.B      #'.',(A4)+
00000258                           252              *NEED to Determine sizes here
00000258  4EB9 0000030C            253              JSR         GET_SIZE_2   *Get size code (placed in D4)
0000025E  4EB9 000002BA            254              JSR         ADD_SIZE     *Add size character to string (B/W/L)
Line 255 ERROR: Undefined symbol
00000264  4EB9 004DBB8E            255              JSR         ADDQ_EA      *Start the EA/operand decode logic
0000026A                           256              
0000026A                           257              *JUMP to EACODE table
0000026A  4E75                     258              RTS
0000026C                           259  
0000026C                           260  *------------------MOVEQ OPCODE-----------------------------
0000026C  18FC 004D                261  OPC_7XXX    MOVE.B      #'M',(A4)+
00000270  18FC 004F                262              MOVE.B      #'O',(A4)+
00000274  18FC 0056                263              MOVE.B      #'V',(A4)+
00000278  18FC 0045                264              MOVE.B      #'E',(A4)+
0000027C  18FC 0051                265              MOVE.B      #'Q',(A4)+
00000280  18FC 002E                266              MOVE.B      #'.',(A4)+
00000284  18FC 004C                267              MOVE.B      #'L',(A4)+
00000288                           268              
Line 269 ERROR: Undefined symbol
00000288  4EB9 004DBB8E            269              JSR         MOVEQ_EA     *Start the EA/opderand decode logic for moveq
0000028E                           270              
0000028E                           271              *Needs special EA decode logic
0000028E                           272              *jump to EACODE table
0000028E  4E75                     273              RTS
00000290                           274  
00000290                           275  *------------------SUB OPCODE-------------------------------
00000290  18FC 0053                276  OPC_9XXX    MOVE.B      #'S',(A4)+
00000294  18FC 0055                277              MOVE.B      #'U',(A4)+
00000298  18FC 0042                278              MOVE.B      #'B',(A4)+
0000029C  18FC 002E                279              MOVE.B      #'.',(A4)+
000002A0                           280              *NEED to Determine sizes here (opmode 3 bits)
000002A0  4EB9 000002FC            281              JSR         GET_SIZE_3  * Size bits will be in D4 after this statement
000002A6  4EB9 00000332            282              JSR         OR_ADD_SIZE    * This will add size characters and start operand decode sequence
000002AC                           283              *jump to EACODE table
000002AC  4E75                     284              RTS
000002AE                           285  
000002AE                           286  *------------------LEA OPCODE-------------------------------            
000002AE  4E75                     287  OPC_LEA     RTS
000002B0                           288  
000002B0                           289  
000002B0                           290  *------------------MOVEM OPCODE----------------------------- 
000002B0  4E75                     291  OPC_MOVEM   RTS
000002B2                           292  
000002B2                           293  *------------------MOVEA.L OPCODE----------------------------
000002B2  4E75                     294  OPC_MOVEAL  RTS
000002B4                           295  
000002B4                           296  *------------------MOVEM.L OPCODE----------------------------
000002B4  4E75                     297  OPC_MOVEL   RTS
000002B6                           298  
000002B6                           299  *------------------MOVEA.W OPCODE----------------------------
000002B6  4E75                     300  OPC_MOVEAW RTS
000002B8                           301  
000002B8                           302  *------------------MOVE.W OPCODE----------------------------
000002B8  4E75                     303  OPC_MOVEW  RTS
000002BA                           304  
000002BA                           305  *===========================================================
000002BA                           306  *=====================HELPER SUBROUTINES====================
000002BA                           307  *===========================================================
000002BA                           308  
000002BA                           309  *--------------------ADD SIZE-------------------------------
000002BA                           310  * A simple helper that looks at the size code in D4 to add
000002BA                           311  * the appropriate B,W,L to the string.
000002BA                           312  *-----------------------------------------------------------
000002BA  B83C 0000                313  ADD_SIZE    CMP.B       #0,D4       *Is it a B, <ea>,dn
000002BE  6700 0012                314              BEQ         B_SIZE
000002C2  B83C 0001                315              CMP.B       #1,D4       *Is it a W, <ea>,dn
000002C6  6700 0018                316              BEQ         W_SIZE
000002CA  B83C 0002                317              CMP.B       #2,D4       *Is it a L, <ea>,dn
000002CE  6700 001E                318              BEQ         L_SIZE 
000002D2                           319              
000002D2  18FC 0042                320  B_SIZE      MOVE.B      #'B',(A4)+  *Add size character to good string
000002D6  18FC 0020                321              MOVE.B      #' ',(A4)+
000002DA  18FC 0020                322              MOVE.B      #' ',(A4)+
000002DE  4E75                     323              RTS
000002E0                           324  
000002E0  18FC 0057                325  W_SIZE      MOVE.B      #'W',(A4)+  *Add size character to good string
000002E4  18FC 0020                326              MOVE.B      #' ',(A4)+
000002E8  18FC 0020                327              MOVE.B      #' ',(A4)+
000002EC  4E75                     328              RTS
000002EE                           329  
000002EE  18FC 004C                330  L_SIZE      MOVE.B      #'L',(A4)+  *Add size character to good string
000002F2  18FC 0020                331              MOVE.B      #' ',(A4)+
000002F6  18FC 0020                332              MOVE.B      #' ',(A4)+
000002FA  4E75                     333              RTS
000002FC                           334  
000002FC                           335  *--------------------GET SIZE CODE--------------------------
000002FC                           336  * The following three subroutines isolate the size bits for
000002FC                           337  * all opcodes. They are by number of bits (e.g. 3 bits for
000002FC                           338  * size implies GET_SIZE_3)
000002FC                           339  *-----------------------------------------------------------
000002FC  4284                     340  GET_SIZE_3  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
000002FE  3807                     341              MOVE.W      D7,D4       *Copy untouched opcode into D4
00000300  EF4C                     342              LSL.W       #7,D4       *Clear more significant bits
00000302  4283                     343              CLR.L       D3          *Make sure D3 is clear for shifting
00000304  163C 000D                344              MOVE.B      #13,D3      *Shifting 13 times
00000308  E66C                     345              LSR.W       D3,D4       *Move size bits to LSB position
0000030A  4E75                     346              RTS
0000030C                           347  
0000030C  4284                     348  GET_SIZE_2  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
0000030E  3807                     349              MOVE.W      D7,D4       *Copy untouched opcode into D4
00000310  E14C                     350              LSL.W       #8,D4       *Clear more significant bits
00000312  4283                     351              CLR.L       D3          *Make sure D3 is clear for shifting
00000314  163C 000E                352              MOVE.B      #14,D3      *Shifting 14 times
00000318  E66C                     353              LSR.W       D3,D4       *Move size bits to LSB position
0000031A  4E75                     354              RTS
0000031C                           355  
0000031C  4284                     356  GET_SIZE_1  CLR.L       D4          *Make sure D4 is clear to isolate size bits.
0000031E  3807                     357              MOVE.W      D7,D4       *Copy untouched opcode into D4
00000320  4283                     358              CLR.L       D3          *Make sure D3 is clear for shifting
00000322  163C 0009                359              MOVE.B      #9,D3       *Shift 9 times to the left
00000326  E76C                     360              LSL.W       D3,D4       *Clear more significant bits
00000328  4283                     361              CLR.L       D3          *Make sure D3 is clear for shifting
0000032A  163C 000F                362              MOVE.B      #15,D3      *Shifting 15 times
0000032E  E66C                     363              LSR.W       D3,D4       *Move size bits to LSB position
00000330  4E75                     364              RTS
00000332                           365  
00000332                           366  *--------------------ADD SIZE (Pseudo JMP TABLE)------------
00000332                           367  * This subroutine is for ADD, AND, OR, SUB.
00000332                           368  * It adds the appropriate "B", "W", "L" and space characters
00000332                           369  * to the output strings. It then starts the parameter decode
00000332                           370  * sequence for the above 4 subroutines.
00000332                           371  * Values 0, 1, 2 => B, W, L => <ea>,Dn => JSR EA_SRC
00000332                           372  * Values 4, 5, 6 => B, W, L => Dn,<ea> => JSR DN_SRC
00000332                           373  *-----------------------------------------------------------
00000332  B83C 0000                374  OR_ADD_SIZE CMP.B       #0,D4       *Is it a B, <ea>,dn
00000336  6700 002E                375              BEQ         B_EA
0000033A  B83C 0001                376              CMP.B       #1,D4       *Is it a W, <ea>,dn
0000033E  6700 003A                377              BEQ         W_EA
00000342  B83C 0002                378              CMP.B       #2,D4       *Is it a L, <ea>,dn
00000346  6700 0046                379              BEQ         L_EA
0000034A                           380  
0000034A  B83C 0004                381              CMP.B       #4,D4       *Is it a B, dn,<ea>
0000034E  6700 0052                382              BEQ         B_DN
00000352  B83C 0005                383              CMP.B       #5,D4       *Is it a W, dn,<ea>
00000356  6700 005E                384              BEQ         W_DN
0000035A  B83C 0006                385              CMP.B       #6,D4       *Is it a L, dn,<ea>
0000035E  6700 006A                386              BEQ         L_DN        
Line 387 ERROR: Undefined symbol
00000362  6000 B82A                387              BRA         INVALID     *Got here, must be invalid data.
00000366                           388              
00000366  18FC 0042                389  B_EA        MOVE.B      #'B',(A4)+  *Add size character to good string
0000036A  18FC 0020                390              MOVE.B      #' ',(A4)+
0000036E  18FC 0020                391              MOVE.B      #' ',(A4)+
Line 392 ERROR: Undefined symbol
00000372  4EB9 004DBB8E            392              JSR         EA_SRC_DDES *Move to EA_SRC to start parameter decode sequence
00000378  4E75                     393              RTS
0000037A                           394  
0000037A  18FC 0057                395  W_EA        MOVE.B      #'W',(A4)+  *Add size character to good string
0000037E  18FC 0020                396              MOVE.B      #' ',(A4)+
00000382  18FC 0020                397              MOVE.B      #' ',(A4)+
Line 398 ERROR: Undefined symbol
00000386  4EB9 004DBB8E            398              JSR         EA_SRC_DDES *Move to EA_SRC to start parameter decode sequence
0000038C  4E75                     399              RTS
0000038E                           400  
0000038E  18FC 004C                401  L_EA        MOVE.B      #'L',(A4)+  *Add size character to good string
00000392  18FC 0020                402              MOVE.B      #' ',(A4)+
00000396  18FC 0020                403              MOVE.B      #' ',(A4)+
Line 404 ERROR: Undefined symbol
0000039A  4EB9 004DBB8E            404              JSR         EA_SRC_DDES *Move to EA_SRC to start parameter decode sequence
000003A0  4E75                     405              RTS
000003A2                           406  
000003A2  18FC 0042                407  B_DN        MOVE.B      #'B',(A4)+  *Add size character to good string
000003A6  18FC 0020                408              MOVE.B      #' ',(A4)+
000003AA  18FC 0020                409              MOVE.B      #' ',(A4)+
Line 410 ERROR: Undefined symbol
000003AE  4EB9 004DBB8E            410              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000003B4  4E75                     411              RTS
000003B6                           412  
000003B6  18FC 0057                413  W_DN        MOVE.B      #'W',(A4)+  *Add size character to good string
000003BA  18FC 0020                414              MOVE.B      #' ',(A4)+
000003BE  18FC 0020                415              MOVE.B      #' ',(A4)+
Line 416 ERROR: Undefined symbol
000003C2  4EB9 004DBB8E            416              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000003C8  4E75                     417              RTS
000003CA                           418  
000003CA  18FC 004C                419  L_DN        MOVE.B      #'L',(A4)+  *Add size character to good string
000003CE  18FC 0020                420              MOVE.B      #' ',(A4)+
000003D2  18FC 0020                421              MOVE.B      #' ',(A4)+
Line 422 ERROR: Undefined symbol
000003D6  4EB9 004DBB8E            422              JSR         DN_SRC      *Move to DN_SRC to start parameter decode sequence
000003DC  4E75                     423              RTS            
000003DE                           424              
000003DE                           425              
000003DE                           426              
000003DE                           427              
000003DE                           428              
000003DE                           429              
000003DE                           430              
000003DE                           431  
000003DE                           432  
Line 433 WARNING: END directive missing, starting address not set

22 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_SIZE            2BA
B_DN                3A2
B_EA                366
B_SIZE              2D2
GET_SIZE_1          31C
GET_SIZE_2          30C
GET_SIZE_3          2FC
JMP_0               C
JMP_0X              13C
JMP_1               1C
JMP_2               2C
JMP_2X              168
JMP_3               3C
JMP_3X              18C
JMP_4               4C
JMP_47X             21A
JMP_4X              1B0
JMP_5               5C
JMP_6               6C
JMP_6X              1F0
JMP_7               7C
JMP_8               8C
JMP_8X              1F6
JMP_9               9C
JMP_A               AC
JMP_B               BC
JMP_C               CC
JMP_CX              1FC
JMP_D               DC
JMP_DX              202
JMP_E               EC
JMP_EX              208
JMP_TBL             0
J_47X               1D8
J_ADDI              160
J_CLR1              11C
J_CLR3              10C
J_CLR4              FC
J_CLR_DM            12C
J_LEA               1E0
J_MOVEAL            17C
J_MOVEAW            1A0
J_MOVEL             184
J_MOVEM             1E8
J_MOVEW             1A8
J_SUBI              158
L_DN                3CA
L_EA                38E
L_SIZE              2EE
OPC_04XX            20E
OPC_05XX            214
OPC_1XXX            21A
OPC_5XXX            244
OPC_7XXX            26C
OPC_9XXX            290
OPC_LEA             2AE
OPC_MOVEAL          2B2
OPC_MOVEAW          2B6
OPC_MOVEL           2B4
OPC_MOVEM           2B0
OPC_MOVEW           2B8
OR_ADD_SIZE         332
W_DN                3B6
W_EA                37A
W_SIZE              2E0
